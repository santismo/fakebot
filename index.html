<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>ü§ñ fakebot</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:rgba(255,255,255,.05);
      --panel2:rgba(0,0,0,.20);
      --ink:#e9eef6;
      --muted:#9aa6b2;
      --line:rgba(255,255,255,.09);

      /* Piano theme (defaults) */
      --accent:#2f6bff;  /* scale fill */
      --good:#3fe18b;    /* root marker */
      --chord:#b67cff;   /* chord marker */

      --keyWhite:#f2f5fb;
      --keyBlack:#161b23;
      --keyBorder:#c9d3e2;
      --keyBlackBorder:#2a3240;

      /* Scale key outline (for separation between blue keys) */
      --scaleStrokeAlpha: 0.88;    /* 0..1 */
      --scaleStrokeWidth: 2.2;     /* px */

      --radius:16px;
      --tap:44px;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:
        radial-gradient(1200px 800px at 30% 10%, rgba(122,162,255,.08), transparent 55%),
        radial-gradient(900px 600px at 90% 30%, rgba(182,124,255,.08), transparent 55%),
        var(--bg);
      color:var(--ink);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      -webkit-font-smoothing: antialiased;
      overflow-x:hidden;
      touch-action: manipulation;
    }

    button, input, select, label {font:inherit}
    button { -webkit-tap-highlight-color: transparent; }
    input[type="range"]{width:100%}

    .app{max-width:1100px;margin:0 auto;padding:14px 12px 22px;}

    .header{
      padding:12px 12px;border:1px solid var(--line);border-radius: var(--radius);
      background: var(--panel);box-shadow: var(--shadow);margin-bottom:12px;
    }
    .headerTop{display:flex;align-items:flex-end;justify-content:space-between;gap:10px;flex-wrap:wrap;}
    h1{margin:0;font-size:18px;font-weight:900;letter-spacing:.2px;}
    .sub{margin-top:2px;color:var(--muted);font-size:12px;}
    .statusLine{margin-top:10px;display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .pill{
      padding:6px 10px;border:1px solid var(--line);border-radius:999px;
      background: rgba(0,0,0,.18);color: var(--muted);font-size:12px;
      user-select:none;white-space:nowrap;
    }
    .pill strong{color:var(--ink);font-weight:900}

    .card{
      border:1px solid var(--line);border-radius: var(--radius);
      background: var(--panel);box-shadow: var(--shadow);
      overflow:hidden;margin-bottom:12px;
    }
    .cardHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      padding:12px 12px;border-bottom:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }
    .title{font-size:12px;color:var(--muted);letter-spacing:.2px;user-select:none;}
    .cardBody{padding:12px}

    .controls{display:grid;grid-template-columns: repeat(6, minmax(0,1fr));gap:10px;}
    @media (max-width: 980px){ .controls{grid-template-columns: repeat(3, minmax(0,1fr));} }
    @media (max-width: 520px){ .controls{grid-template-columns: repeat(2, minmax(0,1fr));} }

    .control{
      padding:10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);
      background: var(--panel2);min-width:0;
    }
    .control label{display:block;font-size:11px;color: rgba(154,166,178,.88);margin-bottom:6px;user-select:none;}
    .inline{display:flex;align-items:center;gap:8px;min-width:0;}
    input[type="number"], select{
      width: 98px;min-height: 38px;background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);color: var(--ink);
      border-radius: 10px;padding: 8px 8px;outline:none;
    }
    select{width:100%}

    .btn{
      min-height: var(--tap);
      padding: 10px 12px;border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color: var(--ink);cursor:pointer;
      display:inline-flex;align-items:center;justify-content:center;gap:8px;
      transition: transform .06s ease, border-color .15s ease;width:100%;
    }
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      border-color: rgba(122,162,255,.45);
      background: linear-gradient(180deg, rgba(122,162,255,.18), rgba(122,162,255,.06));
    }
    .btn.ghost{background: transparent}
    .btn.small{min-height:36px;padding:7px 8px;border-radius:10px;font-size:13px}
    .btn.tiny{min-height:34px;padding:6px 8px;border-radius:10px;font-size:12px}

    .sheet{display:grid;grid-template-columns: repeat(4, minmax(0, 1fr));gap:10px;}
    @media (max-width: 640px){ .sheet{grid-template-columns: repeat(2, minmax(0, 1fr));} }
    .bar{
      position:relative;min-height: 62px;background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);border-radius: 14px;
      padding: 12px 10px 10px;cursor:pointer;
      transition: border-color .15s ease, transform .06s ease, background .15s ease;
      overflow:hidden;user-select:none;
    }
    .bar:active{transform: translateY(1px)}
    .bar.active{border-color: rgba(122,162,255,.70);background: rgba(122,162,255,.08);}
    .bar .sym{font-weight:900;letter-spacing:.2px;font-size:16px;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:28px;}
    .bar .sym2{margin-top:6px;padding-top:6px;border-top:1px solid rgba(255,255,255,.08);}
    .bar .num{position:absolute;top:10px;right:10px;font-size:12px;color: rgba(154,166,178,.55);}

    .bar .halfHit{
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      pointer-events:none;
    }
    .bar .halfHit button{
      flex:1;background:transparent;border:0;padding:0;margin:0;cursor:pointer;pointer-events:auto;
    }
    .bar .halfHit button:active{background: rgba(122,162,255,.06);}
    .bar .halfHit button:first-child{border-bottom:1px solid rgba(255,255,255,.06);}

    .limitGrid{display:grid;grid-template-columns: repeat(3, minmax(0,1fr));gap:10px;}
    @media (max-width: 820px){ .limitGrid{grid-template-columns: repeat(2, minmax(0,1fr));} }
    @media (max-width: 520px){ .limitGrid{grid-template-columns: 1fr;} }

    .checkRow{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .chip{
      display:inline-flex;align-items:center;gap:8px;padding:10px 10px;border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);background: rgba(0,0,0,.18);
      min-height: 44px;user-select:none;
    }
    .chip input{transform: scale(1.1)}
    .chip span{font-size:13px;color: rgba(233,238,246,.92)}

    .legend{display:flex;gap:10px;flex-wrap:wrap;align-items:center;color: var(--muted);font-size:12px;user-select:none;margin-bottom:10px;}
    .dotLegend{display:inline-flex;align-items:center;gap:6px;}
    .sw{width:10px;height:10px;border-radius:999px;border:1px solid rgba(255,255,255,.15);}
    .sw.scale{background: var(--accent); border-color: rgba(47,107,255,.95)}
    .sw.root{background: var(--good); border-color: rgba(63,225,139,.95)}
    .sw.chord{background: var(--chord); border-color: rgba(182,124,255,.95)}

    .pianoBox{border:1px solid rgba(255,255,255,.10);border-radius: 16px;background: rgba(0,0,0,.18);overflow:hidden;}
    svg{display:block;width:100%;height:auto}
    .hint{margin-top:10px;color: rgba(154,166,178,.85);font-size:12px;line-height:1.2;user-select:none;}
    .msg{margin-top:10px;font-size:12px;color: var(--muted);user-select:none;}

    /* Advanced settings modal */
    .modalBack{
      position:fixed;inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:14px;
      z-index:9999;
    }
    .modal{
      width:min(760px,100%);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      background: rgba(12,16,22,.96);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:12px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .modalTitle{font-weight:900;font-size:14px;letter-spacing:.2px;}
    .modalBody{padding:12px}
    .modalRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 10px;border:1px solid rgba(255,255,255,.08);
      border-radius:14px;background: rgba(0,0,0,.22);
      margin-bottom:10px;
    }
    .modalRow .name{font-size:13px;color: rgba(233,238,246,.92);font-weight:800}
    .reorderBtns{display:flex;gap:8px}
    .gearBtn{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 12px;
      min-height: 38px;
      padding:8px 10px;
      cursor:pointer;
      color: var(--ink);
      display:inline-flex;align-items:center;gap:8px;
    }
    .splitLine{height:1px;background: rgba(255,255,255,.10);margin:12px 0;}
    .modalSubTitle{font-size:12px;color: var(--muted);margin:0 0 8px 2px;}
    .modalGrid{display:grid;grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 560px){ .modalGrid{grid-template-columns: 1fr;} }
    .miniCtl{
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .miniCtl label{display:block;font-size:11px;color: rgba(154,166,178,.88);margin-bottom:6px;}
    .miniRow{display:flex;gap:8px;align-items:center;}
    .miniRow input[type="range"]{flex:1}
    .miniRow input[type="number"]{width:86px}
    .hidden{display:none !important;}
  </style>
</head>

<body>
  <div class="app">

    <div class="header">
      <div class="headerTop">
        <div>
          <h1>ü§ñ fakebot</h1>
          <div class="sub">random charts ¬∑ band ¬∑ keyboard display</div>
        </div>
        <div style="min-width:220px; width:min(420px,100%);">
          <button class="btn ghost" id="btnCopy" style="width:32%; display:inline-flex;">Copy</button>
          <button class="btn" id="btnDefaults" style="width:32%; display:inline-flex; margin:0 1%;">Defaults</button>
          <button class="btn primary" id="btnPlay" style="width:32%; display:inline-flex; float:right;">Play</button>
          <div style="clear:both"></div>
        </div>
      </div>

      <div class="statusLine">
        <span class="pill" id="pillLine">‚Äî</span>
        <span class="pill">Bars: <strong id="metaBars">4</strong></span>
        <span class="pill">Tempo: <strong id="metaTempo">120</strong></span>
        <span class="pill">Swing: <strong id="metaSwing">60</strong></span>
        <span class="pill">Chaos: <strong id="metaChaos">50</strong></span>
        <span class="pill" id="metaHalves" style="display:none;">¬Ω-bars: <strong id="metaHalvesVal">0</strong></span>
      </div>

      <div class="msg" id="msg">Tip: tap a bar (or half) to focus the piano + band on that chord (and preview it).</div>
    </div>

    <!-- LEAD SHEET -->
    <section class="card" id="cardLead">
      <div class="cardHead">
        <div class="title">Lead sheet</div>
        <div class="title" id="leadKey">‚Äî</div>
      </div>
      <div class="cardBody">
        <div class="sheet" id="sheet"></div>
      </div>
    </section>

    <!-- PIANO -->
    <section class="card" id="cardPiano">
      <div class="cardHead">
        <div class="title">üéπ</div>
        <div class="title" id="pianoTop">‚Äî</div>
      </div>
      <div class="cardBody">
        <div class="legend">
          <span class="dotLegend"><span class="sw scale"></span>Scale tones</span>
          <span class="dotLegend"><span class="sw root"></span>Root</span>
          <span class="dotLegend"><span class="sw chord"></span>Chord tones</span>
        </div>
        <div class="pianoBox">
          <svg id="pianoSvg" viewBox="0 0 1000 240" preserveAspectRatio="none" aria-label="Piano keyboard"></svg>
        </div>
        <div class="hint" id="pianoHint">‚Äî</div>
      </div>
    </section>

    <!-- Controls -->
    <section class="card" id="cardControls">
      <div class="cardHead">
        <div class="title">Controls</div>
        <button class="gearBtn" id="btnGear" aria-label="Advanced settings" title="Advanced settings">
          ‚öôÔ∏è <span style="font-size:12px;color:var(--muted);">Advanced</span>
        </button>
      </div>

      <div class="cardBody">
        <div class="controls" id="controlsGrid">

          <div class="control" data-ctl="generate">
            <label>Generate</label>
            <div class="inline" style="gap:6px">
              <button class="btn primary tiny" id="btnGenerate" style="flex:1">üé∞</button>
              <button class="btn tiny" id="btnRandom" style="flex:1">üé≤</button>
              <button class="btn tiny" id="btnDefaults2" style="flex:1">‚Ü©Ô∏é</button>
            </div>
          </div>

          <div class="control" data-ctl="genre">
            <label>Genre preset</label>
            <select id="genrePreset">
              <option value="jazzSwing" selected>Jazz Swing (default)</option>
              <option value="bebop">Bebop Burner</option>
              <option value="balladJazz">Jazz Ballad</option>
              <option value="modalJazz">Modal / Spiritual</option>
              <option value="bossa">Bossa Nova</option>
              <option value="afroCuban">Afro-Cuban</option>
              <option value="funk">Funk</option>
              <option value="hiphop">Hip-Hop</option>
              <option value="house">House</option>
              <option value="dnb">Drum & Bass</option>
              <option value="ambient">Ambient Minimal</option>
              <option value="free">Free / Broken</option>
            </select>
            <div class="msg" style="margin:6px 0 0 0;">yeah</div>
          </div>

          <div class="control" data-ctl="bars">
            <label>Bars (2‚Äì16)</label>
            <div class="inline">
              <input id="bars" type="range" min="2" max="16" value="4">
              <input id="barsNum" type="number" min="2" max="16" value="4">
            </div>
          </div>

          <div class="control" data-ctl="half">
            <label>2 chords / bar (random bars)</label>
            <div class="checkRow" style="margin-bottom:8px;">
              <label class="chip" style="width:100%;justify-content:space-between;">
                <span>Enable occasional ¬Ω-bars</span>
                <input type="checkbox" id="halfChords">
              </label>
            </div>
            <div class="inline">
              <input id="halfDensity" type="range" min="0" max="100" value="40">
              <input id="halfDensityNum" type="number" min="0" max="100" value="40">
            </div>
            <div class="msg" style="margin:6px 0 0 0;">Density %</div>
          </div>

          <div class="control" data-ctl="compStyle">
            <label>Keys play style</label>
            <select id="compStyle">
              <option value="twoStabs" selected>2 stabs (default)</option>
              <option value="fourComp">4-to-the-bar</option>
              <option value="charleston">Charleston</option>
              <option value="anticipations">Anticipations</option>
              <option value="pushPull">Push / pull</option>
              <option value="sparse">Sparse sync</option>
              <option value="arpeggio">Arpeggio flutter</option>
              <option value="sustain">Sustain pad</option>
              <option value="montuno">Montuno (latin)</option>
              <option value="clav">Clav comp (funk)</option>
              <option value="houseChop">House chops</option>
            </select>
          </div>

          <div class="control" data-ctl="tempo">
            <label>Tempo</label>
            <div class="inline">
              <input id="tempo" type="range" min="60" max="220" value="120">
              <input id="tempoNum" type="number" min="40" max="300" value="120">
            </div>
          </div>

          <div class="control" data-ctl="swing">
            <label>Swing</label>
            <div class="inline">
              <input id="swing" type="range" min="50" max="75" value="60">
              <input id="swingNum" type="number" min="50" max="80" value="60">
            </div>
          </div>

          <div class="control" data-ctl="chaos">
            <label>Chaos</label>
            <div class="inline">
              <input id="chaos" type="range" min="0" max="100" value="50">
              <input id="chaosNum" type="number" min="0" max="100" value="50">
            </div>
          </div>

          <div class="control" data-ctl="rootMode">
            <label>Root mode</label>
            <select id="rootMode">
              <option value="keyed" selected>Keyed</option>
              <option value="drifting">Drifting</option>
              <option value="orbiting">Orbiting</option>
              <option value="freefall">Freefall</option>
            </select>
          </div>

          <div class="control" data-ctl="groove">
            <label>Groove (drums)</label>
            <select id="grooveStyle">
              <option value="swing" selected>Swing ride</option>
              <option value="brushBallad">Brush ballad</option>
              <option value="bossa">Bossa</option>
              <option value="afroCuban">Afro-Cuban</option>
              <option value="funk">Funk</option>
              <option value="hiphop">Hip-hop</option>
              <option value="house">House</option>
              <option value="dnb">DnB</option>
              <option value="breaks">Breakbeat</option>
              <option value="ambient">Ambient ticks</option>
              <option value="free">Free cymbals</option>
            </select>
          </div>

          <div class="control" data-ctl="bassPreset">
            <label>Bass sound (minimal)</label>
            <select id="bassPreset">
              <option value="upright" selected>Upright</option>
              <option value="round">Round</option>
              <option value="sub">Sub</option>
              <option value="pluck">Pluck</option>
              <option value="fmBass">FM bass</option>
              <option value="rubber">Rubber</option>
              <option value="acid">Acid</option>
              <option value="reese">Reese</option>
              <option value="squareBass">Square bass</option>
              <option value="wobble">Wobble</option>
            </select>
          </div>

          <div class="control" data-ctl="keysPreset">
            <label>Keys sound (minimal)</label>
            <select id="keysPreset">
              <option value="ep" selected>EP</option>
              <option value="piano">Piano</option>
              <option value="organ">Organ</option>
              <option value="pad">Pad</option>
              <option value="fm">FM keys</option>
              <option value="chip">Chip</option>
              <option value="bell">Bell</option>
              <option value="glass">Glass</option>
              <option value="pluck2">Pluck 2</option>
              <option value="vibes">Vibes</option>
              <option value="choirPad">Choir pad</option>
              <option value="noisePad">Noise pad</option>
            </select>
          </div>

          <div class="control" data-ctl="drumsPreset">
            <label>Drums sound (minimal)</label>
            <select id="drumsPreset">
              <option value="jazz" selected>Jazz kit</option>
              <option value="brushes">Brushes</option>
              <option value="tight">Tight</option>
              <option value="lofi">Lo-fi</option>
              <option value="minimal">Minimal clicks</option>
              <option value="electro">Electro</option>
              <option value="house">House</option>
              <option value="trap">Trap hats</option>
              <option value="perc">Perc kit</option>
              <option value="dnb">DnB kit</option>
            </select>
          </div>

          <div class="control" data-ctl="drumsLevel">
            <label>Drums level</label>
            <div class="inline">
              <input id="drumsLevel" type="range" min="0" max="100" value="55">
              <input id="drumsLevelNum" type="number" min="0" max="100" value="55">
            </div>
          </div>

          <!-- NEW: Fill + Complexity per instrument -->
          <div class="control" data-ctl="keysFeel">
            <label>Keys: complexity / fills</label>
            <div class="inline" style="margin-bottom:8px;">
              <input id="keysComplex" type="range" min="0" max="100" value="55">
              <input id="keysComplexNum" type="number" min="0" max="100" value="55">
            </div>
            <div class="inline">
              <input id="keysFill" type="range" min="0" max="100" value="35">
              <input id="keysFillNum" type="number" min="0" max="100" value="35">
            </div>
            <div class="msg" style="margin:6px 0 0 0;">mhm</div>
          </div>

          <div class="control" data-ctl="bassFeel">
            <label>Bass: complexity / fills</label>
            <div class="inline" style="margin-bottom:8px;">
              <input id="bassComplex" type="range" min="0" max="100" value="55">
              <input id="bassComplexNum" type="number" min="0" max="100" value="55">
            </div>
            <div class="inline">
              <input id="bassFill" type="range" min="0" max="100" value="30">
              <input id="bassFillNum" type="number" min="0" max="100" value="30">
            </div>
            <div class="msg" style="margin:6px 0 0 0;">oooh</div>
          </div>

          <div class="control" data-ctl="drumsFeel">
            <label>Drums: complexity / fills</label>
            <div class="inline" style="margin-bottom:8px;">
              <input id="drumsComplex" type="range" min="0" max="100" value="60">
              <input id="drumsComplexNum" type="number" min="0" max="100" value="60">
            </div>
            <div class="inline">
              <input id="drumsFill" type="range" min="0" max="100" value="40">
              <input id="drumsFillNum" type="number" min="0" max="100" value="40">
            </div>
            <div class="msg" style="margin:6px 0 0 0;">pshh</div>
          </div>

        </div>
      </div>
    </section>

    <!-- CHORD LIMITERS -->
    <section class="card" id="cardLimiters">
      <div class="cardHead">
        <div class="title">Chord limiters</div>
        <div class="title">üß©</div>
      </div>
      <div class="cardBody">
        <div class="limitGrid">
          <div class="control">
            <label>Core qualities</label>
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="qMaj7" checked><span>maj7</span></label>
              <label class="chip"><input type="checkbox" id="qMin7" checked><span>m7</span></label>
              <label class="chip"><input type="checkbox" id="qDom7" checked><span>7</span></label>
              <label class="chip"><input type="checkbox" id="qDim7" checked><span>dim7</span></label>
              <label class="chip"><input type="checkbox" id="qHalfDim"><span>√∏7</span></label>
              <label class="chip"><input type="checkbox" id="qSus"><span>sus</span></label>
              <label class="chip"><input type="checkbox" id="qMinMaj"><span>mMaj7</span></label>
            </div>
          </div>

          <div class="control">
            <label>Extensions</label>
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="x9"><span>9</span></label>
              <label class="chip"><input type="checkbox" id="x11"><span>11</span></label>
              <label class="chip"><input type="checkbox" id="x13"><span>13</span></label>
              <label class="chip"><input type="checkbox" id="x6"><span>6 / 6-9</span></label>
              <label class="chip"><input type="checkbox" id="xAdd9"><span>add9</span></label>
              <label class="chip"><input type="checkbox" id="xSharp11"><span>#11</span></label>
              <label class="chip"><input type="checkbox" id="xMin11"><span>m11</span></label>
            </div>
          </div>

          <div class="control">
            <label>Tension</label>
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="tAlt"><span>alt dom</span></label>
              <label class="chip"><input type="checkbox" id="tSlash"><span>slash</span></label>
              <label class="chip"><input type="checkbox" id="tChrom"><span>chromatic</span></label>
              <label class="chip"><input type="checkbox" id="tB9"><span>‚ô≠9</span></label>
              <label class="chip"><input type="checkbox" id="tSharp9"><span>#9</span></label>
            </div>
          </div>
        </div>

        <div class="msg" style="margin-top:12px;">üé∂</div>
      </div>
    </section>

  </div>

  <!-- Advanced Settings Modal -->
  <div class="modalBack" id="advBack" role="dialog" aria-modal="true" aria-label="Advanced settings">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle">Advanced settings</div>
        <div class="reorderBtns">
          <button class="btn small" id="btnResetMenu">Reset</button>
          <button class="btn primary small" id="btnCloseAdv">Done</button>
        </div>
      </div>
      <div class="modalBody">
        <div class="msg" style="margin:0 0 10px 0;">Menu order (main sections). Theme + marker style + theme sliders live here.</div>
        <div id="orderList"></div>

        <div class="splitLine"></div>
        <div class="modalSubTitle">Piano display theme</div>

        <div class="modalGrid">
          <div class="miniCtl">
            <label>Piano theme</label>
            <select id="pianoTheme">
              <option value="classic" selected>Classic</option>
              <option value="neon">Neon</option>
              <option value="mono">Mono</option>
              <option value="pastel">Pastel</option>
            </select>
          </div>

          <div class="miniCtl">
            <label>Tone markers</label>
            <select id="markerStyle">
              <option value="dots" selected>Dots</option>
              <option value="rings">Rings</option>
              <option value="triangles">Triangles</option>
              <option value="squares">Squares</option>
            </select>
          </div>

          <div class="miniCtl">
            <label>Scale key outline width</label>
            <div class="miniRow">
              <input id="scaleOutlineW" type="range" min="0.8" max="4.0" step="0.1" value="2.2">
              <input id="scaleOutlineWNum" type="number" min="0.8" max="4.0" step="0.1" value="2.2">
            </div>
          </div>

          <div class="miniCtl">
            <label>Scale key outline darkness</label>
            <div class="miniRow">
              <input id="scaleOutlineA" type="range" min="0" max="100" step="1" value="88">
              <input id="scaleOutlineANum" type="number" min="0" max="100" step="1" value="88">
            </div>
          </div>
        </div>

        <div class="msg" style="margin-top:10px;">Tip: advanced settings save locally in your browser.</div>
      </div>
    </div>
  </div>

<script>
/* =========================================================
   UPDATED (per your request):
   ‚úÖ Removed SoundFont option entirely (minimal synth only)
   ‚úÖ Dozens of minimalist ‚Äúsounds‚Äù (keys + bass + drums)
   ‚úÖ Genre presets that set groove + typical tempo/swing + default fill/complexity
   ‚úÖ Per-instrument Fill Amount + Complexity sliders
   ‚úÖ Lots of randomized ‚Äúfill shapes‚Äù so it doesn‚Äôt repeat the same fill
   ‚úÖ Groove styles expanded across jazz + many genres (drums + bass + keys respond)
   ========================================================= */

const NOTE_NAMES = ["C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"];
const WHITE_PCS = new Set([0,2,4,5,7,9,11]);

const SCALES = {
  ionian:[0,2,4,5,7,9,11],
  dorian:[0,2,3,5,7,9,10],
  phryg:[0,1,3,5,7,8,10],
  lydian:[0,2,4,6,7,9,11],
  mixo:  [0,2,4,5,7,9,10],
  aeolian:[0,2,3,5,7,8,10],
  locrian:[0,1,3,5,6,8,10],
  melodicMinor:[0,2,3,5,7,9,11],
  lydianDom:[0,2,4,6,7,9,10],
  altered:[0,1,3,4,6,8,10],
};

const CHORDS = {
  maj7:[0,4,7,11],
  maj9:[0,4,7,11,14],
  maj6:[0,4,7,9],
  "6/9":[0,4,7,9,14],
  add9:[0,4,7,14],
  maj9sharp11:[0,4,7,11,14,18],

  min7:[0,3,7,10],
  min9:[0,3,7,10,14],
  min6:[0,3,7,9],
  min11:[0,3,7,10,14,17],

  minMaj7:[0,3,7,11],
  minMaj9:[0,3,7,11,14],

  dom7:[0,4,7,10],
  dom9:[0,4,7,10,14],
  dom11:[0,4,7,10,14,17],
  dom13:[0,4,7,10,14,21],
  dom7b9:[0,4,7,10,13],
  dom7sharp9:[0,4,7,10,15],

  sus:[0,5,7,10],
  "7sus":[0,5,7,10,14],

  halfdim:[0,3,6,10],
  dim7:[0,3,6,9],
};

function clamp(n,a,b){ return Math.max(a, Math.min(b,n)); }
function rint(a,b){ return Math.floor(a + Math.random()*(b-a+1)); }
function pick(arr){ return arr[Math.floor(Math.random()*arr.length)]; }
function chance(p){ return Math.random() < p; }
function pc(n){ return ((n%12)+12)%12; }
function noteName(p){ return NOTE_NAMES[pc(p)]; }

function weightedPick(opts){
  const sum = opts.reduce((s,o)=>s+o.w,0);
  let t = Math.random()*sum;
  for (const o of opts){ t -= o.w; if (t<=0) return o.v; }
  return opts[opts.length-1].v;
}

function chordName(ch){
  const base = `${noteName(ch.root)}${ch.symbol}`;
  return (ch.slash!=null) ? `${base}/${noteName(ch.slash)}` : base;
}
function chordTonesPCs(ch){
  return [...new Set(ch.intervals.map(i=>pc(ch.root+i)))];
}

function macroToWeights(chaos){
  const c = clamp(chaos,0,100)/100;
  return {
    keyStability: Math.round(85 - c*75),
    functional:   Math.round(80 - c*70),
    rootChaos:    Math.round(15 + c*80),
    qualityChaos: Math.round(15 + c*75),
    tension:      Math.round(10 + c*80),
    memoryKill:   Math.round(40 + c*50),
  };
}

function pickKeyMode(chaos){
  const c = clamp(chaos,0,100)/100;
  return weightedPick([
    {v:"ionian", w: 55 - c*15},
    {v:"dorian", w: 16 + c*10},
    {v:"mixo",   w: 16 + c*10},
    {v:"lydian", w:  7 + c*8},
    {v:"aeolian",w:  5 + c*6},
    {v:"locrian",w:  1 + c*5},
  ]);
}

/* Limiters */
function getChordLimiterState(){
  return {
    qMaj7: document.getElementById("qMaj7").checked,
    qMin7: document.getElementById("qMin7").checked,
    qDom7: document.getElementById("qDom7").checked,
    qDim7: document.getElementById("qDim7").checked,
    qHalfDim: document.getElementById("qHalfDim").checked,
    qSus: document.getElementById("qSus").checked,
    qMinMaj: document.getElementById("qMinMaj").checked,

    x9: document.getElementById("x9").checked,
    x11: document.getElementById("x11").checked,
    x13: document.getElementById("x13").checked,
    x6: document.getElementById("x6").checked,
    xAdd9: document.getElementById("xAdd9").checked,
    xSharp11: document.getElementById("xSharp11").checked,
    xMin11: document.getElementById("xMin11").checked,

    tAlt: document.getElementById("tAlt").checked,
    tSlash: document.getElementById("tSlash").checked,
    tChrom: document.getElementById("tChrom").checked,
    tB9: document.getElementById("tB9").checked,
    tSharp9: document.getElementById("tSharp9").checked,
  };
}
function setChordLimiterState(s){
  for (const k of Object.keys(s)){
    const el = document.getElementById(k);
    if (el && el.type === "checkbox") el.checked = !!s[k];
  }
}

function buildQualityOptions(limit){
  const opts = [];

  if (limit.qMaj7){
    opts.push({v:{symbol:"maj7", family:"maj", key:"maj7", display:"maj7"}, w:22});
    if (limit.x9) opts.push({v:{symbol:"maj9", family:"maj", key:"maj9", display:"maj9"}, w:12});
    if (limit.x6) opts.push({v:{symbol:"6/9", family:"maj", key:"6/9", display:"6/9"}, w:10});
    if (limit.x6) opts.push({v:{symbol:"maj6", family:"maj", key:"maj6", display:"6"}, w:7});
    if (limit.xAdd9) opts.push({v:{symbol:"add9", family:"maj", key:"add9", display:"add9"}, w:7});
    if (limit.xSharp11 || limit.x11) opts.push({v:{symbol:"maj9sharp11", family:"maj", key:"maj9sharp11", display:"maj9(#11)"}, w:7});
  }

  if (limit.qMin7){
    opts.push({v:{symbol:"min7", family:"min", key:"min7", display:"m7"}, w:20});
    if (limit.x9) opts.push({v:{symbol:"min9", family:"min", key:"min9", display:"m9"}, w:12});
    if (limit.x6) opts.push({v:{symbol:"min6", family:"min", key:"min6", display:"m6"}, w:8});
    if (limit.xMin11 || limit.x11) opts.push({v:{symbol:"min11", family:"min", key:"min11", display:"m11"}, w:8});
  }

  if (limit.qDom7){
    opts.push({v:{symbol:"dom7", family:"dom", key:"dom7", display:"7"}, w:22});
    if (limit.x9) opts.push({v:{symbol:"dom9", family:"dom", key:"dom9", display:"9"}, w:14});
    if (limit.x11) opts.push({v:{symbol:"dom11", family:"dom", key:"dom11", display:"11"}, w:9});
    if (limit.x13) opts.push({v:{symbol:"dom13", family:"dom", key:"dom13", display:"13"}, w:12});
    if (limit.tB9) opts.push({v:{symbol:"dom7b9", family:"dom", key:"dom7b9", display:"7(b9)"}, w:7});
    if (limit.tSharp9) opts.push({v:{symbol:"dom7sharp9", family:"dom", key:"dom7sharp9", display:"7(#9)"}, w:7});
  }

  if (limit.qMinMaj){
    opts.push({v:{symbol:"minMaj7", family:"minmaj", key:"minMaj7", display:"mMaj7"}, w:7});
    if (limit.x9) opts.push({v:{symbol:"minMaj9", family:"minmaj", key:"minMaj9", display:"mMaj9"}, w:5});
  }

  if (limit.qHalfDim) opts.push({v:{symbol:"halfdim", family:"hdim", key:"halfdim", display:"√∏7"}, w:10});
  if (limit.qDim7)    opts.push({v:{symbol:"dim7", family:"dim", key:"dim7", display:"dim7"}, w:8});
  if (limit.qSus){
    opts.push({v:{symbol:"sus", family:"sus", key:"sus", display:"sus"}, w:6});
    if (limit.x9) opts.push({v:{symbol:"7sus", family:"sus", key:"7sus", display:"7sus"}, w:6});
  }

  if (!opts.length) opts.push({v:{symbol:"dom7", family:"dom", key:"dom7", display:"7"}, w:1});
  return opts;
}

/* chord-local scale */
function candidatesForChord(ch){
  const hasSharp11 = chordTonesPCs(ch).includes(pc(ch.root + 6)) || ch.symbol.includes("#11");
  if (ch.family === "maj"){
    return hasSharp11 ? ["lydian","ionian"] : ["ionian","lydian"];
  }
  if (ch.family === "min"){
    return ["dorian","aeolian","phryg"];
  }
  if (ch.family === "minmaj"){
    return ["melodicMinor","dorian","aeolian"];
  }
  if (ch.family === "dom"){
    const hasSharp11Dom = chordTonesPCs(ch).includes(pc(ch.root+6));
    return hasSharp11Dom ? ["lydianDom","mixo","altered"] : ["mixo","lydianDom","altered"];
  }
  if (ch.family === "sus"){
    return ["mixo","dorian"];
  }
  if (ch.family === "hdim" || ch.family === "dim"){
    return ["locrian"];
  }
  return ["mixo"];
}

function scoreModeForContext(ch, mode, prevCh, nextCh){
  const scale = SCALES[mode] || SCALES.mixo;
  const scalePC = new Set(scale.map(i=>pc(ch.root+i)));

  const ctxPCs = [];
  if (prevCh) ctxPCs.push(...chordTonesPCs(prevCh));
  if (nextCh) ctxPCs.push(...chordTonesPCs(nextCh));
  if (prevCh && prevCh.slash!=null) ctxPCs.push(pc(prevCh.slash));
  if (nextCh && nextCh.slash!=null) ctxPCs.push(pc(nextCh.slash));

  let score = 0;
  for (const p of ctxPCs){
    if (scalePC.has(p)) score += 2;
  }

  if (mode==="ionian") score += 1.2;
  if (mode==="dorian") score += 1.1;
  if (mode==="mixo") score += 1.0;
  if (mode==="lydian") score += 0.6;
  if (mode==="aeolian") score += 0.6;
  if (mode==="phryg") score += 0.2;
  if (mode==="altered") score += 0.2;
  if (mode==="lydianDom") score += 0.4;
  if (mode==="melodicMinor") score += 0.8;

  const chordPCs = chordTonesPCs(ch);
  if (chordPCs.includes(pc(ch.root+6))){
    if (mode==="lydian" || mode==="lydianDom") score += 2.5;
    if (mode==="ionian" || mode==="mixo") score -= 0.5;
  }
  return score;
}

function chooseChordLocalMode(ch, prevCh, nextCh){
  const cand = candidatesForChord(ch);
  let best = cand[0], bestScore = -1e9;
  for (const m of cand){
    const s = scoreModeForContext(ch, m, prevCh, nextCh);
    if (s > bestScore){ bestScore = s; best = m; }
  }
  return best;
}

function scalePCsForChordLocal(ch, prevCh, nextCh){
  const mode = chooseChordLocalMode(ch, prevCh, nextCh);
  const base = SCALES[mode] || SCALES.mixo;

  const pcs = new Set();
  base.forEach(i => pcs.add(pc(ch.root + i)));
  chordTonesPCs(ch).forEach(p=>pcs.add(p));
  if (ch.slash!=null) pcs.add(pc(ch.slash));

  return { pcs:[...pcs], mode };
}

/* chart generator */
function genChartBars({bars, chaos, rootMode, weights, limiter, halfEnabled, halfDensity}){
  let keyRoot = rint(0,11);
  let keyMode = pickKeyMode(chaos);
  let orbitRoot = keyRoot;

  const qualityPool = buildQualityOptions(limiter);

  const density = clamp(halfDensity,0,100)/100;
  const barSplit = [];
  for (let i=0;i<bars;i++){
    if (!halfEnabled) barSplit.push(false);
    else {
      const p = (i===0) ? density*0.6 : density;
      barSplit.push(chance(p));
    }
  }
  const halvesCount = barSplit.filter(Boolean).length;

  const slotPlan = [];
  for (let b=0;b<bars;b++){
    if (!barSplit[b]){
      slotPlan.push({barIndex:b, halfIndex:0, beats:4});
    } else {
      slotPlan.push({barIndex:b, halfIndex:0, beats:2});
      slotPlan.push({barIndex:b, halfIndex:1, beats:2});
    }
  }

  const memory = { lastRoots:[], lastQuals:[] };
  function remember(root, qualKey){
    memory.lastRoots.unshift(root); if(memory.lastRoots.length>7) memory.lastRoots.pop();
    memory.lastQuals.unshift(qualKey); if(memory.lastQuals.length>7) memory.lastQuals.pop();
  }
  function memoryBlocks(root, qualKey){
    const kill = clamp(weights.memoryKill,0,100)/100;
    if (kill <= 0.05) return false;
    const blockRoot = memory.lastRoots.includes(root) && chance(kill*0.85);
    const blockQual = memory.lastQuals.includes(qualKey) && chance(kill*0.65);
    return blockRoot || blockQual;
  }

  const DEG = { I:0, ii:2, iii:4, IV:5, V:7, VI:9, vii√∏:11, bVII:10, bVI:8, i:0, ii√∏:2 };
  const funcCells = [
    ["ii","V","I","I"],
    ["I","VI","ii","V"],
    ["iii","VI","ii","V"],
    ["I","IV","bVII","I"],
    ["i","bVI","ii√∏","V"],
  ];
  function degreeToRoot(deg, baseRoot){ return pc(baseRoot + (DEG[deg] ?? rint(0,11))); }

  function chooseNextRoot(prevRoot, meta){
    const c = clamp(weights.rootChaos,0,100)/100;
    let cling = clamp(clamp(weights.keyStability,0,100)/100 * (1 - (chaos/100)*0.65), 0, 1);

    if (rootMode === "keyed") cling = Math.max(cling, 0.78);
    if (rootMode === "freefall") cling = Math.min(cling, 0.10);

    if (rootMode === "drifting" && chance((chaos/100)*0.25)){
      keyRoot = pc(keyRoot + pick([1,2,3,5,7,10,11]) * (chance(.5)?1:-1));
      keyMode = pickKeyMode(chaos);
    }
    if (rootMode === "orbiting" && chance((chaos/100)*0.18)){
      orbitRoot = pc(orbitRoot + pick([2,3,5,7,9,10]) * (chance(.5)?1:-1));
    }

    const funcBias = clamp(weights.functional,0,100)/100;
    const useFunctional = chance(funcBias * (1 - (chaos/100)*0.55));
    const isBarStart = (meta.halfIndex===0);
    if (useFunctional && isBarStart && (meta.barIndex % 4 === 0) && limiter.tChrom){
      const cell = pick(funcCells);
      const base = (rootMode==="orbiting") ? orbitRoot : keyRoot;
      return degreeToRoot(cell[0], base);
    }

    const jumpsSane = [2,5,7,10,3,4,9,8,1,11];
    const jumpsWild = [0,1,2,3,4,5,6,7,8,9,10,11];
    const anchor = chance(cling);

    if (anchor){
      const base = (rootMode==="orbiting") ? orbitRoot : keyRoot;
      const scale = SCALES[keyMode] || SCALES.ionian;
      let target = pc(base + pick(scale));
      if (limiter.tChrom && chance(c*0.25)) target = pc(target + (chance(.5)?1:-1));
      return target;
    } else {
      if (prevRoot == null) return rint(0,11);
      const pool = chance(c) ? jumpsWild : jumpsSane;
      const step = pick(pool);
      if (pool !== jumpsWild || chance(0.6)){
        return pc(prevRoot + step * (chance(.5)?1:-1));
      } else {
        return rint(0,11);
      }
    }
  }

  function chooseQuality(){
    const qC = clamp(weights.qualityChaos,0,100)/100;
    const tweaked = qualityPool.map(o=>{
      const boost = (chance(qC*0.55) ? (1 + Math.random()*0.35) : 1);
      return {v:o.v, w:o.w*boost};
    });
    return weightedPick(tweaked);
  }

  const slots = [];
  let prevRoot = null;

  for (let i=0;i<slotPlan.length;i++){
    const meta = slotPlan[i];

    let root = chooseNextRoot(prevRoot, meta);
    let q = chooseQuality();

    let guard=0;
    while (memoryBlocks(root, q.key) && guard<8){
      root = chooseNextRoot(prevRoot, meta);
      q = chooseQuality();
      guard++;
    }

    let intervals = (CHORDS[q.symbol] || CHORDS.dom7).slice();
    let label = q.display;

    const tC = clamp(weights.tension,0,100)/100;
    const canAlt = limiter.tAlt && (q.family === "dom") && chance(tC*0.55) && chance((chaos/100)*0.75);
    if (canAlt){
      label = (label === "7" ? "7alt" : (label === "9" ? "9alt" : label + "alt"));
      if (!intervals.includes(14)) intervals.push(14);
      if (chance(0.55)) intervals.push(13);
      if (chance(0.35)) intervals.push(15);
      if (chance(0.35)) intervals.push(18);
    }

    let slash = null;
    if (limiter.tSlash && rootMode !== "keyed"){
      const slashChance = clamp((chaos/100)*0.30, 0, 0.30);
      if (chance(slashChance)){
        slash = pc(root + pick([2,5,7,9,10]) * (chance(.5)?1:-1));
        if (slash === root) slash = pc(root+7);
      }
    }

    slots.push({ root, family:q.family, symbol:label, intervals, slash, meta });
    remember(root, q.key);
    prevRoot = root;
  }

  const barsOut = [];
  for (let b=0;b<bars;b++){
    const s = slots.filter(x=>x.meta.barIndex===b).sort((a,b2)=>a.meta.halfIndex-b2.meta.halfIndex);
    barsOut.push({
      chords: s.map(x=>({root:x.root,family:x.family,symbol:x.symbol,intervals:x.intervals,slash:x.slash})),
      split: barSplit[b] && s.length===2
    });
  }

  const showKey = !(rootMode === "freefall" || clamp(weights.keyStability,0,100) < 25);
  return { bars: barsOut, keyRoot, keyMode, showKey, halvesCount };
}

/* UI refs */
const els = {
  pillLine: document.getElementById("pillLine"),
  leadKey: document.getElementById("leadKey"),
  metaBars: document.getElementById("metaBars"),
  metaTempo: document.getElementById("metaTempo"),
  metaSwing: document.getElementById("metaSwing"),
  metaChaos: document.getElementById("metaChaos"),
  metaHalves: document.getElementById("metaHalves"),
  metaHalvesVal: document.getElementById("metaHalvesVal"),
  msg: document.getElementById("msg"),

  sheet: document.getElementById("sheet"),

  pianoSvg: document.getElementById("pianoSvg"),
  pianoTop: document.getElementById("pianoTop"),
  pianoHint: document.getElementById("pianoHint"),

  btnGenerate: document.getElementById("btnGenerate"),
  btnRandom: document.getElementById("btnRandom"),
  btnCopy: document.getElementById("btnCopy"),
  btnPlay: document.getElementById("btnPlay"),
  btnDefaults: document.getElementById("btnDefaults"),
  btnDefaults2: document.getElementById("btnDefaults2"),

  genrePreset: document.getElementById("genrePreset"),
  grooveStyle: document.getElementById("grooveStyle"),

  bars: document.getElementById("bars"),
  barsNum: document.getElementById("barsNum"),
  halfChords: document.getElementById("halfChords"),
  halfDensity: document.getElementById("halfDensity"),
  halfDensityNum: document.getElementById("halfDensityNum"),
  compStyle: document.getElementById("compStyle"),

  tempo: document.getElementById("tempo"),
  tempoNum: document.getElementById("tempoNum"),
  swing: document.getElementById("swing"),
  swingNum: document.getElementById("swingNum"),
  chaos: document.getElementById("chaos"),
  chaosNum: document.getElementById("chaosNum"),
  rootMode: document.getElementById("rootMode"),

  bassPreset: document.getElementById("bassPreset"),
  keysPreset: document.getElementById("keysPreset"),
  drumsPreset: document.getElementById("drumsPreset"),
  drumsLevel: document.getElementById("drumsLevel"),
  drumsLevelNum: document.getElementById("drumsLevelNum"),

  keysComplex: document.getElementById("keysComplex"),
  keysComplexNum: document.getElementById("keysComplexNum"),
  keysFill: document.getElementById("keysFill"),
  keysFillNum: document.getElementById("keysFillNum"),

  bassComplex: document.getElementById("bassComplex"),
  bassComplexNum: document.getElementById("bassComplexNum"),
  bassFill: document.getElementById("bassFill"),
  bassFillNum: document.getElementById("bassFillNum"),

  drumsComplex: document.getElementById("drumsComplex"),
  drumsComplexNum: document.getElementById("drumsComplexNum"),
  drumsFill: document.getElementById("drumsFill"),
  drumsFillNum: document.getElementById("drumsFillNum"),

  controlsGrid: document.getElementById("controlsGrid"),
  btnGear: document.getElementById("btnGear"),

  advBack: document.getElementById("advBack"),
  orderList: document.getElementById("orderList"),
  btnCloseAdv: document.getElementById("btnCloseAdv"),
  btnResetMenu: document.getElementById("btnResetMenu"),

  pianoTheme: document.getElementById("pianoTheme"),
  markerStyle: document.getElementById("markerStyle"),
  scaleOutlineW: document.getElementById("scaleOutlineW"),
  scaleOutlineWNum: document.getElementById("scaleOutlineWNum"),
  scaleOutlineA: document.getElementById("scaleOutlineA"),
  scaleOutlineANum: document.getElementById("scaleOutlineANum"),
};

/* Defaults */
const DEFAULTS = {
  bars: 4,
  halfEnabled: false,
  halfDensity: 40,
  tempo: 120,
  swing: 60,
  chaos: 50,
  rootMode: "keyed",
  genrePreset: "jazzSwing",
  grooveStyle: "swing",
  compStyle: "twoStabs",

  bassPreset: "upright",
  keysPreset: "ep",
  drumsPreset: "jazz",
  drumsLevel: 55,

  keysComplex: 55,
  keysFill: 35,
  bassComplex: 55,
  bassFill: 30,
  drumsComplex: 60,
  drumsFill: 40,

  limiter: {
    qMaj7:true, qMin7:true, qDom7:true, qDim7:true,
    qHalfDim:false, qSus:false, qMinMaj:false,
    x9:false, x11:false, x13:false, x6:false, xAdd9:false, xSharp11:false, xMin11:false,
    tAlt:false, tSlash:false, tChrom:false, tB9:false, tSharp9:false,
  },

  pianoTheme: "classic",
  markerStyle: "dots",
  scaleStrokeWidth: 2.2,
  scaleStrokeAlphaPct: 88,
};

let state = {
  bars: DEFAULTS.bars,
  halfEnabled: DEFAULTS.halfEnabled,
  halfDensity: DEFAULTS.halfDensity,
  tempo: DEFAULTS.tempo,
  swing: DEFAULTS.swing,
  chaos: DEFAULTS.chaos,
  rootMode: DEFAULTS.rootMode,

  genrePreset: DEFAULTS.genrePreset,
  grooveStyle: DEFAULTS.grooveStyle,
  compStyle: DEFAULTS.compStyle,

  keysComplex: DEFAULTS.keysComplex,
  keysFill: DEFAULTS.keysFill,
  bassComplex: DEFAULTS.bassComplex,
  bassFill: DEFAULTS.bassFill,
  drumsComplex: DEFAULTS.drumsComplex,
  drumsFill: DEFAULTS.drumsFill,

  weights: macroToWeights(DEFAULTS.chaos),
  limiter: getChordLimiterState(),
  chartBars: [],

  keyRoot: 0,
  keyMode: "ionian",
  showKey: true,

  activeBar: 0,
  activeHalf: 0,

  pianoTheme: DEFAULTS.pianoTheme,
  markerStyle: DEFAULTS.markerStyle,
};

function syncMeta(halvesCount=0){
  els.metaBars.textContent = state.bars;
  els.metaTempo.textContent = state.tempo;
  els.metaSwing.textContent = state.swing;
  els.metaChaos.textContent = state.chaos;
  if (state.halfEnabled && halvesCount>0){
    els.metaHalves.style.display = "";
    els.metaHalvesVal.textContent = halvesCount;
  } else {
    els.metaHalves.style.display = "none";
    els.metaHalvesVal.textContent = "0";
  }
}

function setHeaderLine(){
  const modeLabel = (state.keyMode || "ionian").toUpperCase();
  const line = state.showKey ? `${noteName(state.keyRoot)} ¬∑ ${modeLabel}` : `FREE ¬∑ ${state.rootMode.toUpperCase()}`;
  const halfInfo = state.halfEnabled ? ` ¬∑ random ¬Ω-bars (${state.halfDensity}%)` : "";
  els.pillLine.textContent = `${line}${halfInfo} ¬∑ ${state.grooveStyle.toUpperCase()}`;
  els.leadKey.textContent  = `${line}${halfInfo}`;
}

/* Lead sheet */
function renderSheet(){
  els.sheet.innerHTML = "";

  for (let bar=0; bar<state.bars; bar++){
    const barObj = state.chartBars[bar];
    const chords = barObj?.chords || [];

    const div = document.createElement("div");
    const isActiveBar = (state.activeBar === bar);
    div.className = "bar" + (isActiveBar ? " active" : "");

    const num = `<div class="num">${bar+1}</div>`;
    if (chords.length<=1){
      const ch = chords[0];
      div.innerHTML = `<div class="sym">${ch ? chordName(ch) : "‚Äî"}</div>${num}`;
      div.addEventListener("click", async ()=>{ await focusBarHalf(bar, 0, "tap"); });
    } else {
      const chA = chords[0], chB = chords[1];
      div.innerHTML = `
        <div class="sym">${chA ? chordName(chA) : "‚Äî"}</div>
        <div class="sym sym2">${chB ? chordName(chB) : "‚Äî"}</div>
        ${num}
        <div class="halfHit" aria-hidden="true">
          <button type="button" data-half="0" title="First half"></button>
          <button type="button" data-half="1" title="Second half"></button>
        </div>
      `;
      div.querySelectorAll("button[data-half]").forEach(btn=>{
        btn.addEventListener("click", async (e)=>{
          e.stopPropagation();
          const half = Number(btn.getAttribute("data-half")||0);
          await focusBarHalf(bar, half, "tap");
        });
      });
      div.addEventListener("click", async ()=>{ await focusBarHalf(bar, 0, "tap"); });
    }

    els.sheet.appendChild(div);
  }
}

function getActiveChord(){
  const barObj = state.chartBars[state.activeBar];
  const chords = barObj?.chords || [];
  return chords[Math.min(state.activeHalf, chords.length-1)] || null;
}
function getChordByBarHalf(bar, half){
  const barObj = state.chartBars[bar];
  const chords = barObj?.chords || [];
  return chords[Math.min(half, chords.length-1)] || null;
}

async function focusBarHalf(barIndex, halfIndex){
  barIndex = clamp(barIndex, 0, state.bars-1);
  const barObj = state.chartBars[barIndex] || {chords:[]};
  const maxHalf = Math.max(0, (barObj.chords?.length||1)-1);
  halfIndex = clamp(halfIndex, 0, maxHalf);

  state.activeBar = barIndex;
  state.activeHalf = halfIndex;

  renderSheet();
  updatePianoForActive();

  const target = getActiveChord();
  if (!target) return;

  if (player.isPlaying && !player.isPaused){
    player.jumpTo(barIndex, halfIndex);
    els.msg.textContent = `Jumped to: ${chordName(target)}`;
  } else {
    if (player.isPlaying && player.isPaused) player.setResumePos(barIndex, halfIndex);
    await player.previewChord(target);
    els.msg.textContent = `Preview: ${chordName(target)}`;
  }
}

/* Piano SVG keyboard */
const KEYBOARD = (() => {
  const baseMidi = 48;
  const total = 24;
  const whiteMidi = [];
  for (let i=0;i<total;i++){
    const m = baseMidi + i;
    if (WHITE_PCS.has(pc(m))) whiteMidi.push(m);
  }

  function buildLayout(){
    const W=1000, H=240;
    const whiteCount = whiteMidi.length;
    const wW = W / whiteCount;

    const whiteKeys = whiteMidi.map((m,idx)=>({ midi:m, pc:pc(m), x:idx*wW, w:wW, h:H }));
    const blackKeys = [];
    const blackW = wW * 0.62;
    const blackH = H * 0.62;

    for (let i=0;i<total;i++){
      const m = baseMidi+i;
      if (WHITE_PCS.has(pc(m))) continue;
      let prev = m-1;
      while (prev>=baseMidi && !WHITE_PCS.has(pc(prev))) prev--;
      const whiteIdx = whiteMidi.indexOf(prev);
      if (whiteIdx < 0) continue;
      const x = (whiteIdx+1)*wW - blackW/2;
      blackKeys.push({midi:m, pc:pc(m), x, w:blackW, h:blackH});
    }

    const keyCenters = new Map();
    for (const k of whiteKeys) keyCenters.set(k.midi, {x:k.x+k.w/2, y:H*0.18});
    for (const k of blackKeys) keyCenters.set(k.midi, {x:k.x+k.w/2, y:blackH*0.22});

    function centersForPC(p){
      const centers=[];
      for (let i=0;i<total;i++){
        const m = baseMidi+i;
        if (pc(m)===p) centers.push(keyCenters.get(m));
      }
      return centers.filter(Boolean);
    }

    return {W,H,whiteKeys,blackKeys,centersForPC};
  }
  return buildLayout();
})();

let pianoKeyElsByPC = new Map();

function renderPianoBase(){
  const svg = els.pianoSvg;
  svg.innerHTML = "";
  svg.setAttribute("viewBox", `0 0 ${KEYBOARD.W} ${KEYBOARD.H}`);

  pianoKeyElsByPC = new Map();

  const css = getComputedStyle(document.documentElement);
  const whiteFill = css.getPropertyValue("--keyWhite").trim();
  const blackFill = css.getPropertyValue("--keyBlack").trim();
  const whiteStroke = css.getPropertyValue("--keyBorder").trim();
  const blackStroke = css.getPropertyValue("--keyBlackBorder").trim();

  function addKeyToMap(p, node){
    if (!pianoKeyElsByPC.has(p)) pianoKeyElsByPC.set(p, []);
    pianoKeyElsByPC.get(p).push(node);
  }

  for (const k of KEYBOARD.whiteKeys){
    const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
    r.setAttribute("x", k.x); r.setAttribute("y", 0);
    r.setAttribute("width", k.w); r.setAttribute("height", k.h);
    r.setAttribute("rx", 10); r.setAttribute("ry", 10);
    r.setAttribute("fill", whiteFill);
    r.setAttribute("stroke", whiteStroke);
    r.setAttribute("stroke-width", 1);
    r.setAttribute("data-kind","white");
    r.setAttribute("data-pc", k.pc);
    els.pianoSvg.appendChild(r);
    addKeyToMap(k.pc, r);
  }

  for (const k of KEYBOARD.blackKeys){
    const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
    r.setAttribute("x", k.x); r.setAttribute("y", 0);
    r.setAttribute("width", k.w); r.setAttribute("height", k.h);
    r.setAttribute("rx", 9); r.setAttribute("ry", 9);
    r.setAttribute("fill", blackFill);
    r.setAttribute("stroke", blackStroke);
    r.setAttribute("stroke-width", 1);
    r.setAttribute("data-kind","black");
    r.setAttribute("data-pc", k.pc);
    els.pianoSvg.appendChild(r);
    addKeyToMap(k.pc, r);
  }

  const g = document.createElementNS("http://www.w3.org/2000/svg","g");
  g.setAttribute("id","overlayLayer");
  els.pianoSvg.appendChild(g);
}

function resetKeyFills(){
  const css = getComputedStyle(document.documentElement);
  const whiteFill = css.getPropertyValue("--keyWhite").trim();
  const blackFill = css.getPropertyValue("--keyBlack").trim();
  const whiteStroke = css.getPropertyValue("--keyBorder").trim();
  const blackStroke = css.getPropertyValue("--keyBlackBorder").trim();

  for (const arr of pianoKeyElsByPC.values()){
    for (const el of arr){
      const kind = el.getAttribute("data-kind");
      el.setAttribute("fill", kind==="black" ? blackFill : whiteFill);
      el.setAttribute("stroke", kind==="black" ? blackStroke : whiteStroke);
      el.setAttribute("stroke-width", "1");
    }
  }
}

function fillScaleKeys(scalePCs){
  const css = getComputedStyle(document.documentElement);
  const blue = css.getPropertyValue("--accent").trim();
  const strokeW = Number(css.getPropertyValue("--scaleStrokeWidth").trim()) || 2.2;
  const alpha = Number(css.getPropertyValue("--scaleStrokeAlpha").trim()) || 0.88;

  for (const p of scalePCs){
    const arr = pianoKeyElsByPC.get(p) || [];
    for (const el of arr){
      el.setAttribute("fill", blue);
      el.setAttribute("stroke", `rgba(0,0,0,${clamp(alpha,0,1)})`);
      el.setAttribute("stroke-width", String(strokeW));
    }
  }
}

function clearPianoOverlays(){
  const g = els.pianoSvg.querySelector("#overlayLayer");
  if (g) g.innerHTML = "";
}

/* marker shapes */
function markerNode(x,y,color, kind){
  const style = state.markerStyle || "dots";
  const stroke = "rgba(0,0,0,0.35)";

  if (style === "rings"){
    const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
    c.setAttribute("cx", x);
    c.setAttribute("cy", y);
    c.setAttribute("r", kind==="root" ? 10 : 9);
    c.setAttribute("fill", "transparent");
    c.setAttribute("stroke", color);
    c.setAttribute("stroke-width", kind==="root" ? 5 : 4);
    c.setAttribute("opacity", "0.95");
    return c;
  }

  if (style === "triangles"){
    const s = kind==="root" ? 12 : 11;
    const pts = `${x},${y-s} ${x-s},${y+s} ${x+s},${y+s}`;
    const p = document.createElementNS("http://www.w3.org/2000/svg","polygon");
    p.setAttribute("points", pts);
    p.setAttribute("fill", color);
    p.setAttribute("stroke", stroke);
    p.setAttribute("stroke-width", "3");
    return p;
  }

  if (style === "squares"){
    const s = kind==="root" ? 20 : 18;
    const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
    r.setAttribute("x", x - s/2);
    r.setAttribute("y", y - s/2);
    r.setAttribute("width", s);
    r.setAttribute("height", s);
    r.setAttribute("rx", kind==="root" ? 6 : 5);
    r.setAttribute("ry", kind==="root" ? 6 : 5);
    r.setAttribute("fill", color);
    r.setAttribute("stroke", stroke);
    r.setAttribute("stroke-width", "3");
    return r;
  }

  const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
  c.setAttribute("cx", x);
  c.setAttribute("cy", y);
  c.setAttribute("r", kind==="root" ? 10 : 9);
  c.setAttribute("fill", color);
  c.setAttribute("stroke", stroke);
  c.setAttribute("stroke-width", "3");
  return c;
}

function modeLabel(mode){
  if (mode==="mixo") return "Mixolydian";
  if (mode==="ionian") return "Ionian";
  if (mode==="dorian") return "Dorian";
  if (mode==="locrian") return "Locrian";
  if (mode==="lydian") return "Lydian";
  if (mode==="aeolian") return "Aeolian";
  if (mode==="phryg") return "Phrygian";
  if (mode==="melodicMinor") return "Melodic Minor";
  if (mode==="lydianDom") return "Lydian Dominant";
  if (mode==="altered") return "Altered";
  return String(mode||"");
}

function updatePianoForActive(){
  const ch = getActiveChord();
  if (!ch) return;

  const prev = getChordByBarHalf(state.activeBar, Math.max(0,state.activeHalf-1)) || (state.activeBar>0 ? getChordByBarHalf(state.activeBar-1, 1) : null);
  const next = getChordByBarHalf(state.activeBar, state.activeHalf+1) || (state.activeBar<state.bars-1 ? getChordByBarHalf(state.activeBar+1, 0) : null);

  const { pcs:scalePCs, mode } = scalePCsForChordLocal(ch, prev, next);

  resetKeyFills();
  fillScaleKeys(scalePCs);
  clearPianoOverlays();

  const chordPCs = chordTonesPCs(ch);
  const rootPC = pc(ch.root);

  const g = els.pianoSvg.querySelector("#overlayLayer");
  const css = getComputedStyle(document.documentElement);
  const green = css.getPropertyValue("--good").trim();
  const purple = css.getPropertyValue("--chord").trim();

  KEYBOARD.centersForPC(rootPC).forEach(c=> g.appendChild(markerNode(c.x, c.y, green, "root")));
  chordPCs.filter(p=>p!==rootPC).forEach(p=>{
    KEYBOARD.centersForPC(p).forEach(c=> g.appendChild(markerNode(c.x, c.y, purple, "tone")));
  });

  const chordScaleName = `${noteName(ch.root)} ${modeLabel(mode)}`;
  els.pianoTop.textContent = chordScaleName;

  const halfLetter = (state.chartBars[state.activeBar]?.chords?.length===2) ? (state.activeHalf===0 ? "A" : "B") : "";
  els.pianoHint.textContent = `${chordName(ch)} ¬∑ scale: ${chordScaleName} ¬∑ bar ${state.activeBar+1}${halfLetter ? halfLetter : ""}`;
}

/* Copy chart */
function copyChart(){
  let out = "";
  for (let bar=0; bar<state.bars; bar++){
    if (bar%4===0) out += (bar===0 ? "" : "\n");
    const barObj = state.chartBars[bar] || {chords:[]};
    const chords = barObj.chords || [];

    let txt = "‚Äî";
    if (chords.length<=1){
      txt = chords[0] ? chordName(chords[0]) : "‚Äî";
      out += `| ${txt.padEnd(10," ")} `;
    } else {
      const a = chords[0] ? chordName(chords[0]) : "‚Äî";
      const b = chords[1] ? chordName(chords[1]) : "‚Äî";
      txt = `${a} , ${b}`;
      out += `| ${txt.padEnd(18," ")} `;
    }

    if (bar%4===3) out += "|";
  }

  if (navigator.clipboard?.writeText){
    navigator.clipboard.writeText(out)
      .then(()=>{ els.msg.textContent = "Copied chart to clipboard."; })
      .catch(()=>{ els.msg.textContent = "Copy failed (clipboard permission)."; });
  } else {
    els.msg.textContent = "Clipboard not available.";
  }
}

function linkRangeAndNumber(rangeEl, numEl, onChange){
  rangeEl.addEventListener("input", ()=>{
    numEl.value = rangeEl.value;
    onChange(Number(rangeEl.value));
  });
  numEl.addEventListener("change", ()=>{
    const v = clamp(Number(numEl.value), Number(rangeEl.min||-1e9), Number(rangeEl.max||1e9));
    numEl.value = v;
    rangeEl.value = v;
    onChange(v);
  });
}

/* wiring */
linkRangeAndNumber(els.bars, els.barsNum, (v)=>{ state.bars = v|0; generateAndRender(); });
linkRangeAndNumber(els.halfDensity, els.halfDensityNum, (v)=>{ state.halfDensity = v|0; if (state.halfEnabled) generateAndRender(); });

linkRangeAndNumber(els.tempo, els.tempoNum, (v)=>{
  state.tempo = v|0;
  syncMeta(player.lastHalvesCount||0);
  if (player.isPlaying) player.setTempo(state.tempo, state.swing);
});
linkRangeAndNumber(els.swing, els.swingNum, (v)=>{
  state.swing = v|0;
  syncMeta(player.lastHalvesCount||0);
  if (player.isPlaying) player.setTempo(state.tempo, state.swing);
});
linkRangeAndNumber(els.chaos, els.chaosNum, (v)=>{
  state.chaos = v|0;
  state.weights = macroToWeights(state.chaos);
  syncMeta(player.lastHalvesCount||0);
});

linkRangeAndNumber(els.keysComplex, els.keysComplexNum, (v)=>{ state.keysComplex = v|0; if (player.isPlaying) player.setFeel(state); });
linkRangeAndNumber(els.keysFill, els.keysFillNum, (v)=>{ state.keysFill = v|0; if (player.isPlaying) player.setFeel(state); });
linkRangeAndNumber(els.bassComplex, els.bassComplexNum, (v)=>{ state.bassComplex = v|0; if (player.isPlaying) player.setFeel(state); });
linkRangeAndNumber(els.bassFill, els.bassFillNum, (v)=>{ state.bassFill = v|0; if (player.isPlaying) player.setFeel(state); });
linkRangeAndNumber(els.drumsComplex, els.drumsComplexNum, (v)=>{ state.drumsComplex = v|0; if (player.isPlaying) player.setFeel(state); });
linkRangeAndNumber(els.drumsFill, els.drumsFillNum, (v)=>{ state.drumsFill = v|0; if (player.isPlaying) player.setFeel(state); });

linkRangeAndNumber(els.drumsLevel, els.drumsLevelNum, (v)=>{ player.setDrumsLevel((v|0)/100); });

els.halfChords.addEventListener("change", ()=>{ state.halfEnabled = !!els.halfChords.checked; generateAndRender(); });

els.compStyle.addEventListener("change", ()=>{
  state.compStyle = els.compStyle.value;
  if (player.isPlaying) player.setCompStyle(state.compStyle);
});

els.grooveStyle.addEventListener("change", ()=>{
  state.grooveStyle = els.grooveStyle.value;
  if (player.isPlaying) player.setGroove(state.grooveStyle);
});

els.rootMode.addEventListener("change", ()=>{ state.rootMode = els.rootMode.value; });

els.bassPreset.addEventListener("change", ()=> player.setPresets(els.bassPreset.value, els.keysPreset.value, els.drumsPreset.value));
els.keysPreset.addEventListener("change", ()=> player.setPresets(els.bassPreset.value, els.keysPreset.value, els.drumsPreset.value))
els.drumsPreset.addEventListener("change", ()=> player.setPresets(els.bassPreset.value, els.keysPreset.value, els.drumsPreset.value));

els.btnCopy.addEventListener("click", copyChart);

function renderAll(halvesCount=0){
  syncMeta(halvesCount);
  setHeaderLine();
  renderSheet();
  updatePianoForActive();
}

function generateAndRender(){
  state.limiter = getChordLimiterState();

  const res = genChartBars({
    bars: state.bars,
    chaos: state.chaos,
    rootMode: state.rootMode,
    weights: state.weights,
    limiter: state.limiter,
    halfEnabled: state.halfEnabled,
    halfDensity: state.halfDensity
  });

  state.chartBars = res.bars;
  state.keyRoot = res.keyRoot;
  state.keyMode = res.keyMode;
  state.showKey = res.showKey;

  state.activeBar = 0;
  state.activeHalf = 0;

  renderAll(res.halvesCount);
  player.lastHalvesCount = res.halvesCount;
  els.msg.textContent = "Generated new chart.";

  if (player.isPlaying){
    player.setChart(state.chartBars);
    player.jumpTo(0, 0);
  }
}

els.btnGenerate.addEventListener("click", generateAndRender);

[
  "qMaj7","qMin7","qDom7","qDim7","qHalfDim","qSus","qMinMaj",
  "x9","x11","x13","x6","xAdd9","xSharp11","xMin11",
  "tAlt","tSlash","tChrom","tB9","tSharp9"
].forEach(id=>{
  document.getElementById(id).addEventListener("change", ()=> generateAndRender());
});

/* ========= Genre presets ========= */
const GENRE_PRESETS = {
  jazzSwing: {
    tempo:[110,150], swing:[58,66], groove:"swing", comp:"twoStabs",
    bass:"upright", keys:"ep", drums:"jazz",
    keysC:55, keysF:35, bassC:55, bassF:30, drumsC:60, drumsF:40,
    halfOn:false, halfDen:40
  },
  bebop: {
    tempo:[170,220], swing:[60,68], groove:"swing", comp:"fourComp",
    bass:"upright", keys:"piano", drums:"tight",
    keysC:75, keysF:45, bassC:80, bassF:35, drumsC:75, drumsF:55,
    halfOn:true, halfDen:35
  },
  balladJazz: {
    tempo:[70,92], swing:[52,58], groove:"brushBallad", comp:"sustain",
    bass:"round", keys:"pad", drums:"brushes",
    keysC:35, keysF:25, bassC:40, bassF:20, drumsC:35, drumsF:30,
    halfOn:false, halfDen:25
  },
  modalJazz: {
    tempo:[95,135], swing:[50,56], groove:"ambient", comp:"sparse",
    bass:"sub", keys:"choirPad", drums:"lofi",
    keysC:45, keysF:35, bassC:45, bassF:25, drumsC:45, drumsF:35,
    halfOn:true, halfDen:30
  },
  bossa: {
    tempo:[120,160], swing:[50,54], groove:"bossa", comp:"montuno",
    bass:"round", keys:"vibes", drums:"perc",
    keysC:60, keysF:40, bassC:55, bassF:35, drumsC:60, drumsF:40,
    halfOn:true, halfDen:40
  },
  afroCuban: {
    tempo:[120,180], swing:[50,54], groove:"afroCuban", comp:"montuno",
    bass:"round", keys:"organ", drums:"perc",
    keysC:70, keysF:45, bassC:65, bassF:35, drumsC:75, drumsF:55,
    halfOn:true, halfDen:45
  },
  funk: {
    tempo:[95,125], swing:[50,55], groove:"funk", comp:"clav",
    bass:"rubber", keys:"clav?__unused", drums:"tight",
    keysC:75, keysF:55, bassC:75, bassF:45, drumsC:75, drumsF:55,
    halfOn:true, halfDen:30
  },
  hiphop: {
    tempo:[78,98], swing:[54,62], groove:"hiphop", comp:"sparse",
    bass:"sub", keys:"noisePad", drums:"lofi",
    keysC:35, keysF:35, bassC:55, bassF:35, drumsC:60, drumsF:55,
    halfOn:true, halfDen:25
  },
  house: {
    tempo:[120,132], swing:[50,54], groove:"house", comp:"houseChop",
    bass:"squareBass", keys:"organ", drums:"house",
    keysC:65, keysF:45, bassC:60, bassF:35, drumsC:70, drumsF:50,
    halfOn:true, halfDen:30
  },
  dnb: {
    tempo:[165,178], swing:[50,54], groove:"dnb", comp:"arpeggio",
    bass:"reese", keys:"fm", drums:"dnb",
    keysC:70, keysF:55, bassC:80, bassF:45, drumsC:80, drumsF:65,
    halfOn:true, halfDen:35
  },
  ambient: {
    tempo:[60,90], swing:[50,52], groove:"ambient", comp:"sustain",
    bass:"sub", keys:"pad", drums:"minimal",
    keysC:25, keysF:20, bassC:25, bassF:15, drumsC:20, drumsF:15,
    halfOn:false, halfDen:10
  },
  free: {
    tempo:[90,170], swing:[50,65], groove:"free", comp:"pushPull",
    bass:"fmBass", keys:"glass", drums:"electro",
    keysC:85, keysF:70, bassC:85, bassF:60, drumsC:85, drumsF:70,
    halfOn:true, halfDen:55
  },
};

function applyGenrePreset(id){
  const p = GENRE_PRESETS[id] || GENRE_PRESETS.jazzSwing;

  state.genrePreset = id;

  state.tempo = rint(p.tempo[0], p.tempo[1]);
  state.swing = rint(p.swing[0], p.swing[1]);

  state.grooveStyle = p.groove;
  state.compStyle = p.comp;

  state.halfEnabled = !!p.halfOn;
  state.halfDensity = p.halfDen|0;

  state.keysComplex = p.keysC|0;
  state.keysFill = p.keysF|0;
  state.bassComplex = p.bassC|0;
  state.bassFill = p.bassF|0;
  state.drumsComplex = p.drumsC|0;
  state.drumsFill = p.drumsF|0;

  els.tempo.value = state.tempo; els.tempoNum.value = state.tempo;
  els.swing.value = state.swing; els.swingNum.value = state.swing;
  els.grooveStyle.value = state.grooveStyle;
  els.compStyle.value = state.compStyle;

  els.halfChords.checked = state.halfEnabled;
  els.halfDensity.value = state.halfDensity; els.halfDensityNum.value = state.halfDensity;

  els.keysComplex.value = state.keysComplex; els.keysComplexNum.value = state.keysComplex;
  els.keysFill.value = state.keysFill; els.keysFillNum.value = state.keysFill;
  els.bassComplex.value = state.bassComplex; els.bassComplexNum.value = state.bassComplex;
  els.bassFill.value = state.bassFill; els.bassFillNum.value = state.bassFill;
  els.drumsComplex.value = state.drumsComplex; els.drumsComplexNum.value = state.drumsComplex;
  els.drumsFill.value = state.drumsFill; els.drumsFillNum.value = state.drumsFill;

  // pick safe sound defaults for each preset
  els.bassPreset.value = p.bass || "upright";
  els.keysPreset.value = p.keys === "clav?__unused" ? "chip" : (p.keys || "ep");
  els.drumsPreset.value = p.drums || "jazz";

  state.weights = macroToWeights(state.chaos);

  player.setTempo(state.tempo, state.swing);
  player.setGroove(state.grooveStyle);
  player.setCompStyle(state.compStyle);
  player.setPresets(els.bassPreset.value, els.keysPreset.value, els.drumsPreset.value);
  player.setFeel(state);

  generateAndRender();
  els.msg.textContent = `Preset: ${id}`;
}

els.genrePreset.addEventListener("change", ()=> applyGenrePreset(els.genrePreset.value));

/* ========= Randomize everything ========= */
function randomizeAllSettings(){
  state.bars = rint(2, 16);
  els.bars.value = state.bars;
  els.barsNum.value = state.bars;

  state.halfEnabled = chance(0.55);
  els.halfChords.checked = state.halfEnabled;

  state.halfDensity = rint(10, 70);
  els.halfDensity.value = state.halfDensity;
  els.halfDensityNum.value = state.halfDensity;

  // random genre influences groove + style but keep user control
  const g = pick(Object.keys(GENRE_PRESETS));
  els.genrePreset.value = g;
  applyGenrePreset(g); // will call generate

  // then sprinkle extra randomness
  state.chaos = rint(0, 100);
  els.chaos.value = state.chaos; els.chaosNum.value = state.chaos;
  state.weights = macroToWeights(state.chaos);

  state.rootMode = pick(["keyed","drifting","orbiting","freefall"]);
  els.rootMode.value = state.rootMode;

  // random sounds
  els.bassPreset.value = pick([...els.bassPreset.options].map(o=>o.value));
  els.keysPreset.value = pick([...els.keysPreset.options].map(o=>o.value));
  els.drumsPreset.value = pick([...els.drumsPreset.options].map(o=>o.value));

  const dl = rint(20, 85);
  els.drumsLevel.value = dl; els.drumsLevelNum.value = dl;

  // random feel
  state.keysComplex = rint(0, 95); state.keysFill = rint(0, 85);
  state.bassComplex = rint(0, 95); state.bassFill = rint(0, 85);
  state.drumsComplex = rint(0, 95); state.drumsFill = rint(0, 95);

  els.keysComplex.value = state.keysComplex; els.keysComplexNum.value = state.keysComplex;
  els.keysFill.value = state.keysFill; els.keysFillNum.value = state.keysFill;
  els.bassComplex.value = state.bassComplex; els.bassComplexNum.value = state.bassComplex;
  els.bassFill.value = state.bassFill; els.bassFillNum.value = state.bassFill;
  els.drumsComplex.value = state.drumsComplex; els.drumsComplexNum.value = state.drumsComplex;
  els.drumsFill.value = state.drumsFill; els.drumsFillNum.value = state.drumsFill;

  // limiter random
  const lim = {
    qMaj7: chance(0.85),
    qMin7: chance(0.85),
    qDom7: chance(0.85),
    qDim7: chance(0.55),
    qHalfDim: chance(0.45),
    qSus: chance(0.40),
    qMinMaj: chance(0.25),

    x9: chance(0.60),
    x11: chance(0.35),
    x13: chance(0.35),
    x6: chance(0.35),
    xAdd9: chance(0.30),
    xSharp11: chance(0.25),
    xMin11: chance(0.25),

    tAlt: chance(0.35),
    tSlash: chance(0.30),
    tChrom: chance(0.30),
    tB9: chance(0.25),
    tSharp9: chance(0.25),
  };
  if (!lim.qMaj7 && !lim.qMin7 && !lim.qDom7 && !lim.qDim7 && !lim.qHalfDim && !lim.qSus && !lim.qMinMaj){
    lim.qDom7 = true;
  }
  setChordLimiterState(lim);

  player.setPresets(els.bassPreset.value, els.keysPreset.value, els.drumsPreset.value);
  player.setDrumsLevel((Number(els.drumsLevel.value)||55)/100);
  player.setCompStyle(state.compStyle);
  player.setGroove(state.grooveStyle);
  player.setTempo(state.tempo, state.swing);
  player.setFeel(state);

  generateAndRender();
  els.msg.textContent = "Randomized everything.";
}
els.btnRandom.addEventListener("click", randomizeAllSettings);

/* ========= Defaults ========= */
function applyDefaults(){
  state.bars = DEFAULTS.bars;
  els.bars.value = state.bars; els.barsNum.value = state.bars;

  state.halfEnabled = DEFAULTS.halfEnabled;
  els.halfChords.checked = state.halfEnabled;

  state.halfDensity = DEFAULTS.halfDensity;
  els.halfDensity.value = state.halfDensity; els.halfDensityNum.value = state.halfDensity;

  state.tempo = DEFAULTS.tempo; els.tempo.value = state.tempo; els.tempoNum.value = state.tempo;
  state.swing = DEFAULTS.swing; els.swing.value = state.swing; els.swingNum.value = state.swing;
  state.chaos = DEFAULTS.chaos; els.chaos.value = state.chaos; els.chaosNum.value = state.chaos;

  state.rootMode = DEFAULTS.rootMode; els.rootMode.value = state.rootMode;

  state.genrePreset = DEFAULTS.genrePreset;
  els.genrePreset.value = state.genrePreset;

  state.grooveStyle = DEFAULTS.grooveStyle;
  els.grooveStyle.value = state.grooveStyle;

  state.compStyle = DEFAULTS.compStyle;
  els.compStyle.value = state.compStyle;

  els.bassPreset.value = DEFAULTS.bassPreset;
  els.keysPreset.value = DEFAULTS.keysPreset;
  els.drumsPreset.value = DEFAULTS.drumsPreset;

  els.drumsLevel.value = DEFAULTS.drumsLevel;
  els.drumsLevelNum.value = DEFAULTS.drumsLevel;

  state.keysComplex = DEFAULTS.keysComplex; els.keysComplex.value = state.keysComplex; els.keysComplexNum.value = state.keysComplex;
  state.keysFill = DEFAULTS.keysFill; els.keysFill.value = state.keysFill; els.keysFillNum.value = state.keysFill;

  state.bassComplex = DEFAULTS.bassComplex; els.bassComplex.value = state.bassComplex; els.bassComplexNum.value = state.bassComplex;
  state.bassFill = DEFAULTS.bassFill; els.bassFill.value = state.bassFill; els.bassFillNum.value = state.bassFill;

  state.drumsComplex = DEFAULTS.drumsComplex; els.drumsComplex.value = state.drumsComplex; els.drumsComplexNum.value = state.drumsComplex;
  state.drumsFill = DEFAULTS.drumsFill; els.drumsFill.value = state.drumsFill; els.drumsFillNum.value = state.drumsFill;

  setChordLimiterState(DEFAULTS.limiter);
  state.weights = macroToWeights(state.chaos);

  els.pianoTheme.value = DEFAULTS.pianoTheme;
  els.markerStyle.value = DEFAULTS.markerStyle;
  applyMarkerStyle(DEFAULTS.markerStyle);
  applyPianoTheme(DEFAULTS.pianoTheme);

  els.scaleOutlineW.value = DEFAULTS.scaleStrokeWidth;
  els.scaleOutlineWNum.value = DEFAULTS.scaleStrokeWidth;
  els.scaleOutlineA.value = DEFAULTS.scaleStrokeAlphaPct;
  els.scaleOutlineANum.value = DEFAULTS.scaleStrokeAlphaPct;
  applyScaleOutlineSettings(DEFAULTS.scaleStrokeWidth, DEFAULTS.scaleStrokeAlphaPct);

  player.setPresets(els.bassPreset.value, els.keysPreset.value, els.drumsPreset.value);
  player.setDrumsLevel((DEFAULTS.drumsLevel)/100);
  player.setCompStyle(state.compStyle);
  player.setGroove(state.grooveStyle);
  player.setFeel(state);
  player.setTempo(state.tempo, state.swing);

  generateAndRender();
  els.msg.textContent = "Restored defaults.";
}
els.btnDefaults.addEventListener("click", applyDefaults);
els.btnDefaults2.addEventListener("click", applyDefaults);

/* ========= Advanced settings: reorder MAIN SECTIONS ========= */
const DEFAULT_SECTION_ORDER = ["cardLead","cardPiano","cardControls","cardLimiters"];
const SECTION_LABELS = {
  cardLead: "Lead sheet",
  cardPiano: "Piano display",
  cardControls: "Controls",
  cardLimiters: "Chord limiters",
};

function getSectionOrder(){
  try{
    const raw = localStorage.getItem("fm_section_order");
    if (!raw) return DEFAULT_SECTION_ORDER.slice();
    const arr = JSON.parse(raw);
    const set = new Set(DEFAULT_SECTION_ORDER);
    const cleaned = arr.filter(x=>set.has(x));
    for (const x of DEFAULT_SECTION_ORDER) if (!cleaned.includes(x)) cleaned.push(x);
    return cleaned;
  }catch{
    return DEFAULT_SECTION_ORDER.slice();
  }
}
function setSectionOrder(order){
  localStorage.setItem("fm_section_order", JSON.stringify(order));
}
function applySectionOrder(order){
  const app = document.querySelector(".app");
  const header = app.querySelector(".header");
  const sections = new Map();

  for (const id of DEFAULT_SECTION_ORDER){
    const el = document.getElementById(id);
    if (el) sections.set(id, el);
  }

  for (const id of order){
    const el = sections.get(id);
    if (el) app.appendChild(el);
  }

  if (header) app.insertBefore(header, app.firstChild);
}
function renderOrderModal(){
  const order = getSectionOrder();
  els.orderList.innerHTML = "";
  order.forEach((id, idx)=>{
    const row = document.createElement("div");
    row.className = "modalRow";
    row.innerHTML = `
      <div class="name">${idx+1}. ${SECTION_LABELS[id] || id}</div>
      <div class="reorderBtns">
        <button class="btn small" data-act="up" data-key="${id}">‚Üë</button>
        <button class="btn small" data-act="down" data-key="${id}">‚Üì</button>
      </div>
    `;
    els.orderList.appendChild(row);
  });

  els.orderList.querySelectorAll("button[data-act]").forEach(btn=>{
    btn.addEventListener("click", ()=>{
      const act = btn.getAttribute("data-act");
      const key = btn.getAttribute("data-key");
      const cur = getSectionOrder();
      const i = cur.indexOf(key);
      if (i < 0) return;

      if (act==="up" && i>0){
        [cur[i-1], cur[i]] = [cur[i], cur[i-1]];
      } else if (act==="down" && i<cur.length-1){
        [cur[i+1], cur[i]] = [cur[i], cur[i+1]];
      }

      setSectionOrder(cur);
      renderOrderModal();
      applySectionOrder(cur);
    });
  });
}
function openAdv(){ renderOrderModal(); els.advBack.style.display = "flex"; }
function closeAdv(){ els.advBack.style.display = "none"; }
els.btnGear.addEventListener("click", openAdv);
els.btnCloseAdv.addEventListener("click", closeAdv);
els.advBack.addEventListener("click", (e)=>{ if (e.target === els.advBack) closeAdv(); });
els.btnResetMenu.addEventListener("click", ()=>{
  setSectionOrder(DEFAULT_SECTION_ORDER.slice());
  renderOrderModal();
  applySectionOrder(getSectionOrder());
});

/* ========= Piano theme + marker style ========= */
const THEME_PRESETS = {
  classic: {
    "--accent":"#2f6bff","--good":"#3fe18b","--chord":"#b67cff",
    "--keyWhite":"#f2f5fb","--keyBlack":"#161b23","--keyBorder":"#c9d3e2","--keyBlackBorder":"#2a3240",
  },
    neon: {
    "--accent":"#00b7ff","--good":"#00ff9a","--chord":"#ff4dff",
    "--keyWhite":"#e9f7ff","--keyBlack":"#0b0f14","--keyBorder":"rgba(233,247,255,.45)","--keyBlackBorder":"rgba(255,255,255,.16)",
  },
  mono: {
    "--accent":"#d7dde6","--good":"#ffffff","--chord":"#9aa6b2",
    "--keyWhite":"#f4f6fa","--keyBlack":"#10151d","--keyBorder":"rgba(0,0,0,.18)","--keyBlackBorder":"rgba(255,255,255,.12)",
  },
  pastel: {
    "--accent":"#8bb6ff","--good":"#88f0c3","--chord":"#d7a6ff",
    "--keyWhite":"#fbfbff","--keyBlack":"#141a22","--keyBorder":"rgba(20,26,34,.18)","--keyBlackBorder":"rgba(255,255,255,.10)",
  }
};

function applyPianoTheme(themeId){
  const t = THEME_PRESETS[themeId] || THEME_PRESETS.classic;
  for (const k of Object.keys(t)){
    document.documentElement.style.setProperty(k, t[k]);
  }
  state.pianoTheme = themeId;
  try{ localStorage.setItem("fm_piano_theme", themeId); }catch{}
  renderPianoBase();
  updatePianoForActive();
}

function applyMarkerStyle(styleId){
  state.markerStyle = styleId || "dots";
  try{ localStorage.setItem("fm_marker_style", state.markerStyle); }catch{}
  updatePianoForActive();
}

function applyScaleOutlineSettings(widthPx, alphaPct){
  const w = clamp(Number(widthPx)||2.2, 0.0, 6.0);
  const a = clamp((Number(alphaPct)||0)/100, 0, 1);
  document.documentElement.style.setProperty("--scaleStrokeWidth", String(w));
  document.documentElement.style.setProperty("--scaleStrokeAlpha", String(a));
  try{
    localStorage.setItem("fm_scale_outline_w", String(w));
    localStorage.setItem("fm_scale_outline_a", String(alphaPct));
  }catch{}
  updatePianoForActive();
}

/* theme + marker UI wiring */
els.pianoTheme.addEventListener("change", ()=> applyPianoTheme(els.pianoTheme.value));
els.markerStyle.addEventListener("change", ()=> applyMarkerStyle(els.markerStyle.value));

linkRangeAndNumber(els.scaleOutlineW, els.scaleOutlineWNum, (v)=> applyScaleOutlineSettings(v, Number(els.scaleOutlineA.value)));
linkRangeAndNumber(els.scaleOutlineA, els.scaleOutlineANum, (v)=> applyScaleOutlineSettings(Number(els.scaleOutlineW.value), v));

/* ========= LocalStorage load ========= */
function loadSaved(){
  try{
    const t = localStorage.getItem("fm_piano_theme");
    if (t && THEME_PRESETS[t]) { els.pianoTheme.value = t; state.pianoTheme=t; }
    const ms = localStorage.getItem("fm_marker_style");
    if (ms) { els.markerStyle.value = ms; state.markerStyle = ms; }

    const w = localStorage.getItem("fm_scale_outline_w");
    const a = localStorage.getItem("fm_scale_outline_a");
    if (w){
      els.scaleOutlineW.value = w;
      els.scaleOutlineWNum.value = w;
    }
    if (a){
      els.scaleOutlineA.value = a;
      els.scaleOutlineANum.value = a;
    }
  }catch{}
}

/* ========= AUDIO ENGINE (minimal synth band) ========= */
function midiToFreq(m){ return 440 * Math.pow(2, (m-69)/12); }

class MiniSynth {
  constructor(ctx){
    this.ctx = ctx;
    this.out = ctx.createGain();
    this.out.gain.value = 0.9;
    this.out.connect(ctx.destination);

    this.master = ctx.createGain();
    this.master.gain.value = 0.85;
    this.master.connect(this.out);

    this.drumsBus = ctx.createGain();
    this.drumsBus.gain.value = 0.55;
    this.drumsBus.connect(this.master);

    this.keysBus = ctx.createGain();
    this.keysBus.gain.value = 0.55;
    this.keysBus.connect(this.master);

    this.bassBus = ctx.createGain();
    this.bassBus.gain.value = 0.55;
    this.bassBus.connect(this.master);

    this.presets = { bass:"upright", keys:"ep", drums:"jazz" };
  }

  setPresets(bass, keys, drums){
    this.presets = { bass, keys, drums };
  }

  setDrumsLevel(v01){
    this.drumsBus.gain.value = clamp(v01,0,1);
  }

  _env(g, t, a, d, s, r, peak=1){
    const now = t;
    g.gain.cancelScheduledValues(now);
    g.gain.setValueAtTime(0.0001, now);
    g.gain.linearRampToValueAtTime(peak, now + a);
    g.gain.exponentialRampToValueAtTime(Math.max(0.0001, peak*s), now + a + d);
    g.gain.exponentialRampToValueAtTime(0.0001, now + a + d + r);
  }

  /* ---------- KEYS ---------- */
  playKeysChord(midiNotes, t, len=0.18, vel=0.7){
    const ctx = this.ctx;
    const p = this.presets.keys;

    const wave = ({
      ep:"sine",
      piano:"triangle",
      organ:"square",
      pad:"sine",
      fm:"sine",
      chip:"square",
      bell:"sine",
      glass:"sine",
      pluck2:"triangle",
      vibes:"sine",
      choirPad:"sine",
      noisePad:"sine",
    })[p] || "sine";

    const baseCut = ({
      ep: 1600,
      piano: 2400,
      organ: 1200,
      pad: 900,
      fm: 1500,
      chip: 2500,
      bell: 2600,
      glass: 3000,
      pluck2: 2000,
      vibes: 2200,
      choirPad: 900,
      noisePad: 1100,
    })[p] || 1600;

    for (const m of midiNotes){
      const o = ctx.createOscillator();
      o.type = wave;

      const g = ctx.createGain();
      const f = ctx.createBiquadFilter();
      f.type = "lowpass";
      f.frequency.setValueAtTime(baseCut, t);
      f.Q.setValueAtTime(0.7, t);

      o.frequency.setValueAtTime(midiToFreq(m), t);

      const atk = (p==="pad" || p==="choirPad" || p==="noisePad") ? 0.02 : 0.004;
      const rel = (p==="pad" || p==="choirPad" || p==="noisePad") ? Math.max(0.18, len*0.9) : Math.max(0.08, len*0.6);
      this._env(g, t, atk, 0.06, 0.35, rel, vel*0.55);

      o.connect(f);
      f.connect(g);
      g.connect(this.keysBus);

      o.start(t);
      o.stop(t + len + rel + 0.05);

      if (p==="noisePad"){
        // subtle noise layer
        const n = ctx.createBufferSource();
        const buf = ctx.createBuffer(1, Math.floor(ctx.sampleRate*(len+0.25)), ctx.sampleRate);
        const data = buf.getChannelData(0);
        for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * 0.15;
        n.buffer = buf;
        const ng = ctx.createGain();
        this._env(ng, t, 0.01, 0.08, 0.18, 0.22, vel*0.18);
        const nf = ctx.createBiquadFilter();
        nf.type = "bandpass";
        nf.frequency.setValueAtTime(900, t);
        nf.Q.setValueAtTime(0.8, t);
        n.connect(nf); nf.connect(ng); ng.connect(this.keysBus);
        n.start(t);
        n.stop(t + len + 0.3);
      }
    }
  }

  /* ---------- BASS ---------- */
  playBassNote(midi, t, len=0.16, vel=0.7){
    const ctx = this.ctx;
    const p = this.presets.bass;

    const wave = ({
      upright:"sine",
      round:"triangle",
      sub:"sine",
      pluck:"triangle",
      fmBass:"sine",
      rubber:"square",
      acid:"sawtooth",
      reese:"sawtooth",
      squareBass:"square",
      wobble:"square",
    })[p] || "sine";

    const o = ctx.createOscillator();
    o.type = wave;

    const g = ctx.createGain();
    const f = ctx.createBiquadFilter();
    f.type = "lowpass";

    const cut = ({
      upright: 700,
      round: 900,
      sub: 380,
      pluck: 1100,
      fmBass: 900,
      rubber: 1200,
      acid: 1800,
      reese: 1400,
      squareBass: 1200,
      wobble: 1000,
    })[p] || 800;

    f.frequency.setValueAtTime(cut, t);
    f.Q.setValueAtTime(p==="acid" ? 1.2 : 0.8, t);

    o.frequency.setValueAtTime(midiToFreq(midi), t);

    const atk = 0.004;
    const rel = Math.max(0.07, len*0.6);
    const peak = vel * (p==="sub" ? 0.75 : 0.65);

    this._env(g, t, atk, 0.06, 0.28, rel, peak);

    o.connect(f);
    f.connect(g);
    g.connect(this.bassBus);

    // wobble LFO
    if (p==="wobble"){
      const lfo = ctx.createOscillator();
      const lg = ctx.createGain();
      lfo.type = "sine";
      lfo.frequency.setValueAtTime(3.5, t);
      lg.gain.setValueAtTime(320, t);
      lfo.connect(lg);
      lg.connect(f.frequency);
      lfo.start(t);
      lfo.stop(t + len + rel + 0.05);
    }
    // reese detune
    if (p==="reese"){
      const o2 = ctx.createOscillator();
      o2.type = "sawtooth";
      o2.frequency.setValueAtTime(midiToFreq(midi)*1.005, t);
      const g2 = ctx.createGain();
      this._env(g2, t, 0.006, 0.07, 0.22, rel, peak*0.45);
      o2.connect(f);
      f.connect(g2);
      g2.connect(this.bassBus);
      o2.start(t);
      o2.stop(t + len + rel + 0.05);
    }

    o.start(t);
    o.stop(t + len + rel + 0.05);
  }

  /* ---------- DRUMS ---------- */
  _noise(t, len, hp=2000){
    const ctx = this.ctx;
    const src = ctx.createBufferSource();
    const buf = ctx.createBuffer(1, Math.floor(ctx.sampleRate*len), ctx.sampleRate);
    const data = buf.getChannelData(0);
    for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1);
    src.buffer = buf;

    const f = ctx.createBiquadFilter();
    f.type = "highpass";
    f.frequency.setValueAtTime(hp, t);
    const g = ctx.createGain();
    src.connect(f); f.connect(g); g.connect(this.drumsBus);
    return {src, g, f};
  }

  hitRide(t, vel=0.5){
    const ctx = this.ctx;
    const p = this.presets.drums;
    const hp = (p==="brushes") ? 1800 : (p==="lofi" ? 1400 : 2400);
    const {src,g} = this._noise(t, 0.12, hp);
    this._env(g, t, 0.001, 0.03, 0.12, 0.08, vel*0.35);
    src.start(t); src.stop(t+0.13);
  }

  hitHat(t, vel=0.45){
    const p = this.presets.drums;
    const hp = (p==="trap") ? 5000 : 3800;
    const {src,g} = this._noise(t, 0.08, hp);
    this._env(g, t, 0.001, 0.02, 0.10, 0.05, vel*0.28);
    src.start(t); src.stop(t+0.09);
  }

  hitSnare(t, vel=0.6){
    const ctx = this.ctx;
    const p = this.presets.drums;
    const {src,g} = this._noise(t, 0.14, p==="lofi" ? 900 : 1400);
    this._env(g, t, 0.001, 0.03, 0.18, 0.11, vel*0.35);

    const body = ctx.createOscillator();
    body.type = "triangle";
    body.frequency.setValueAtTime(180, t);
    const bg = ctx.createGain();
    this._env(bg, t, 0.001, 0.02, 0.10, 0.08, vel*0.18);
    body.connect(bg); bg.connect(this.drumsBus);
    body.start(t); body.stop(t+0.12);

    src.start(t); src.stop(t+0.16);
  }

  hitKick(t, vel=0.7){
    const ctx = this.ctx;
    const o = ctx.createOscillator();
    o.type = "sine";
    const g = ctx.createGain();

    o.frequency.setValueAtTime(120, t);
    o.frequency.exponentialRampToValueAtTime(48, t+0.06);

    this._env(g, t, 0.001, 0.03, 0.08, 0.10, vel*0.55);

    o.connect(g); g.connect(this.drumsBus);
    o.start(t); o.stop(t+0.16);
  }
}

/* ========= PLAYER / TRANSPORT ========= */
const player = (() => {
  let ctx = null;
  let synth = null;

  let timer = null;
  let startedAt = 0;
  let nextTickAt = 0;

  let chart = [];
  let pos = { bar:0, half:0, step:0 }; // step = 8th-note steps inside current bar (0..7 or 0..3 if half slot)
  let resumePos = { bar:0, half:0 };

  let tempo = DEFAULTS.tempo;
  let swing = DEFAULTS.swing; // 50..75

  let groove = DEFAULTS.grooveStyle;
  let compStyle = DEFAULTS.compStyle;

  let feel = {
    keysComplex: DEFAULTS.keysComplex,
    keysFill: DEFAULTS.keysFill,
    bassComplex: DEFAULTS.bassComplex,
    bassFill: DEFAULTS.bassFill,
    drumsComplex: DEFAULTS.drumsComplex,
    drumsFill: DEFAULTS.drumsFill,
  };

  let isPlaying = false;
  let isPaused = false;

  let drumsLevel = DEFAULTS.drumsLevel/100;

  function ensureCtx(){
    if (!ctx){
      ctx = new (window.AudioContext || window.webkitAudioContext)();
      synth = new MiniSynth(ctx);
      synth.setDrumsLevel(drumsLevel);
    }
    return ctx;
  }

  function setTempo(t, sw){
    tempo = clamp(Number(t)||120, 30, 400);
    swing = clamp(Number(sw)||60, 50, 80);
  }

  function setGroove(g){ groove = g || "swing"; }
  function setCompStyle(s){ compStyle = s || "twoStabs"; }
  function setPresets(b,k,d){ ensureCtx(); synth.setPresets(b,k,d); }
  function setFeel(s){
    feel = {
      keysComplex: s.keysComplex|0,
      keysFill: s.keysFill|0,
      bassComplex: s.bassComplex|0,
      bassFill: s.bassFill|0,
      drumsComplex: s.drumsComplex|0,
      drumsFill: s.drumsFill|0,
    };
  }
  function setDrumsLevel(v01){
    drumsLevel = clamp(v01,0,1);
    if (synth) synth.setDrumsLevel(drumsLevel);
  }

  function setChart(bars){
    chart = bars || [];
  }

  function currentChord(){
    const barObj = chart[pos.bar];
    const chords = barObj?.chords || [];
    const idx = Math.min(pos.half, chords.length-1);
    return chords[idx] || null;
  }

  function chordAt(bar, half){
    const barObj = chart[bar];
    const chords = barObj?.chords || [];
    const idx = Math.min(half, chords.length-1);
    return chords[idx] || null;
  }

  function barHasSplit(bar){
    const barObj = chart[bar];
    return !!barObj?.split;
  }

  function stepsInCurrentSlot(){
    // 8th-note steps per bar = 8. If bar split, each half = 4 steps.
    return barHasSplit(pos.bar) ? 4 : 8;
  }

  function stepDur(stepIndex){
    // 8th-note swing: delay the off-beat (odd steps) by swing amount.
    // base 8th duration:
    const base = (60/tempo) / 2; // seconds per 8th
    const sw = (swing-50)/25; // 0..1 when 50..75
    // push odd steps longer, even steps shorter; keep sum ~2*base
    const long = base * (1 + 0.45*sw);
    const short= base * (1 - 0.45*sw);
    return (stepIndex % 2 === 1) ? long : short;
  }

  function voicingForChord(ch){
    // simple, musical-ish voicing around C4..C5
    const rootMidi = 48 + (pc(ch.root)); // around C3/C4 area
    const tones = ch.intervals.map(i=>rootMidi + i).filter(n=>n>=45 && n<=84);
    // pick 3-5 notes max, drop duplicates by pitch class
    const seen = new Set();
    const uniq = [];
    for (const n of tones){
      const p = pc(n);
      if (!seen.has(p)){ seen.add(p); uniq.push(n); }
    }
    // tighten: include 3rd+7th always if present
    const want = [];
    function pushIf(pcTarget){
      const found = uniq.find(n=>pc(n-rootMidi)===pcTarget) || uniq.find(n=>pc(n)===pc(rootMidi+pcTarget));
      if (found!=null && !want.includes(found)) want.push(found);
    }
    if (ch.family==="dom" || ch.family==="min" || ch.family==="maj" || ch.family==="minmaj"){
      pushIf(ch.family==="min" || ch.family==="minmaj" ? 3 : 4);
      pushIf(10); // 7th (dom/min)
      pushIf(11); // maj7
    }
    // add root sometimes based on keys complexity (lower complexity -> more root)
    if ((feel.keysComplex/100) < 0.55) want.unshift(rootMidi);
    // fill with remaining tones
    for (const n of uniq){
      if (want.length>=5) break;
      if (!want.includes(n)) want.push(n);
    }
    // shift up an octave if too low
    const avg = want.reduce((s,n)=>s+n,0)/Math.max(1,want.length);
    const up = avg < 55 ? 12 : 0;
    return want.map(n=>n+up);
  }

  function bassTargetForChord(ch){
    // keep bass in lower register
    let m = 36 + pc(ch.root); // C2-ish
    if (m < 34) m += 12;
    if (m > 50) m -= 12;
    return m;
  }

  /* ---------- PATTERNS ---------- */
  function compHitsForStyle(style, steps){
    // steps = 8 (full bar) or 4 (half)
    // Return array of step indices to hit
    const s = style || "twoStabs";
    if (steps===4){
      // half-bar variants
      if (s==="fourComp") return [0,1,2,3];
      if (s==="charleston") return [0,2];
      if (s==="anticipations") return [1,3];
      if (s==="pushPull") return chance(0.5) ? [0,3] : [1,2];
      if (s==="sparse") return [0];
      if (s==="arpeggio") return [0,1,2,3];
      if (s==="sustain") return [0];
      if (s==="montuno") return [0,2,3];
      if (s==="clav") return [0,2];
      if (s==="houseChop") return [0,2];
      return [0,2];
    }

    // full bar (8 steps)
    if (s==="twoStabs") return [0,4];
    if (s==="fourComp") return [0,2,4,6];
    if (s==="charleston") return [0,3];
    if (s==="anticipations") return [1,4,7];
    if (s==="pushPull") return [0,3,5,7];
    if (s==="sparse") return [0,5];
    if (s==="arpeggio") return [0,1,2,3,4,5,6,7];
    if (s==="sustain") return [0];
    if (s==="montuno") return [0,2,3,5,6];
    if (s==="clav") return [0,2,3,5,7];
    if (s==="houseChop") return [0,4,6];
    return [0,4];
  }

  function drumsPattern(stepInBar){
    // returns {ride,hat,kick,snare,ghostHat} booleans for this 8th step
    const c = feel.drumsComplex/100;
    const g = groove;

    const base = {ride:false,hat:false,kick:false,snare:false,ghostHat:false};

    if (g==="swing"){
      // ride on all steps; accent on 0,3,4,7 loosely
      base.ride = true;
      base.hat = (stepInBar===4); // "2 and 4" = step 4 in 8th grid is beat 3's downbeat; we also add beat 2? We'll do both:
      if (stepInBar===2 || stepInBar===6) base.hat = true;
      base.kick = (stepInBar===0) || (c>0.6 && (stepInBar===5 || stepInBar===7) && chance(0.25));
      base.snare = (stepInBar===4) && chance(0.65);
      base.ghostHat = (c>0.55 && chance(0.20));
      return base;
    }

    if (g==="brushBallad"){
      base.ride = (stepInBar%2===0);
      base.snare = (stepInBar===4) && chance(0.55);
      base.kick = (stepInBar===0) && chance(0.55);
      base.ghostHat = (c>0.4 && chance(0.15));
      return base;
    }

    if (g==="bossa" || g==="afroCuban"){
      base.hat = (stepInBar%2===1);
      base.kick = (stepInBar===0 || stepInBar===4) && chance(0.6);
      base.snare = (stepInBar===2 || stepInBar===6) && chance(0.55);
      base.ride = (c>0.5 && chance(0.25));
      return base;
    }

    if (g==="funk"){
      base.hat = true;
      base.kick = (stepInBar===0 || stepInBar===3 || stepInBar===5) && chance(0.55 + c*0.25);
      base.snare = (stepInBar===4) || (c>0.75 && stepInBar===6 && chance(0.35));
      base.ghostHat = (c>0.6 && chance(0.20));
      return base;
    }

    if (g==="hiphop"){
      base.hat = (stepInBar%1===0) && chance(0.85);
      base.kick = (stepInBar===0 || stepInBar===5) && chance(0.55 + c*0.20);
      base.snare = (stepInBar===4) && chance(0.9);
      base.ghostHat = (c>0.5 && chance(0.30));
      return base;
    }

    if (g==="house"){
      base.kick = (stepInBar===0 || stepInBar===4);
      base.hat  = (stepInBar%2===1) && chance(0.85);
      base.snare= (stepInBar===4) && chance(0.25);
      base.ride = (c>0.75 && chance(0.25));
      return base;
    }

    if (g==="dnb" || g==="breaks"){
      base.hat = true;
      base.kick = (stepInBar===0 || stepInBar===3 || stepInBar===5) && chance(0.6+c*0.25);
      base.snare = (stepInBar===4) && chance(0.95);
      base.ride = (c>0.8 && chance(0.25));
      return base;
    }

    if (g==="ambient"){
      base.ride = chance(0.35 + c*0.20);
      base.hat = chance(0.25 + c*0.20);
      base.kick = (stepInBar===0) && chance(0.25);
      base.snare = (stepInBar===4) && chance(0.15);
      return base;
    }

    if (g==="free"){
      base.ride = chance(0.55 + c*0.35);
      base.hat = chance(0.25 + c*0.35);
      base.kick = chance(0.20 + c*0.25);
      base.snare = chance(0.15 + c*0.25);
      return base;
    }

    return base;
  }

  function bassPattern(stepInBar, stepsInSlot, ch, prevCh){
    // return midi note or null
    const c = feel.bassComplex/100;
    const root = bassTargetForChord(ch);

    // walking-ish: more complexity -> more steps
    const wantWalk = (c > 0.45);
    if (!wantWalk){
      if (stepInBar===0) return root;
      if (stepsInSlot===8 && stepInBar===4 && chance(0.35)) return root + 12;
      return null;
    }

    // choose targets
    const chordPCs = chordTonesPCs(ch);
    const nextRoot = root;
    const stepStrong = (stepInBar===0 || stepInBar===4);

    if (stepStrong) return (stepInBar===0) ? root : (chance(0.35+c*0.25) ? root+7 : root);

    // passing tones / approach notes
    const approachChance = 0.25 + c*0.35;
    if (chance(approachChance)){
      const dir = chance(0.5) ? 1 : -1;
      return root + dir * pick([1,2,3,5,7]);
    }

    // chord tone pick
    const tone = pick(chordPCs);
    let m = 36 + tone;
    while (m < 34) m += 12;
    while (m > 52) m -= 12;
    return m;
  }

  function maybeDoFills(t, slotIndexIn4bar, isEndOfPhrase){
    // randomized "fill shapes" ‚Äî not the same fill each time
    const kF = feel.keysFill/100;
    const bF = feel.bassFill/100;
    const dF = feel.drumsFill/100;

    // prefer phrase ends, but sometimes mid
    const pBoost = isEndOfPhrase ? 1.0 : 0.45;

    const doKeys = chance(kF * 0.55 * pBoost);
    const doBass = chance(bF * 0.50 * pBoost);
    const doDrum = chance(dF * 0.65 * pBoost);

    const fillShapes = [
      [6,7],          // last two 8ths
      [5,6,7],        // run
      [4,6,7],        // skip
      [3,5,6,7],      // ramp
      [7],            // tag
    ];

    return { doKeys, doBass, doDrum, shape: pick(fillShapes) };
  }

  function scheduleStep(t, globalStepInBar, stepsInSlot, ch, prevCh, isFill, fillShape){
    ensureCtx();

    // drums
    const d = drumsPattern(globalStepInBar);
    const dVelBase = 0.65 + (feel.drumsComplex/100)*0.25;

    if (d.ride) synth.hitRide(t, dVelBase*0.70);
    if (d.hat) synth.hitHat(t, dVelBase*0.55);
    if (d.kick) synth.hitKick(t, dVelBase*0.75);
    if (d.snare) synth.hitSnare(t, dVelBase*0.70);
    if (d.ghostHat && chance(0.35)) synth.hitHat(t, dVelBase*0.35);

    if (isFill){
      // fill shapes: little flurries
      if (fillShape.includes(globalStepInBar)){
        if (chance(0.55)) synth.hitSnare(t, dVelBase*0.55);
        if (chance(0.40)) synth.hitHat(t, dVelBase*0.45);
        if (chance(0.25)) synth.hitKick(t, dVelBase*0.55);
      }
    }

    // bass
    const bassMidi = bassPattern(globalStepInBar, stepsInSlot, ch, prevCh);
    if (bassMidi!=null){
      const len = (globalStepInBar%2===0) ? 0.14 : 0.12;
      const vel = 0.65 + (feel.bassComplex/100)*0.25;
      synth.playBassNote(bassMidi, t, len, vel);
    }
    if (isFill && fillShape.includes(globalStepInBar)){
      if (chance(0.35 + (feel.bassFill/100)*0.35)){
        synth.playBassNote(bassTargetForChord(ch)+pick([2,3,5,7,9]), t, 0.10, 0.45);
      }
    }

    // keys comp
    const hits = compHitsForStyle(compStyle, stepsInSlot);
    const keysBusy = feel.keysComplex/100;
    const isHit = hits.includes(globalStepInBar);
    const vel = 0.55 + keysBusy*0.30;

    if (isHit){
      const notes = voicingForChord(ch);
      const len = (compStyle==="sustain" ? (stepsInSlot===8 ? 0.85 : 0.45) : 0.16) * (60/tempo);
      synth.playKeysChord(notes, t, Math.max(0.12, len), vel);
    } else if (keysBusy > 0.78 && chance(0.12 + keysBusy*0.10)){
      // extra syncopation with high complexity
      const notes = voicingForChord(ch).slice(0, chance(0.5)?3:4);
      synth.playKeysChord(notes, t, 0.11, vel*0.6);
    }

    if (isFill && fillShape.includes(globalStepInBar) && chance(0.45 + (feel.keysFill/100)*0.35)){
      const notes = voicingForChord(ch);
      // little arpeggio-ish jab
      const single = pick(notes);
      synth.playKeysChord([single], t, 0.10, vel*0.55);
    }
  }

  function advanceStep(){
    const stepsSlot = stepsInCurrentSlot();
    pos.step += 1;

    if (pos.step >= stepsSlot){
      pos.step = 0;
      // advance half / bar
      if (barHasSplit(pos.bar)){
        if (pos.half === 0){
          pos.half = 1;
        } else {
          pos.half = 0;
          pos.bar += 1;
        }
      } else {
        pos.bar += 1;
        pos.half = 0;
      }

      if (pos.bar >= state.bars){
        // loop
        pos.bar = 0; pos.half = 0; pos.step = 0;
      }

      // keep UI in sync exactly at chord boundaries
      state.activeBar = pos.bar;
      state.activeHalf = pos.half;
      renderSheet();
      updatePianoForActive();
    }
  }

  function tick(){
    if (!isPlaying || isPaused) return;

    const ctx = ensureCtx();
    const now = ctx.currentTime;

    // schedule slightly ahead
    const lookahead = 0.10; // seconds
    while (nextTickAt < now + lookahead){
      // compute chord and schedule
      const ch = currentChord();
      if (ch){
        const stepsSlot = stepsInCurrentSlot();

        // map slot step to "global step in bar" 0..7
        let globalStep = pos.step;
        if (barHasSplit(pos.bar)){
          globalStep = (pos.half===0 ? pos.step : (pos.step + 4));
        }

        // fill logic at phrase ends (every 4 bars)
        const slotIdxIn4 = pos.bar % 4;
        const isPhraseEnd = (pos.bar % 4 === 3) && (globalStep >= 4);
        const fill = maybeDoFills(nextTickAt, slotIdxIn4, isPhraseEnd);
        const isFill = fill.doDrum || fill.doBass || fill.doKeys;

        // to avoid fills constantly: only enable on some steps near end
        const fillShape = fill.shape;

        scheduleStep(
          nextTickAt,
          globalStep,
          barHasSplit(pos.bar) ? 4 : 8,
          ch,
          (pos.bar>0 || pos.half>0) ? chordAt(pos.bar, Math.max(0,pos.half-1)) || chordAt(Math.max(0,pos.bar-1), 1) : null,
          isFill,
          fillShape
        );
      }

      // advance + next time
      const d = stepDur(pos.step);
      nextTickAt += d;
      advanceStep();
    }

    timer = setTimeout(tick, 25);
  }

  async function start(){
    ensureCtx();
    if (ctx.state === "suspended") await ctx.resume();

    isPlaying = true;
    isPaused = false;

    // start from resumePos if set (used when pausing and tapping chords)
    pos.bar = clamp(resumePos.bar, 0, Math.max(0,state.bars-1));
    pos.half = clamp(resumePos.half, 0, 1);
    pos.step = 0;

    state.activeBar = pos.bar;
    state.activeHalf = pos.half;
    renderSheet();
    updatePianoForActive();

    startedAt = ctx.currentTime;
    nextTickAt = ctx.currentTime + 0.03;

    clearTimeout(timer);
    timer = setTimeout(tick, 10);
  }

  function pause(){
    if (!isPlaying) return;
    isPaused = true;
    clearTimeout(timer);
    timer = null;
  }

  async function resume(){
    if (!isPlaying) return start();
    ensureCtx();
    if (ctx.state === "suspended") await ctx.resume();
    isPaused = false;
    nextTickAt = ctx.currentTime + 0.03;
    clearTimeout(timer);
    timer = setTimeout(tick, 10);
  }

  function stopHard(){
    isPlaying = false;
    isPaused = false;
    clearTimeout(timer);
    timer = null;
  }

  function jumpTo(bar, half){
    resumePos = { bar: bar|0, half: half|0 };
    if (!isPlaying) return;
    // if currently playing, jump immediately
    pos.bar = clamp(resumePos.bar, 0, Math.max(0,state.bars-1));
    pos.half = clamp(resumePos.half, 0, 1);
    pos.step = 0;
  }

  function setResumePos(bar, half){
    resumePos = { bar: bar|0, half: half|0 };
  }

  async function previewChord(ch){
    ensureCtx();
    if (ctx.state === "suspended") await ctx.resume();
    const t = ctx.currentTime + 0.01;

    // quick ‚Äúband‚Äù preview (no transport)
    const notes = voicingForChord(ch);
    synth.playKeysChord(notes, t, 0.18, 0.75);
    synth.playBassNote(bassTargetForChord(ch), t, 0.14, 0.65);
    // subtle tick
    synth.hitRide(t, 0.35);
  }

  return {
    get isPlaying(){ return isPlaying; },
    get isPaused(){ return isPaused; },

    lastHalvesCount: 0,

    setChart,
    setTempo,
    setGroove,
    setCompStyle,
    setPresets,
    setFeel,
    setDrumsLevel,

    start,
    pause,
    resume,
    stopHard,

    jumpTo,
    setResumePos,
    previewChord,
  };
})();

/* Play/Pause button */
function updatePlayBtn(){
  if (!player.isPlaying) els.btnPlay.textContent = "Play";
  else if (player.isPaused) els.btnPlay.textContent = "Resume";
  else els.btnPlay.textContent = "Pause";
}

els.btnPlay.addEventListener("click", async ()=>{
  try{
    if (!player.isPlaying){
      player.setChart(state.chartBars);
      player.setTempo(state.tempo, state.swing);
      player.setGroove(state.grooveStyle);
      player.setCompStyle(state.compStyle);
      player.setPresets(els.bassPreset.value, els.keysPreset.value, els.drumsPreset.value);
      player.setFeel(state);
      player.setDrumsLevel((Number(els.drumsLevel.value)||55)/100);
      player.setResumePos(state.activeBar, state.activeHalf);
      await player.start();
      els.msg.textContent = "Playing‚Ä¶ (tap any bar to jump / preview when paused)";
    } else if (player.isPaused){
      await player.resume();
      els.msg.textContent = "Resumed.";
    } else {
      player.pause();
      player.setResumePos(state.activeBar, state.activeHalf);
      els.msg.textContent = "Paused. Tap a chord to preview or set resume point.";
    }
  } finally {
    updatePlayBtn();
  }
});

/* keep tempo/swing live while playing handled in range wiring */

/* ========= INITIALIZE ========= */
function init(){
  loadSaved();

  applySectionOrder(getSectionOrder());

  applyPianoTheme(els.pianoTheme.value || DEFAULTS.pianoTheme);
  applyMarkerStyle(els.markerStyle.value || DEFAULTS.markerStyle);

  applyScaleOutlineSettings(
    Number(els.scaleOutlineW.value || DEFAULTS.scaleStrokeWidth),
    Number(els.scaleOutlineA.value || DEFAULTS.scaleStrokeAlphaPct)
  );

  renderPianoBase();

  // set default limiter + generate once
  setChordLimiterState(DEFAULTS.limiter);
  state.limiter = getChordLimiterState();

  // set initial UI values explicitly
  els.bars.value = state.bars; els.barsNum.value = state.bars;
  els.tempo.value = state.tempo; els.tempoNum.value = state.tempo;
  els.swing.value = state.swing; els.swingNum.value = state.swing;
  els.chaos.value = state.chaos; els.chaosNum.value = state.chaos;

  els.halfChords.checked = state.halfEnabled;
  els.halfDensity.value = state.halfDensity; els.halfDensityNum.value = state.halfDensity;

  els.rootMode.value = state.rootMode;
  els.grooveStyle.value = state.grooveStyle;
  els.compStyle.value = state.compStyle;

  els.bassPreset.value = DEFAULTS.bassPreset;
  els.keysPreset.value = DEFAULTS.keysPreset;
  els.drumsPreset.value = DEFAULTS.drumsPreset;
  els.drumsLevel.value = DEFAULTS.drumsLevel; els.drumsLevelNum.value = DEFAULTS.drumsLevel;

  els.keysComplex.value = state.keysComplex; els.keysComplexNum.value = state.keysComplex;
  els.keysFill.value = state.keysFill; els.keysFillNum.value = state.keysFill;
  els.bassComplex.value = state.bassComplex; els.bassComplexNum.value = state.bassComplex;
  els.bassFill.value = state.bassFill; els.bassFillNum.value = state.bassFill;
  els.drumsComplex.value = state.drumsComplex; els.drumsComplexNum.value = state.drumsComplex;
  els.drumsFill.value = state.drumsFill; els.drumsFillNum.value = state.drumsFill;

  generateAndRender();
  updatePlayBtn();
}

init();
</script>
</body>
</html>
