<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>ü§ñ fakebot</title>

  <style>
    :root{
      /* Page theme vars */
      --pageBg:#0b0f14;
      --pageInk:#e9eef6;
      --pageMuted:#9aa6b2;
      --pageLine:rgba(255,255,255,.09);
      --pagePanel:rgba(255,255,255,.05);
      --pagePanel2:rgba(0,0,0,.20);

      --pageGlowA: rgba(122,162,255,.08);
      --pageGlowB: rgba(182,124,255,.08);
      --pageGlowC: rgba(63,225,139,.06);

      /* Morphing gradient (default ON) */
      --morphOn: 1; /* 1=on, 0=off */
      --morphA: rgba(60,180,255,.22);
      --morphB: rgba(255,90,220,.18);
      --morphC: rgba(90,255,170,.16);
      --morphD: rgba(255,210,120,.14);

      /* Piano theme */
      --accent:#2f6bff;  /* scale fill */
      --good:#3fe18b;    /* root marker */
      --chord:#b67cff;   /* chord marker */

      --keyWhite:#f2f5fb;
      --keyBlack:#161b23;
      --keyBorder:#c9d3e2;
      --keyBlackBorder:#2a3240;
      --keyBorderStrong: rgba(0,0,0,.35);

      /* Fixed thin black outline for scale keys */
      --scaleStrokeAlpha: 0.88;
      --scaleStrokeWidth: 2.2;

      --radius:16px;
      --tap:44px;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--pageInk);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      -webkit-font-smoothing: antialiased;
      overflow-x:hidden;
      touch-action: manipulation;
      background: var(--pageBg);
    }

    /* Base glows */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-2;
      background:
        radial-gradient(1200px 800px at 30% 10%, var(--pageGlowA), transparent 55%),
        radial-gradient(900px 600px at 90% 30%, var(--pageGlowB), transparent 55%),
        radial-gradient(1100px 700px at 55% 95%, var(--pageGlowC), transparent 60%),
        linear-gradient(180deg, var(--pageBg), var(--pageBg));
      background-repeat:no-repeat;
    }

    /* Morphing gradient overlay (toggleable) */
    body::after{
      content:"";
      position:fixed;
      inset:-40px;
      z-index:-1;
      pointer-events:none;
      opacity: calc(var(--morphOn) * 0.95);
      background:
        radial-gradient(1200px 800px at 15% 20%, var(--morphA), transparent 62%),
        radial-gradient(1100px 700px at 80% 25%, var(--morphB), transparent 62%),
        radial-gradient(1200px 850px at 60% 85%, var(--morphC), transparent 62%),
        radial-gradient(900px 600px at 25% 80%, var(--morphD), transparent 62%);
      filter: blur(10px) saturate(1.15);
      transform: translateZ(0);
      animation: morphMove 14s ease-in-out infinite alternate;
      mix-blend-mode: screen;
    }
    @keyframes morphMove{
      0%   { transform: translate3d(-10px,-8px,0) scale(1.02); }
      50%  { transform: translate3d(18px,10px,0) scale(1.06); }
      100% { transform: translate3d(-6px,14px,0) scale(1.04); }
    }

    button, input, select, label {font:inherit}
    button { -webkit-tap-highlight-color: transparent; }
    input[type="range"]{width:100%}
    .app{max-width:1100px;margin:0 auto;padding:14px 12px 22px;}

    .card{
      border:1px solid var(--pageLine);border-radius: var(--radius);
      background: var(--pagePanel);box-shadow: var(--shadow);
      overflow:hidden;margin-bottom:12px;
    }
    .cardHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      padding:12px 12px;border-bottom:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }
    .title{font-size:12px;color:var(--pageMuted);letter-spacing:.2px;user-select:none;}
    .cardBody{padding:12px}

    h1{margin:0;font-size:18px;font-weight:900;letter-spacing:.2px;}
    .sub{margin-top:2px;color:var(--pageMuted);font-size:12px;}
    .msg{margin-top:10px;font-size:12px;color: var(--pageMuted);user-select:none;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .grow{flex:1;min-width:220px}
    .miniStat{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border:1px solid var(--pageLine);border-radius:999px;
      background: rgba(0,0,0,.18);color: var(--pageMuted);font-size:12px;
      user-select:none;white-space:nowrap;
    }
    .miniStat strong{color:var(--pageInk);font-weight:900}

    .btn{
      min-height: var(--tap);
      padding: 10px 12px;border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color: var(--pageInk);cursor:pointer;
      display:inline-flex;align-items:center;justify-content:center;gap:8px;
      transition: transform .06s ease, border-color .15s ease,width .15s ease, opacity .15s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      border-color: rgba(122,162,255,.45);
      background: linear-gradient(180deg, rgba(122,162,255,.18), rgba(122,162,255,.06));
    }
    .btn.ghost{background: transparent}
    .btn.small{min-height:36px;padding:7px 8px;border-radius:10px;font-size:13px}
    .btn.tiny{min-height:34px;padding:6px 8px;border-radius:10px;font-size:12px}
    .btn:disabled{opacity:.45;cursor:not-allowed;transform:none}
    .btnRow{display:flex;gap:8px;flex-wrap:wrap}
    .btnRow .btn{flex:1;min-width:120px}

    /* Lead sheet */
    .sheet{display:grid;grid-template-columns: repeat(4, minmax(0, 1fr));gap:10px;}
    @media (max-width: 640px){ .sheet{grid-template-columns: repeat(2, minmax(0, 1fr));} }
    .bar{
      position:relative;min-height: 62px;background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);border-radius: 14px;
      padding: 12px 10px 10px;cursor:pointer;
      transition: border-color .15s ease, transform .06s ease, background .15s ease;
      overflow:hidden;user-select:none;
    }
    .bar:active{transform: translateY(1px)}
    .bar.active{border-color: rgba(122,162,255,.70);background: rgba(122,162,255,.08);}
    .bar.editing{border-color: rgba(63,225,139,.55);background: rgba(63,225,139,.06);}
    .bar .sym{font-weight:900;letter-spacing:.2px;font-size:16px;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;padding-right:28px;}
    .bar .sym2{margin-top:6px;padding-top:6px;border-top:1px solid rgba(255,255,255,.08);}
    .bar .num{position:absolute;top:10px;right:10px;font-size:12px;color: rgba(154,166,178,.55);}

    .bar .halfHit{
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      pointer-events:none;
    }
    .bar .halfHit button{
      flex:1;background:transparent;border:0;padding:0;margin:0;cursor:pointer;pointer-events:auto;
    }
    .bar .halfHit button:active{background: rgba(122,162,255,.06);}
    .bar .halfHit button:first-child{border-bottom:1px solid rgba(255,255,255,.06);}

    /* Piano */
    .legend{display:flex;gap:10px;flex-wrap:wrap;align-items:center;color: var(--pageMuted);font-size:12px;user-select:none;margin-bottom:10px;}
    .dotLegend{display:inline-flex;align-items:center;gap:6px;}
    .sw{width:10px;height:10px;border-radius:999px;border:1px solid rgba(255,255,255,.15);}
    .sw.scale{background: var(--accent); border-color: rgba(47,107,255,.95)}
    .sw.root{background: var(--good); border-color: rgba(63,225,139,.95)}
    .sw.chord{background: var(--chord); border-color: rgba(182,124,255,.95)}
    .pianoBox{border:1px solid rgba(255,255,255,.10);border-radius: 16px;background: rgba(0,0,0,.18);overflow:hidden;}
    svg{display:block;width:100%;height:auto}
    .hint{margin-top:10px;color: rgba(154,166,178,.85);font-size:12px;line-height:1.2;user-select:none;}

    /* Collapsible groups (Controls + Limiters) */
    details.group{
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      border-radius:14px;
      overflow:hidden;
      margin-bottom:10px;
    }
    details.group > summary{
      list-style:none;
      cursor:pointer;
      padding:12px 12px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      user-select:none;
      background: rgba(255,255,255,.03);
    }
    details.group > summary::-webkit-details-marker{display:none}
    .sumLeft{display:flex;align-items:center;gap:10px;min-width:0}
    .sumTitle{font-weight:900;font-size:13px;color:rgba(233,238,246,.92);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .sumSub{font-size:12px;color:var(--pageMuted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .chev{font-size:12px;color:var(--pageMuted); transition: transform .15s ease;}
    details[open] .chev{transform:rotate(180deg)}
    .groupBody{padding:12px}

    /* Controls grid inside groups */
    .controls{display:grid;grid-template-columns: repeat(6, minmax(0,1fr));gap:10px;}
    @media (max-width: 980px){ .controls{grid-template-columns: repeat(3, minmax(0,1fr));} }
    @media (max-width: 520px){ .controls{grid-template-columns: repeat(2, minmax(0,1fr));} }
    .control{
      padding:10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);
      background: var(--pagePanel2);min-width:0;
    }
    .control label{display:block;font-size:11px;color: rgba(154,166,178,.88);margin-bottom:6px;user-select:none;}
    .inline{display:flex;align-items:center;gap:8px;min-width:0;}
    input[type="number"], select{
      width: 98px;min-height: 38px;background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);color: var(--pageInk);
      border-radius: 10px;padding: 8px 8px;outline:none;
    }
    select{width:100%}

    .checkRow{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .chip{
      display:inline-flex;align-items:center;gap:8px;padding:10px 10px;border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);background: rgba(0,0,0,.18);
      min-height: 44px;user-select:none;
    }
    .chip input{transform: scale(1.1)}
    .chip span{font-size:13px;color: rgba(233,238,246,.92)}

    /* Advanced settings modal */
    .modalBack{
      position:fixed;inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:14px;
      z-index:9999;
    }
    .modal{
      width:min(860px,100%);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      background: rgba(12,16,22,.96);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .modalHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:12px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .modalTitle{font-weight:900;font-size:14px;letter-spacing:.2px;}
    .modalBody{padding:12px}
    .modalRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 10px;border:1px solid rgba(255,255,255,.08);
      border-radius:14px;background: rgba(0,0,0,.22);
      margin-bottom:10px;
    }
    .modalRow .name{font-size:13px;color: rgba(233,238,246,.92);font-weight:800}
    .reorderBtns{display:flex;gap:8px;flex-wrap:wrap}
    .gearBtn{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 12px;
      min-height: 38px;
      padding:8px 10px;
      cursor:pointer;
      color: var(--pageInk);
      display:inline-flex;align-items:center;gap:8px;
      user-select:none;
    }
    .splitLine{height:1px;background: rgba(255,255,255,.10);margin:12px 0;}
    .modalSubTitle{font-size:12px;color: var(--pageMuted);margin:0 0 8px 2px;}
    .modalGrid{display:grid;grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 560px){ .modalGrid{grid-template-columns: 1fr;} }
    .miniCtl{
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .miniCtl label{display:block;font-size:11px;color: rgba(154,166,178,.88);margin-bottom:6px;}
    .miniRow{display:flex;gap:8px;align-items:center;}
    .miniRow input[type="range"]{flex:1}
    .miniRow input[type="number"]{width:86px}

    /* Lock buttons: per-area, emoji toggles */
    .lockMini{
      min-height:34px;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color: var(--pageInk);
      cursor:pointer;
      user-select:none;
      display:inline-flex;align-items:center;gap:8px;
      font-size:12px;
      white-space:nowrap;
    }
    .lockMini.on{
      border-color: rgba(63,225,139,.45);
      background: linear-gradient(180deg, rgba(63,225,139,.14), rgba(0,0,0,.12));
    }
    .lockMini b{font-weight:900}

    /* Edit chord modal */
    .editModalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.62);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:14px;
      z-index:10000;
    }
    .editModal{
      width:min(860px,100%);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      background: rgba(12,16,22,.97);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .editHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:12px 12px;border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .editTitle{font-weight:900;font-size:14px;}
    .editBody{padding:12px}
    .editGrid{display:grid;grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px;}
    @media (max-width: 560px){ .editGrid{grid-template-columns: 1fr;} }
    .editNote{margin:10px 0 0 0;color:var(--pageMuted);font-size:12px;}
    .editActions{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px;}
    .editActions .btn{flex:1;min-width:140px;}
  </style>
</head>

<body>
  <div class="app">

    <!-- TITLE BAR -->
    <section class="card" id="cardHeader" data-section="header">
      <div class="cardHead">
        <div class="title"> </div>
        <button class="gearBtn" id="btnGear" aria-label="Advanced settings" title="Advanced settings">
          ‚öôÔ∏è <span style="font-size:12px;color:var(--pageMuted);">Advanced</span>
        </button>
      </div>
      <div class="cardBody">
        <div class="row">
          <div class="grow">
            <h1>ü§ñ fakebot</h1>
            <div class="sub"> </div>
            <div class="msg" id="msg"> </div>
          </div>

          <div class="grow" style="min-width:260px">
            <div class="btnRow">
              <button class="btn tiny" id="btnCopy" title="Copy chart">üìã Copy</button>
              <button class="btn tiny" id="btnStyleRand" title="Randomize style (keeps progression)">üé® Style</button>
              <button class="btn primary tiny" id="btnPlay" title="Play / Pause">‚ñ∂Ô∏è Play</button>
            </div>
            <div class="btnRow" style="margin-top:8px">
              <button class="btn tiny" id="btnGenerate" title="Generate new chart">üé∞ Generate</button>
              <button class="btn tiny" id="btnRandomAll" title="Randomize everything">üé≤ Random</button>
              <button class="btn tiny" id="btnDefaults" title="Defaults">‚Ü©Ô∏è Defaults</button>
            </div>
            <div class="btnRow" style="margin-top:8px">
              <button class="btn tiny" id="btnUndo" title="Undo (up to 5)">‚Ü©Ô∏è Undo</button>
              <button class="btn tiny" id="btnRedo" title="Redo">‚Ü™Ô∏è Redo</button>
            </div>

            <div class="row" style="margin-top:10px">
              <span class="miniStat" id="pillLine">‚Äî</span>
              <span class="miniStat">Focused: <strong id="focusLine">‚Äî</strong></span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- DEFAULT ORDER: title bar, piano, lead sheet, control, limiters -->

    <!-- PIANO -->
    <section class="card" id="cardPiano" data-section="piano">
      <div class="cardHead">
        <div class="title">üéπ</div>
        <div class="title" id="pianoTop">‚Äî</div>
      </div>
      <div class="cardBody">
        <div class="legend">
          <span class="dotLegend"><span class="sw scale"></span>Scale tones</span>
          <span class="dotLegend"><span class="sw root"></span>Root</span>
          <span class="dotLegend"><span class="sw chord"></span>Chord tones</span>
        </div>
        <div class="pianoBox">
          <svg id="pianoSvg" viewBox="0 0 1000 240" preserveAspectRatio="none" aria-label="Piano keyboard"></svg>
        </div>
        <div class="hint" id="pianoHint">‚Äî</div>
      </div>
    </section>

    <!-- LEAD SHEET -->
    <section class="card" id="cardLead" data-section="lead">
      <div class="cardHead">
        <div class="row" style="gap:8px;align-items:center;">
          <div class="title">üéº</div>
          <button class="btn tiny" id="btnEdit" title="Edit chart">‚úèÔ∏è Edit</button>
        </div>
        <div class="title" id="leadKey">‚Äî</div>
      </div>
      <div class="cardBody">
        <div class="sheet" id="sheet"></div>
        <div class="msg" id="editHint" style="display:none;margin-top:10px;">
          Edit mode ON: tap a bar (or half) to change that chord. Use ‚ÄúClear‚Äù to remove it.
        </div>
      </div>
    </section>

    <!-- Controls -->
    <section class="card" id="cardControls" data-section="controls">
      <div class="cardHead">
        <div class="title">Controls</div>
        <div class="title">tap headers to open</div>
      </div>
      <div class="cardBody">

        <details class="group" id="grpGen">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Generate</div>
                <div class="sumSub">generator bias + scale drift</div>
              </div>
              <div class="row" style="gap:8px;">
                <button class="lockMini" id="lockProgMini" type="button" title="Lock progression so Generate/Random won't change it">üîì <b>Progression</b></button>
                <button class="btn tiny" id="btnRandGen" type="button" title="Randomize only generator controls (respects locks)">üé≤ Gen</button>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">
              <div class="control">
                <label>Progression logic</label>
                <select id="progressionLogic"></select>
                <div class="msg" style="margin:6px 0 0 0;">Biases decisions (not canned progressions).</div>
              </div>

              <div class="control">
                <label>Genre preset</label>
                <select id="genrePreset"></select>
              </div>

              <div class="control">
                <label>Scales used (1‚Äì32)</label>
                <div class="inline">
                  <input id="scalesUsed" type="range" min="1" max="32" value="8">
                  <input id="scalesUsedNum" type="number" min="1" max="32" value="8">
                </div>
                <div class="msg" style="margin:6px 0 0 0;">Caps how many distinct scales/modes are used across the chart.</div>
              </div>

            </div>
          </div>
        </details>

        <details class="group" id="grpTime">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Timing + Form</div>
                <div class="sumSub">bars, halves, tempo, swing</div>
              </div>
              <div class="row" style="gap:8px;">
                <button class="lockMini" id="lockTimeMini" type="button" title="Lock timing so Random won't change it">üîì <b>Timing</b></button>
                <button class="btn tiny" id="btnRandTime" type="button" title="Randomize timing/form only (respects locks)">üé≤ Time</button>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">

              <div class="control">
                <label>Bars (2‚Äì32)</label>
                <div class="inline">
                  <input id="bars" type="range" min="2" max="32" value="8">
                  <input id="barsNum" type="number" min="2" max="32" value="8">
                </div>
              </div>

              <div class="control">
                <label>2 chords / bar (random bars)</label>
                <div class="checkRow" style="margin-bottom:8px;">
                  <label class="chip" style="width:100%;justify-content:space-between;">
                    <span>Enable occasional ¬Ω-bars</span>
                    <input type="checkbox" id="halfChords">
                  </label>
                </div>
                <div class="inline">
                  <input id="halfDensity" type="range" min="0" max="100" value="22">
                  <input id="halfDensityNum" type="number" min="0" max="100" value="22">
                </div>
                <div class="msg" style="margin:6px 0 0 0;">Density %</div>
              </div>

              <div class="control">
                <label>Tempo</label>
                <div class="inline">
                  <input id="tempo" type="range" min="60" max="220" value="140">
                  <input id="tempoNum" type="number" min="40" max="300" value="140">
                </div>
              </div>

              <div class="control">
                <label>Swing</label>
                <div class="inline">
                  <input id="swing" type="range" min="50" max="75" value="58">
                  <input id="swingNum" type="number" min="50" max="80" value="58">
                </div>
              </div>

            </div>
          </div>
        </details>

        <details class="group" id="grpFeel">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Feel</div>
                <div class="sumSub">chaos, root mode, groove, comp</div>
              </div>
              <div class="row" style="gap:8px;">
                <button class="lockMini" id="lockStyleMini" type="button" title="Lock play style so Style/Random won't change it">üîì <b>Play style</b></button>
                <button class="btn tiny" id="btnRandFeel" type="button" title="Randomize feel (respects locks)">üé≤ Feel</button>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">

              <div class="control">
                <label>Chaos</label>
                <div class="inline">
                  <input id="chaos" type="range" min="0" max="100" value="35">
                  <input id="chaosNum" type="number" min="0" max="100" value="35">
                </div>
                <div class="msg" style="margin:6px 0 0 0;">More = weirder roots/qualities/tension + more drift.</div>
              </div>

              <div class="control">
                <label>Root mode</label>
                <select id="rootMode">
                  <option value="keyed" selected>Keyed</option>
                  <option value="drifting">Drifting</option>
                  <option value="orbiting">Orbiting</option>
                  <option value="freefall">Freefall</option>
                </select>
              </div>

              <div class="control">
                <label>Groove (drums)</label>
                <select id="grooveStyle"></select>
              </div>

              <div class="control">
                <label>Keys play style</label>
                <select id="compStyle"></select>
              </div>

            </div>
          </div>
        </details>

        <details class="group" id="grpSounds">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Sounds + Fill / Complexity</div>
                <div class="sumSub">instruments + ‚Äúless repeats‚Äù fills</div>
              </div>
              <div class="row" style="gap:8px;">
                <button class="lockMini" id="lockSoundMini" type="button" title="Lock sounds so Style/Random won't change them">üîì <b>Sounds</b></button>
                <button class="btn tiny" id="btnRandSounds" type="button" title="Randomize sounds/mix only (respects locks)">üé≤ Sounds</button>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">

              <div class="control">
                <label>Bass sound (minimal)</label>
                <select id="bassPreset">
                  <option value="upright" selected>Upright</option>
                  <option value="round">Round</option>
                  <option value="sub">Sub</option>
                  <option value="pluck">Pluck</option>
                  <option value="fmBass">FM bass</option>
                  <option value="rubber">Rubber</option>
                  <option value="acid">Acid</option>
                  <option value="reese">Reese</option>
                  <option value="squareBass">Square bass</option>
                  <option value="wobble">Wobble</option>
                  <option value="pickBass">Pick bass</option>
                  <option value="muted">Muted</option>
                </select>
              </div>

              <div class="control">
                <label>Keys sound (minimal)</label>
                <select id="keysPreset">
                  <option value="ep" selected>EP</option>
                  <option value="piano">Piano</option>
                  <option value="organ">Organ</option>
                  <option value="pad">Pad</option>
                  <option value="fm">FM keys</option>
                  <option value="chip">Chip</option>
                  <option value="bell">Bell</option>
                  <option value="glass">Glass</option>
                  <option value="pluck2">Pluck 2</option>
                  <option value="vibes">Vibes</option>
                  <option value="choirPad">Choir pad</option>
                  <option value="noisePad">Noise pad</option>
                  <option value="guitarish">Guitar-ish</option>
                  <option value="clavBright">Clav bright</option>
                </select>
              </div>

              <div class="control">
                <label>Drums sound (minimal)</label>
                <select id="drumsPreset">
                  <option value="jazz" selected>Jazz kit</option>
                  <option value="brushes">Brushes</option>
                  <option value="tight">Tight</option>
                  <option value="rock">Rock kit</option>
                  <option value="disco">Disco kit</option>
                  <option value="lofi">Lo-fi</option>
                  <option value="minimal">Minimal clicks</option>
                  <option value="electro">Electro</option>
                  <option value="house">House</option>
                  <option value="trap">Trap hats</option>
                  <option value="perc">Perc kit</option>
                  <option value="dnb">DnB kit</option>
                  <option value="techno">Techno kit</option>
                </select>
              </div>

              <div class="control">
                <label>Drums level</label>
                <div class="inline">
                  <input id="drumsLevel" type="range" min="0" max="100" value="55">
                  <input id="drumsLevelNum" type="number" min="0" max="100" value="55">
                </div>
              </div>

              <div class="control">
                <label>Keys: complexity / fills</label>
                <div class="inline" style="margin-bottom:8px;">
                  <input id="keysComplex" type="range" min="0" max="100" value="55">
                  <input id="keysComplexNum" type="number" min="0" max="100" value="55">
                </div>
                <div class="inline">
                  <input id="keysFill" type="range" min="0" max="100" value="30">
                  <input id="keysFillNum" type="number" min="0" max="100" value="30">
                </div>
              </div>

              <div class="control">
                <label>Bass: complexity / fills</label>
                <div class="inline" style="margin-bottom:8px;">
                  <input id="bassComplex" type="range" min="0" max="100" value="55">
                  <input id="bassComplexNum" type="number" min="0" max="100" value="55">
                </div>
                <div class="inline">
                  <input id="bassFill" type="range" min="0" max="100" value="25">
                  <input id="bassFillNum" type="number" min="0" max="100" value="25">
                </div>
              </div>

              <div class="control">
                <label>Drums: complexity / fills</label>
                <div class="inline" style="margin-bottom:8px;">
                  <input id="drumsComplex" type="range" min="0" max="100" value="65">
                  <input id="drumsComplexNum" type="number" min="0" max="100" value="65">
                </div>
                <div class="inline">
                  <input id="drumsFill" type="range" min="0" max="100" value="40">
                  <input id="drumsFillNum" type="number" min="0" max="100" value="40">
                </div>
              </div>

            </div>
          </div>
        </details>

      </div>
    </section>

    <!-- CHORD LIMITERS -->
    <section class="card" id="cardLimiters" data-section="limiters">
      <div class="cardHead">
        <div class="row" style="gap:8px;align-items:center;">
          <div class="title">Chord limiters</div>
          <button class="lockMini" id="lockLimitMini" type="button" title="Lock limiters so Random won't change them">üîì <b>Limiters</b></button>
          <button class="btn tiny" id="btnRandLimit" type="button" title="Randomize limiters only (respects locks)">üé≤ Limit</button>
        </div>
        <div class="title">tap headers to open</div>
      </div>
      <div class="cardBody">

        <details class="group" id="limQual">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Core qualities</div>
                <div class="sumSub">what chord families can appear</div>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="qMaj7" checked><span>maj7</span></label>
              <label class="chip"><input type="checkbox" id="qMin7" checked><span>m7</span></label>
              <label class="chip"><input type="checkbox" id="qDom7" checked><span>7</span></label>
              <label class="chip"><input type="checkbox" id="qDim7" checked><span>dim7</span></label>
              <label class="chip"><input type="checkbox" id="qHalfDim"><span>√∏7</span></label>
              <label class="chip"><input type="checkbox" id="qSus"><span>sus</span></label>
              <label class="chip"><input type="checkbox" id="qMinMaj"><span>mMaj7</span></label>
            </div>
          </div>
        </details>

        <details class="group" id="limExt">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Extensions</div>
                <div class="sumSub">9 / 11 / 13 / 6 etc</div>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="x9"><span>9</span></label>
              <label class="chip"><input type="checkbox" id="x11"><span>11</span></label>
              <label class="chip"><input type="checkbox" id="x13"><span>13</span></label>
              <label class="chip"><input type="checkbox" id="x6"><span>6 / 6-9</span></label>
              <label class="chip"><input type="checkbox" id="xAdd9"><span>add9</span></label>
              <label class="chip"><input type="checkbox" id="xSharp11"><span>#11</span></label>
              <label class="chip"><input type="checkbox" id="xMin11"><span>m11</span></label>
            </div>
          </div>
        </details>

        <details class="group" id="limTen">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Tension</div>
                <div class="sumSub">alt, slash, chromatic, b9/#9</div>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="tAlt"><span>alt dom</span></label>
              <label class="chip"><input type="checkbox" id="tSlash"><span>slash</span></label>
              <label class="chip"><input type="checkbox" id="tChrom"><span>chromatic</span></label>
              <label class="chip"><input type="checkbox" id="tB9"><span>‚ô≠9</span></label>
              <label class="chip"><input type="checkbox" id="tSharp9"><span>#9</span></label>
            </div>
          </div>
        </details>

        <div class="msg" style="margin-top:10px;"> </div>
      </div>
    </section>

  </div><!-- /app -->

  <!-- Advanced Settings Modal -->
  <div class="modalBack" id="advBack" role="dialog" aria-modal="true" aria-label="Advanced settings">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle">Advanced settings</div>
        <div class="reorderBtns">
          <button class="btn small" id="btnResetMenu" type="button">Reset</button>
          <button class="btn primary small" id="btnCloseAdv" type="button">Done</button>
        </div>
      </div>

      <div class="modalBody">
        <div class="msg" style="margin:0 0 10px 0;">
          Menu order (main sections). Visual + keyboard settings live here.
        </div>

        <div id="orderList"></div>

        <div class="splitLine"></div>

        <div class="modalSubTitle">Visuals</div>
        <div class="modalGrid">
          <div class="miniCtl">
            <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
              <span>Page theme</span>
              <button class="lockMini" id="lockThemeMini" type="button" title="Lock theme so Style/Random won't change it">üîì <b>Theme</b></button>
            </label>
            <select id="pageTheme"></select>
          </div>
          <div class="miniCtl">
            <label>Piano theme</label>
            <select id="pianoTheme"></select>
          </div>
          <div class="miniCtl">
            <label>Tone markers</label>
            <select id="markerStyle">
              <option value="dots" selected>Dots</option>
              <option value="rings">Rings</option>
              <option value="triangles">Triangles</option>
              <option value="squares">Squares</option>
            </select>
          </div>

          <div class="miniCtl">
            <label>Morphing gradient background</label>
            <label class="chip" style="width:100%;justify-content:space-between;margin:0;">
              <span>Enable morph</span>
              <input type="checkbox" id="morphBg" checked>
            </label>
          </div>

          <div class="miniCtl">
            <label>Keyboard length (octaves)</label>
            <div class="miniRow">
              <input id="kbOct" type="range" min="1" max="4" value="2">
              <input id="kbOctNum" type="number" min="1" max="4" value="2">
            </div>
            <div class="msg" style="margin:8px 0 0 0;">2 = default (14 white keys). 4 = wider view.</div>
          </div>
        </div>

        <div class="msg" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <!-- Edit Chord Modal -->
  <div class="editModalBack" id="editBack" role="dialog" aria-modal="true" aria-label="Edit chord">
    <div class="editModal">
      <div class="editHead">
        <div class="editTitle" id="editTitle">Edit chord</div>
        <div class="reorderBtns">
          <button class="btn small" id="btnEditClose" type="button">Done</button>
        </div>
      </div>
      <div class="editBody">
        <div class="editGrid">
          <div class="miniCtl">
            <label>Root</label>
            <select id="editRoot"></select>
          </div>
          <div class="miniCtl">
            <label>Quality</label>
            <select id="editQual"></select>
          </div>
          <div class="miniCtl">
            <label>Slash (optional)</label>
            <select id="editSlash"></select>
            <div class="msg" style="margin:8px 0 0 0;">Set ‚Äú(none)‚Äù for no slash bass.</div>
          </div>
          <div class="miniCtl">
            <label>Placement</label>
            <select id="editPlace">
              <option value="whole">Whole bar</option>
              <option value="half1">Half (top)</option>
              <option value="half2">Half (bottom)</option>
            </select>
            <div class="msg" style="margin:8px 0 0 0;">Choosing a half will split the bar into 2 halves.</div>
          </div>
        </div>

        <div class="editActions">
          <button class="btn primary" id="btnEditApply" type="button">‚úÖ Apply</button>
          <button class="btn" id="btnEditClear" type="button">üßπ Clear</button>
          <button class="btn ghost" id="btnEditCancel" type="button">‚úñÔ∏è Cancel</button>
        </div>

        <div class="editNote" id="editNote"> </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  /* ---------- Core helpers ---------- */
  const NOTE_NAMES = ["C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"];
  const pc = (n)=>((n%12)+12)%12;
  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const rint = (a,b)=>Math.floor(a + Math.random()*(b-a+1));
  const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
  const chance = (p)=>Math.random()<p;
  const noteName = (p)=>NOTE_NAMES[pc(p)];

  function weightedPick(opts){
    const sum = opts.reduce((s,o)=>s+o.w,0);
    let t = Math.random()*sum;
    for (const o of opts){ t -= o.w; if (t<=0) return o.v; }
    return opts[opts.length-1].v;
  }

  function safeJSONParse(s, fallback=null){
    try{ return JSON.parse(s); }catch{ return fallback; }
  }

  /* ---------- Scales / chords ---------- */
  const SCALES = {
    ionian:[0,2,4,5,7,9,11],
    dorian:[0,2,3,5,7,9,10],
    phryg:[0,1,3,5,7,8,10],
    lydian:[0,2,4,6,7,9,11],
    mixo:  [0,2,4,5,7,9,10],
    mixolydian:[0,2,4,5,7,9,10],
    aeolian:[0,2,3,5,7,8,10],
    locrian:[0,1,3,5,6,8,10],
    melodicMinor:[0,2,3,5,7,9,11],
    lydianDom:[0,2,4,6,7,9,10],
    altered:[0,1,3,4,6,8,10],
  };

  const CHORDS = {
    maj7:[0,4,7,11],
    maj9:[0,4,7,11,14],
    maj6:[0,4,7,9],
    "6/9":[0,4,7,9,14],
    add9:[0,4,7,14],
    maj9sharp11:[0,4,7,11,14,18],

    min7:[0,3,7,10],
    min9:[0,3,7,10,14],
    min6:[0,3,7,9],
    min11:[0,3,7,10,14,17],

    minMaj7:[0,3,7,11],
    minMaj9:[0,3,7,11,14],

    dom7:[0,4,7,10],
    dom9:[0,4,7,10,14],
    dom11:[0,4,7,10,14,17],
    dom13:[0,4,7,10,14,21],
    dom7b9:[0,4,7,10,13],
    dom7sharp9:[0,4,7,10,15],

    sus:[0,5,7,10],
    "7sus":[0,5,7,10,14],

    halfdim:[0,3,6,10],
    dim7:[0,3,6,9],
  };

  function chordIntervals(ch){
    if (Array.isArray(ch?.intervals) && ch.intervals.length) return ch.intervals;
    const key = ch?.key;
    if (key && CHORDS[key]) return CHORDS[key];
    const sym = ch?.symbol;
    const bySymbol = {
      "maj7":"maj7", "maj9":"maj9", "6/9":"6/9", "6":"maj6", "add9":"add9", "maj9(#11)":"maj9sharp11",
      "m7":"min7", "m9":"min9", "m6":"min6", "m11":"min11", "mMaj7":"minMaj7", "mMaj9":"minMaj9",
      "7":"dom7", "9":"dom9", "11":"dom11", "13":"dom13", "7(b9)":"dom7b9", "7(#9)":"dom7sharp9",
      "sus":"sus", "7sus":"7sus",
      "√∏7":"halfdim", "dim7":"dim7"
    }[sym];
    if (bySymbol && CHORDS[bySymbol]) return CHORDS[bySymbol];
    const fam = ch?.family;
    if (fam==="maj") return CHORDS.maj7;
    if (fam==="min") return CHORDS.min7;
    if (fam==="dom") return CHORDS.dom7;
    if (fam==="hdim") return CHORDS.halfdim;
    if (fam==="dim") return CHORDS.dim7;
    if (fam==="sus") return CHORDS.sus;
    return CHORDS.dom7;
  }

  function chordName(ch){
    const base = `${noteName(ch.root)}${ch.symbol}`;
    return (ch.slash!=null) ? `${base}/${noteName(ch.slash)}` : base;
  }
  function chordTonesPCs(ch){
    return [...new Set(chordIntervals(ch).map(i=>pc(ch.root+i)))];
  }

  /* ---------- Chord-local scale selection (context-aware) ---------- */
  function candidatesForChord(ch){
    const pcs = chordTonesPCs(ch);
    const hasSharp11 = pcs.includes(pc(ch.root + 6)) || (ch.symbol||"").includes("#11");
    if (ch.family === "maj") return hasSharp11 ? ["lydian","ionian"] : ["ionian","lydian"];
    if (ch.family === "min") return ["dorian","aeolian","phryg"];
    if (ch.family === "minmaj") return ["melodicMinor","dorian","aeolian"];
    if (ch.family === "dom"){
      const hasSharp11Dom = pcs.includes(pc(ch.root+6));
      return hasSharp11Dom ? ["lydianDom","mixo","altered"] : ["mixo","lydianDom","altered"];
    }
    if (ch.family === "sus") return ["mixo","dorian"];
    if (ch.family === "hdim" || ch.family === "dim") return ["locrian"];
    return ["mixo"];
  }

  function scoreModeForContext(ch, mode, prevCh, nextCh, scaleRootOverride=null){
    const scaleRoot = (scaleRootOverride!=null) ? pc(scaleRootOverride) : ((ch && typeof ch.scaleRoot==="number") ? ch.scaleRoot : ch.root);
    const scale = SCALES[mode] || SCALES.mixo;
    const scalePC = new Set(scale.map(i=>pc(scaleRoot+i)));
    const ctxPCs = [];
    if (prevCh) ctxPCs.push(...chordTonesPCs(prevCh));
    if (nextCh) ctxPCs.push(...chordTonesPCs(nextCh));
    if (prevCh && prevCh.slash!=null) ctxPCs.push(pc(prevCh.slash));
    if (nextCh && nextCh.slash!=null) ctxPCs.push(pc(nextCh.slash));

    let score = 0;
    for (const p of ctxPCs) if (scalePC.has(p)) score += 2;

    if (mode==="ionian") score += 1.2;
    if (mode==="dorian") score += 1.1;
    if (mode==="mixo") score += 1.0;
    if (mode==="lydian") score += 0.6;
    if (mode==="aeolian") score += 0.6;
    if (mode==="phryg") score += 0.2;
    if (mode==="altered") score += 0.2;
    if (mode==="lydianDom") score += 0.4;
    if (mode==="melodicMinor") score += 0.8;

    const chordPCs = chordTonesPCs(ch);
    if (chordPCs.includes(pc(ch.root+6))){
      if (mode==="lydian" || mode==="lydianDom") score += 2.5;
      if (mode==="ionian" || mode==="mixo") score -= 0.5;
    }
    return score;
  }

  function chooseChordLocalMode(ch, prevCh, nextCh){
    const cand = candidatesForChord(ch);
    let best = cand[0], bestScore = -1e9;
    for (const m of cand){
      const s = scoreModeForContext(ch, m, prevCh, nextCh);
      if (s > bestScore){ bestScore = s; best = m; }
    }
    return best;
  }

  function scalePCsForChordLocal(ch, prevCh, nextCh){
    const mode = ch?.mode || chooseChordLocalMode(ch, prevCh, nextCh);
    const scaleRoot = (ch && typeof ch.scaleRoot==="number") ? ch.scaleRoot : ch.root;
    const base = SCALES[mode] || SCALES.mixo;
    const pcsSet = new Set();
    const baseSet = new Set();
    base.forEach(i => {
      const p = pc(scaleRoot + i);
      pcsSet.add(p);
      baseSet.add(p);
    });
    chordTonesPCs(ch).forEach(p=>{
      const pp = pc(p);
      if (baseSet.has(pp)) pcsSet.add(pp);
    });
    if (ch.slash!=null){
      const s = pc(ch.slash);
      if (baseSet.has(s)) pcsSet.add(s);
    }
    return { pcs:[...pcsSet], mode };
  }

  /* ---------- Limit how many distinct scales are used ---------- */
  function candidateModesWithLimit(ch, limit){
    const base = candidatesForChord(ch);
    if (limit<=2){
      if (ch.family==="dom") return ["mixo"];
      if (ch.family==="maj") return ["ionian"];
      if (ch.family==="min") return ["dorian","aeolian"];
      if (ch.family==="sus") return ["mixo"];
      if (ch.family==="minmaj") return ["melodicMinor","dorian"];
    }
    return base;
  }

  function assignChordModesWithLimit(chartBars){
    if (!Array.isArray(chartBars) || !chartBars.length) return;

    const slots = [];
    for (let b=0;b<chartBars.length;b++){
      const bar = chartBars[b];
      const chords = bar?.chords || [];
      for (let h=0;h<chords.length;h++){
        const chord = chords[h];
        if (!chord) continue;
        slots.push({ barIndex:b, halfIndex:h, chord });
      }
    }
    if (!slots.length) return;

    const limit = clamp(Number(state.scalesUsed)||1, 1, Math.max(1, Object.keys(SCALES).length));

    // Single-scale hard clamp: force all chords to key root/mode
    if (limit===1 && SCALES[state.keyMode]){
      const rootPc = pc(state.keyRoot);
      for (const slot of slots){
        slot.chord.mode = state.keyMode;
        slot.chord.scaleRoot = rootPc;
      }
      return;
    }

    const pcsFor = (center, mode)=>{
      const base = SCALES[mode] || SCALES.mixo;
      return new Set(base.map(i=>pc(center + i)));
    };
    const chordFits = (ch, center, mode)=>{
      const set = pcsFor(center, mode);
      for (const p of chordTonesPCs(ch)) if (!set.has(pc(p))) return false;
      if (ch.slash!=null && !set.has(pc(ch.slash))) return false;
      return true;
    };

    const candidateCentersForMode = (ch, mode)=>{
      const intervals = SCALES[mode] || SCALES.mixo;
      const centers = [];
      const seen = new Set();
      for (const iv of intervals){
        const center = pc(ch.root - iv);
        if (seen.has(center)) continue;
        seen.add(center);
        if (chordFits(ch, center, mode)) centers.push(center);
      }
      return centers;
    };

    const sigFor = (rootPc, mode)=>{
      const base = SCALES[mode] || SCALES.mixo;
      const pcs = base.map(i=>pc(rootPc + i)).sort((a,b)=>a-b);
      return pcs.join(",");
    };

    // collect candidate modes per chord (root fixed to chord root)
    const sigTotals = new Map();
    const sigMeta = new Map(); // sig -> {root, mode}
    const candPer = slots.map((slot, idx)=>{
      const prev = slots[idx-1]?.chord || null;
      const next = slots[idx+1]?.chord || null;
      const chord = slot.chord;
      const cand = [];
      const modes = candidateModesWithLimit(chord, limit);
      modes.forEach(mode=>{
        const centers = candidateCentersForMode(chord, mode);
        centers.forEach(center=>{
          const score = scoreModeForContext(chord, mode, prev, next, center);
          const sig = sigFor(center, mode);
          sigTotals.set(sig, (sigTotals.get(sig)||0) + score);
          if (!sigMeta.has(sig)) sigMeta.set(sig, {root:center, mode});
          cand.push({mode, score, center, sig});
        });
      });
      if (!cand.length){
        const fallbackMode = modes[0] || "mixo";
        const center = pc(chord.root);
        const sig = sigFor(center, fallbackMode);
        if (!sigMeta.has(sig)) sigMeta.set(sig, {root:center, mode:fallbackMode});
        cand.push({mode:fallbackMode, score:scoreModeForContext(chord, fallbackMode, prev, next, center), center, sig});
      }
      return cand;
    });

    // Exact cover (limit=2): pick signatures that cover all chords with best total score
    const sigArr = [...sigTotals.keys()];
    let palette = [];
    if (limit === 2 && sigArr.length){
      let bestScore = -Infinity;
      let bestPair = null;
      for (let a=0;a<sigArr.length;a++){
        for (let b=a;b<sigArr.length;b++){
          const pair = [sigArr[a], sigArr[b]];
          let ok = true;
          let total = 0;
          for (let i=0;i<candPer.length;i++){
            const cand = candPer[i].filter(c=>pair.includes(c.sig) && chordFits(slots[i].chord, c.center, c.mode));
            if (!cand.length){ ok = false; break; }
            const best = cand.reduce((m,c)=> c.score>m?c.score:m, -Infinity);
            total += best;
          }
          if (ok && total > bestScore){
            bestScore = total;
            bestPair = pair;
          }
        }
      }
      if (bestPair) palette = bestPair;
    }

    // Greedy cover: pick signatures that cover as many chords as possible up to limit
    const allSigs = new Set(sigArr);
    const covered = new Array(slots.length).fill(false);
    if (!palette.length){
      palette = [];
    }

    function chordHasSig(idx, sig){
      const cand = candPer[idx];
      return cand.some(c=>c.sig===sig && chordFits(slots[idx].chord, c.center, c.mode));
    }

    while (palette.length < limit && allSigs.size){
      let bestSig = null, bestGain = -Infinity;
      for (const sig of allSigs){
        let gain = 0;
        for (let i=0;i<slots.length;i++){
          if (covered[i]) continue;
          const cand = candPer[i].filter(c=>c.sig===sig && chordFits(slots[i].chord, c.center, c.mode));
          if (cand.length){
            // use best score for this chord under this sig
            const s = cand.reduce((m,c)=> c.score>m?c.score:m, -Infinity);
            gain += s;
          }
        }
        if (gain > bestGain){
          bestGain = gain;
          bestSig = sig;
        }
      }
      if (bestSig==null || bestGain===-Infinity) break;
      palette.push(bestSig);
      allSigs.delete(bestSig);
      for (let i=0;i<slots.length;i++){
        if (covered[i]) continue;
        if (chordHasSig(i, bestSig)) covered[i] = true;
      }
    }

    if (!palette.length && candPer.length){
      const fallbackSig = candPer[0][0]?.sig || "";
      palette.push(fallbackSig);
      if (!sigMeta.has(fallbackSig)) sigMeta.set(fallbackSig, {root: pc(slots[0].chord.root), mode:"mixo"});
    }
    const paletteSet = new Set(palette);

    function nearestScaleTone(rootPc, scaleSet){
      let best = rootPc;
      let bestDist = 99;
      for (const p of scaleSet){
        const d = Math.min((p - rootPc + 12) % 12, (rootPc - p + 12) % 12);
        if (d < bestDist){
          bestDist = d;
          best = p;
        }
      }
      return best;
    }

    function retuneChordToScale(slot, scaleRoot, mode){
      const scaleSet = pcsFor(scaleRoot, mode);
      const limiters = state.limiter || DEFAULTS.limiter;
      const weights = state.weights || macroToWeights(state.chaos);
      const baseOpts = buildQualityOptions(limiters);
      const scaleTones = [...scaleSet];

      let rootPc = pc(slot.chord.root);
      if (!scaleSet.has(rootPc)) rootPc = nearestScaleTone(rootPc, scaleSet);

      // If current root can't support any in-scale quality, find a nearby scale root that can.
      const hasFitAt = (r)=>baseOpts.some(o=>{
        const tones = (CHORDS[o.v.symbol] || []).map(iv=>pc(r + iv));
        return tones.every(p=>scaleSet.has(p));
      });
      if (!hasFitAt(rootPc)){
        let best = rootPc;
        let bestDist = 99;
        for (const t of scaleTones){
          if (!hasFitAt(t)) continue;
          const d = Math.min((t - rootPc + 12) % 12, (rootPc - t + 12) % 12);
          if (d < bestDist){ bestDist = d; best = t; }
        }
        rootPc = best;
      }
      const q = chooseQuality(limiters, weights, scaleSet, rootPc);
      const replacement = makeChord(rootPc, q);
      replacement.mode = mode;
      replacement.scaleRoot = pc(scaleRoot);
      if (slot.chord.slash!=null && scaleSet.has(pc(slot.chord.slash))) replacement.slash = pc(slot.chord.slash);
      Object.assign(slot.chord, replacement);
    }

    for (let i=0;i<slots.length;i++){
      const chord = slots[i].chord;
      const cand = candPer[i];
      let chosen = null;
      let best = -1e9;

      // best candidate within palette (same signature) that fits
      for (const c of cand){
        if (!paletteSet.has(c.sig)) continue;
        if (!chordFits(chord, c.center, c.mode)) continue;
        if (c.score>best){
          best = c.score;
          chosen = c;
        }
      }

      if (!chosen){
        // best palette meta that fits
        for (const sig of palette){
          const meta = sigMeta.get(sig);
          if (!meta) continue;
          if (!chordFits(chord, meta.root, meta.mode)) continue;
          const s = scoreModeForContext(chord, meta.mode, null, null, meta.root);
          if (s > best){
            best = s;
            chosen = {mode:meta.mode, score:s, center:meta.root, sig};
          }
        }
      }

      if (!chosen){
        const fallbackSig = palette[0] || cand[0]?.sig || sigFor(pc(chord.root), "mixo");
        const meta = sigMeta.get(fallbackSig) || {root: pc(chord.root), mode:"mixo"};
        retuneChordToScale(slots[i], meta.root, meta.mode);
        continue;
      }

      slots[i].chord.mode = chosen.mode || "mixo";
      const centerRoot = (chosen && typeof chosen.center==="number") ? chosen.center : pc(chord.root);
      slots[i].chord.scaleRoot = pc(centerRoot);
    }

    // Hard cap: if any extra signatures slipped through, remap them into the top `limit`
    const usedCounts = new Map();
    slots.forEach(slot=>{
      const sig = sigFor(pc(slot.chord.scaleRoot ?? slot.chord.root), slot.chord.mode || "mixo");
      usedCounts.set(sig, (usedCounts.get(sig)||0)+1);
      if (!sigMeta.has(sig)) sigMeta.set(sig, {root: pc(slot.chord.scaleRoot ?? slot.chord.root), mode: slot.chord.mode||"mixo"});
    });

    if (usedCounts.size > limit){
      const keep = [...usedCounts.entries()].sort((a,b)=>b[1]-a[1]).slice(0, limit).map(([sig])=>sig);
      const keepSet = new Set(keep);
      slots.forEach(slot=>{
        const currentSig = sigFor(pc(slot.chord.scaleRoot ?? slot.chord.root), slot.chord.mode || "mixo");
        if (keepSet.has(currentSig)) return;

        let reassigned = false;
        for (const sig of keep){
          const meta = sigMeta.get(sig);
          if (meta && chordFits(slot.chord, meta.root, meta.mode)){
            slot.chord.mode = meta.mode;
            slot.chord.scaleRoot = meta.root;
            reassigned = true;
            break;
          }
        }

        if (!reassigned){
          const fallbackSig = keep[0];
          const meta = sigMeta.get(fallbackSig) || {root: pc(slot.chord.root), mode:"mixo"};
          retuneChordToScale(slot, meta.root, meta.mode);
        }
      });
    }
  }

  /* ---------- Defaults / State ---------- */
  const DEFAULTS = {
    bars: 4,
    halfEnabled: false,
    halfDensity: 22,
    tempo: 140,
    swing: 58,
    chaos: 35,
    rootMode: "keyed",
    progressionLogic: "jazzFunctional",
    genrePreset: "modernJazz",
    grooveStyle: "swing",
    compStyle: "twoStabs",
    bassPreset: "upright",
    keysPreset: "ep",
    drumsPreset: "jazz",
    drumsLevel: 55,
    keysComplex: 55,
    keysFill: 30,
    bassComplex: 55,
    bassFill: 25,
    drumsComplex: 65,
    drumsFill: 40,
    scalesUsed: 2,
    limiter: {
      qMaj7:true, qMin7:true, qDom7:true, qDim7:false,
      qHalfDim:true, qSus:false, qMinMaj:false,
      x9:false, x11:false, x13:false, x6:false, xAdd9:false, xSharp11:false, xMin11:false,
      tAlt:false, tSlash:false, tChrom:false, tB9:false, tSharp9:false,
    },
    pageTheme: "terminal",
    pianoTheme: "classic",
    markerStyle: "dots",
    morphBg: true,
    kbOct: 2, /* 2 octaves = 14 white keys (default) */
  };

  const state = {
    chartBars: [],
    showKey: true,
    keyRoot: 0,
    keyMode: "ionian",
    activeBar: 0,
    activeHalf: 0,

    bars: DEFAULTS.bars,
    halfEnabled: DEFAULTS.halfEnabled,
    halfDensity: DEFAULTS.halfDensity,
    tempo: DEFAULTS.tempo,
    swing: DEFAULTS.swing,
    chaos: DEFAULTS.chaos,
    rootMode: DEFAULTS.rootMode,
    progressionLogic: DEFAULTS.progressionLogic,
    genrePreset: DEFAULTS.genrePreset,
    grooveStyle: DEFAULTS.grooveStyle,
    compStyle: DEFAULTS.compStyle,
    bassPreset: DEFAULTS.bassPreset,
    keysPreset: DEFAULTS.keysPreset,
    drumsPreset: DEFAULTS.drumsPreset,
    drumsLevel: DEFAULTS.drumsLevel,
    keysComplex: DEFAULTS.keysComplex,
    keysFill: DEFAULTS.keysFill,
    bassComplex: DEFAULTS.bassComplex,
    bassFill: DEFAULTS.bassFill,
    drumsComplex: DEFAULTS.drumsComplex,
    drumsFill: DEFAULTS.drumsFill,
    scalesUsed: DEFAULTS.scalesUsed,
    limiter: {...DEFAULTS.limiter},

    pageTheme: DEFAULTS.pageTheme,
    pianoTheme: DEFAULTS.pianoTheme,
    markerStyle: DEFAULTS.markerStyle,
    morphBg: DEFAULTS.morphBg,
    kbOct: DEFAULTS.kbOct,
    allowedCenters: [],

    weights: null,

    lockProg: false,
    lockStyle: false,
    lockTheme: false,
    lockTime: false,
    lockSounds: false,
    lockLimiters: false,

    editMode: false,
  };

  /* ---------- UI refs ---------- */
  const E = window.els = {
    msg: document.getElementById("msg"),
    pillLine: document.getElementById("pillLine"),
    focusLine: document.getElementById("focusLine"),

    btnPlay: document.getElementById("btnPlay"),
    btnGenerate: document.getElementById("btnGenerate"),
    btnRandomAll: document.getElementById("btnRandomAll"),
    btnStyleRand: document.getElementById("btnStyleRand"),
    btnUndo: document.getElementById("btnUndo"),
    btnRedo: document.getElementById("btnRedo"),
    btnCopy: document.getElementById("btnCopy"),
    btnDefaults: document.getElementById("btnDefaults"),

    btnEdit: document.getElementById("btnEdit"),
    editHint: document.getElementById("editHint"),

    btnRandGen: document.getElementById("btnRandGen"),
    btnRandTime: document.getElementById("btnRandTime"),
    btnRandFeel: document.getElementById("btnRandFeel"),
    btnRandSounds: document.getElementById("btnRandSounds"),
    btnRandLimit: document.getElementById("btnRandLimit"),

    lockProgMini: document.getElementById("lockProgMini"),
    lockStyleMini: document.getElementById("lockStyleMini"),
    lockThemeMini: document.getElementById("lockThemeMini"),
    lockTimeMini: document.getElementById("lockTimeMini"),
    lockSoundMini: document.getElementById("lockSoundMini"),
    lockLimitMini: document.getElementById("lockLimitMini"),

    sheet: document.getElementById("sheet"),
    leadKey: document.getElementById("leadKey"),

    pianoSvg: document.getElementById("pianoSvg"),
    pianoTop: document.getElementById("pianoTop"),
    pianoHint: document.getElementById("pianoHint"),
    markerStyle: document.getElementById("markerStyle"),

    progressionLogic: document.getElementById("progressionLogic"),
    genrePreset: document.getElementById("genrePreset"),

    bars: document.getElementById("bars"),
    barsNum: document.getElementById("barsNum"),
    halfChords: document.getElementById("halfChords"),
    halfDensity: document.getElementById("halfDensity"),
    halfDensityNum: document.getElementById("halfDensityNum"),
    tempo: document.getElementById("tempo"),
    tempoNum: document.getElementById("tempoNum"),
    swing: document.getElementById("swing"),
    swingNum: document.getElementById("swingNum"),
    chaos: document.getElementById("chaos"),
    chaosNum: document.getElementById("chaosNum"),
    rootMode: document.getElementById("rootMode"),
    grooveStyle: document.getElementById("grooveStyle"),
    compStyle: document.getElementById("compStyle"),

    scalesUsed: document.getElementById("scalesUsed"),
    scalesUsedNum: document.getElementById("scalesUsedNum"),

    bassPreset: document.getElementById("bassPreset"),
    keysPreset: document.getElementById("keysPreset"),
    drumsPreset: document.getElementById("drumsPreset"),
    drumsLevel: document.getElementById("drumsLevel"),
    drumsLevelNum: document.getElementById("drumsLevelNum"),

    keysComplex: document.getElementById("keysComplex"),
    keysComplexNum: document.getElementById("keysComplexNum"),
    keysFill: document.getElementById("keysFill"),
    keysFillNum: document.getElementById("keysFillNum"),

    bassComplex: document.getElementById("bassComplex"),
    bassComplexNum: document.getElementById("bassComplexNum"),
    bassFill: document.getElementById("bassFill"),
    bassFillNum: document.getElementById("bassFillNum"),

    drumsComplex: document.getElementById("drumsComplex"),
    drumsComplexNum: document.getElementById("drumsComplexNum"),
    drumsFill: document.getElementById("drumsFill"),
    drumsFillNum: document.getElementById("drumsFillNum"),

    pageTheme: document.getElementById("pageTheme"),
    pianoTheme: document.getElementById("pianoTheme"),

    advBack: document.getElementById("advBack"),
    btnGear: document.getElementById("btnGear"),
    btnCloseAdv: document.getElementById("btnCloseAdv"),
    btnResetMenu: document.getElementById("btnResetMenu"),
    orderList: document.getElementById("orderList"),

    morphBg: document.getElementById("morphBg"),
    kbOct: document.getElementById("kbOct"),
    kbOctNum: document.getElementById("kbOctNum"),

    // edit modal
    editBack: document.getElementById("editBack"),
    editTitle: document.getElementById("editTitle"),
    btnEditClose: document.getElementById("btnEditClose"),
    btnEditApply: document.getElementById("btnEditApply"),
    btnEditClear: document.getElementById("btnEditClear"),
    btnEditCancel: document.getElementById("btnEditCancel"),
    editRoot: document.getElementById("editRoot"),
    editQual: document.getElementById("editQual"),
    editSlash: document.getElementById("editSlash"),
    editPlace: document.getElementById("editPlace"),
  };

  /* ---------- Old-ish feel dropdowns: restore/expand grooves + comp styles ---------- */
  const GROOVES = [
    {id:"swing", name:"Swing ride"},
    {id:"brushBallad", name:"Brush ballad"},
    {id:"bossa", name:"Bossa"},
    {id:"samba", name:"Samba"},
    {id:"afroCuban", name:"Afro-Cuban"},
    {id:"funk", name:"Funk"},
    {id:"disco", name:"Disco"},
    {id:"rock", name:"Rock"},
    {id:"shuffle", name:"Shuffle"},
    {id:"hiphop", name:"Hip-hop"},
    {id:"house", name:"House"},
    {id:"techno", name:"Techno"},
    {id:"dnb", name:"DnB"},
    {id:"breaks", name:"Breakbeat"},
    {id:"ambient", name:"Ambient ticks"},
    {id:"free", name:"Free cymbals"},
  ];

  const COMP_STYLES = [
    {id:"twoStabs", name:"2 stabs"},
    {id:"fourComp", name:"4-to-the-bar"},
    {id:"charleston", name:"Charleston"},
    {id:"anticipations", name:"Anticipations"},
    {id:"pushPull", name:"Push / pull"},
    {id:"sparse", name:"Sparse sync"},
    {id:"arpeggio", name:"Arp flutter"},
    {id:"sustain", name:"Sustain pad"},
    {id:"montuno", name:"Montuno (latin)"},
    {id:"clav", name:"Clav comp (funk)"},
    {id:"rockChugs", name:"Rock chugs"},
    {id:"discoChop", name:"Disco chop"},
    {id:"neoSoulPush", name:"Neo-soul pushes"},
    {id:"edmStab", name:"EDM stabs"},
  ];

  function initFeelDropdowns(){
    E.grooveStyle.innerHTML = "";
    GROOVES.forEach(g=>{
      const o=document.createElement("option");
      o.value=g.id; o.textContent=g.name;
      E.grooveStyle.appendChild(o);
    });
    E.compStyle.innerHTML = "";
    COMP_STYLES.forEach(s=>{
      const o=document.createElement("option");
      o.value=s.id; o.textContent=s.name;
      E.compStyle.appendChild(o);
    });
  }

  const GENRE_BASE = {
    tempo:[120,180], swing:[55,60], groove:"swing", comp:"twoStabs",
    bass:"upright", keys:"piano", drums:"jazz",
    kC:60,kF:30,bC:60,bF:20,dC:70,dF:40, halfOn:true, halfDen:[18,38],
    logic:"jazzFunctional"
  };
  const GP = (cfg)=>({...GENRE_BASE, ...cfg});

  /* ---------- Genre Presets (expanded + old-ish coverage) ---------- */
  const GENRE_PRESETS = {
    modernJazz: { name:"Modern jazz", tempo:[120,190], swing:[56,62], groove:"swing", comp:"twoStabs", bass:"upright", keys:"ep", drums:"jazz",
      kC:60,kF:30,bC:60,bF:22,dC:70,dF:40, halfOn:true, halfDen:[18,38], logic:"jazzFunctional" },
    bebop: { name:"Bebop", tempo:[160,240], swing:[58,64], groove:"swing", comp:"charleston", bass:"upright", keys:"piano", drums:"jazz",
      kC:75,kF:40,bC:72,bF:20,dC:78,dF:40, halfOn:true, halfDen:[22,45], logic:"jazzFunctional" },
    jazzBallad: { name:"Jazz ballad", tempo:[60,110], swing:[54,58], groove:"brushBallad", comp:"sustain", bass:"upright", keys:"ep", drums:"brushes",
      kC:35,kF:20,bC:30,bF:12,dC:45,dF:20, halfOn:false, halfDen:[0,10], logic:"jazzModal" },
    hardBop: { name:"Hard bop", tempo:[130,210], swing:[57,63], groove:"swing", comp:"pushPull", bass:"upright", keys:"piano", drums:"jazz",
      kC:70,kF:35,bC:70,bF:22,dC:78,dF:45, halfOn:true, halfDen:[18,44], logic:"jazzFunctional" },
    bossa: { name:"Bossa", tempo:[120,180], swing:[50,52], groove:"bossa", comp:"montuno", bass:"round", keys:"ep", drums:"perc",
      kC:55,kF:28,bC:55,bF:18,dC:60,dF:35, halfOn:true, halfDen:[14,32], logic:"latinTurns" },
    afroCuban: { name:"Afro-Cuban", tempo:[110,175], swing:[50,54], groove:"afroCuban", comp:"montuno", bass:"round", keys:"organ", drums:"perc",
      kC:60,kF:35,bC:65,bF:22,dC:65,dF:38, halfOn:true, halfDen:[18,40], logic:"latinTurns" },
    funk: { name:"Funk", tempo:[85,115], swing:[50,56], groove:"funk", comp:"clav", bass:"round", keys:"clavBright", drums:"tight",
      kC:70,kF:50,bC:70,bF:35,dC:72,dF:50, halfOn:true, halfDen:[18,44], logic:"neoSoulLogic" },
    neoSoul: { name:"Neo-soul", tempo:[70,110], swing:[50,56], groove:"hiphop", comp:"neoSoulPush", bass:"round", keys:"ep", drums:"lofi",
      kC:68,kF:55,bC:60,bF:35,dC:55,dF:45, halfOn:true, halfDen:[28,55], logic:"neoSoulLogic" },
    disco: { name:"Disco", tempo:[115,132], swing:[50,52], groove:"disco", comp:"discoChop", bass:"pickBass", keys:"clavBright", drums:"disco",
      kC:55,kF:35,bC:55,bF:25,dC:70,dF:40, halfOn:false, halfDen:[0,18], logic:"discoLogic" },
    rock: { name:"Rock", tempo:[90,160], swing:[50,52], groove:"rock", comp:"rockChugs", bass:"pickBass", keys:"organ", drums:"rock",
      kC:55,kF:20,bC:55,bF:10,dC:65,dF:25, halfOn:false, halfDen:[0,12], logic:"rockLogic" },
    ambient: { name:"Ambient", tempo:[55,90], swing:[50,52], groove:"ambient", comp:"sustain", bass:"sub", keys:"pad", drums:"minimal",
      kC:22,kF:20,bC:18,bF:10,dC:18,dF:18, halfOn:false, halfDen:[0,10], logic:"jazzModal" },
    dnb: { name:"DnB", tempo:[160,182], swing:[50,54], groove:"dnb", comp:"edmStab", bass:"reese", keys:"pad", drums:"dnb",
      kC:55,kF:35,bC:65,bF:30,dC:85,dF:55, halfOn:false, halfDen:[0,18], logic:"edmLogic" },
    edm: { name:"EDM", tempo:[118,150], swing:[50,52], groove:"house", comp:"edmStab", bass:"sub", keys:"pad", drums:"house",
      kC:45,kF:25,bC:55,bF:20,dC:80,dF:45, halfOn:false, halfDen:[0,14], logic:"edmLogic" },
    newOrleans: GP({ name:"New Orleans trad", tempo:[95,140], swing:[56,62], comp:"twoStabs", bass:"upright", keys:"piano", drums:"jazz",
      kC:55,kF:22,bC:55,bF:18,dC:68,dF:32, halfDen:[10,26], logic:"tradSwing" }),
    chicagoStyle: GP({ name:"Chicago style", tempo:[105,150], swing:[56,62], comp:"twoStabs", bass:"upright", keys:"piano", drums:"jazz",
      kC:58,kF:24,bC:58,bF:18,dC:70,dF:35, halfDen:[12,28], logic:"tradSwing" }),
    kcSwing: GP({ name:"Kansas City swing", tempo:[115,175], swing:[57,63], comp:"pushPull", bass:"upright", keys:"piano", drums:"jazz",
      kC:62,kF:32,bC:62,bF:24,dC:72,dF:40, halfDen:[16,32], logic:"tradSwing" }),
    swingBigBand: GP({ name:"Swing era big band", tempo:[110,180], swing:[57,63], comp:"fourComp", bass:"upright", keys:"piano", drums:"jazz",
      kC:60,kF:30,bC:60,bF:24,dC:75,dF:45, halfDen:[16,34], logic:"tradSwing" }),
    gypsyJazz: GP({ name:"Gypsy jazz / manouche", tempo:[180,240], swing:[58,64], comp:"fourComp", bass:"upright", keys:"guitarish", drums:"jazz",
      kC:68,kF:32,bC:62,bF:24,dC:74,dF:35, halfOn:false, halfDen:[0,12], logic:"tradSwing" }),
    westCoastCool: GP({ name:"West Coast cool", tempo:[90,130], swing:[54,58], comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:45,kF:22,bC:48,bF:18,dC:55,dF:22, halfOn:false, halfDen:[0,16], logic:"coolModal" }),
    milesCool: GP({ name:"Cool jazz (Miles/Gil)", tempo:[78,118], swing:[53,58], comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:48,kF:24,bC:50,bF:18,dC:55,dF:24, halfOn:false, halfDen:[0,16], logic:"coolModal" }),
    thirdStream: GP({ name:"Third stream", tempo:[70,130], swing:[52,56], comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:50,kF:26,bC:50,bF:18,dC:55,dF:24, halfOn:false, halfDen:[0,14], logic:"cinematicBigBand" }),
    soulJazz: GP({ name:"Soul jazz", tempo:[90,125], swing:[54,58], comp:"pushPull", bass:"upright", keys:"organ", drums:"tight",
      kC:65,kF:40,bC:65,bF:35,dC:70,dF:45, halfOn:true, halfDen:[12,32], logic:"grooveFunk" }),
    organGroove: GP({ name:"Organ trio groove", tempo:[95,135], swing:[54,58], comp:"pushPull", bass:"upright", keys:"organ", drums:"tight",
      kC:60,kF:38,bC:62,bF:32,dC:70,dF:40, halfOn:true, halfDen:[12,30], logic:"grooveFunk" }),
    gospelJazz: GP({ name:"Gospel jazz", tempo:[70,115], swing:[52,56], comp:"sustain", bass:"upright", keys:"ep", drums:"brushes",
      kC:55,kF:35,bC:55,bF:30,dC:60,dF:35, halfOn:false, halfDen:[0,20], logic:"grooveFunk" }),
    jazzBlues: GP({ name:"Jazz blues shuffle", tempo:[95,150], swing:[56,62], comp:"charleston", bass:"upright", keys:"piano", drums:"shuffle",
      kC:60,kF:32,bC:60,bF:26,dC:72,dF:42, halfOn:true, halfDen:[10,28], logic:"bluesLogic" }),
    jazzWaltz: GP({ name:"Jazz waltz", tempo:[85,135], swing:[54,58], comp:"fourComp", bass:"upright", keys:"piano", drums:"brushes",
      kC:55,kF:28,bC:55,bF:22,dC:60,dF:30, halfOn:false, halfDen:[0,18], logic:"tradSwing" }),
    modalJazz: GP({ name:"Modal jazz", tempo:[80,140], swing:[53,57], comp:"sustain", bass:"upright", keys:"piano", drums:"jazz",
      kC:50,kF:26,bC:52,bF:22,dC:55,dF:26, halfOn:true, halfDen:[8,24], logic:"modalSpiritual" }),
    spiritualJazz: GP({ name:"Spiritual jazz", tempo:[70,125], swing:[52,56], comp:"sustain", bass:"upright", keys:"organ", drums:"ambient",
      kC:52,kF:30,bC:52,bF:24,dC:50,dF:26, halfOn:true, halfDen:[10,24], logic:"modalSpiritual" }),
    postBop: GP({ name:"Post-bop", tempo:[110,180], swing:[55,60], comp:"pushPull", bass:"upright", keys:"piano", drums:"jazz",
      kC:62,kF:32,bC:62,bF:24,dC:70,dF:38, halfOn:true, halfDen:[14,30], logic:"coolModal" }),
    ecm: GP({ name:"ECM / Nordic ambient", tempo:[60,110], swing:[50,54], comp:"sustain", bass:"upright", keys:"pad", drums:"ambient",
      kC:35,kF:24,bC:40,bF:18,dC:40,dF:22, halfOn:false, halfDen:[0,12], logic:"ambientModal" }),
    chamberJazz: GP({ name:"Chamber jazz", tempo:[70,125], swing:[50,54], comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:42,kF:24,bC:44,bF:18,dC:45,dF:20, halfOn:false, halfDen:[0,12], logic:"ambientModal" }),
    freeJazz: GP({ name:"Free jazz", tempo:[90,170], swing:[50,56], comp:"sustain", bass:"upright", keys:"piano", drums:"free",
      kC:70,kF:55,bC:70,bF:40,dC:75,dF:55, halfOn:true, halfDen:[10,40], logic:"freeForm" }),
    loftJazz: GP({ name:"Loft jazz", tempo:[85,150], swing:[50,56], comp:"sustain", bass:"upright", keys:"piano", drums:"free",
      kC:68,kF:52,bC:68,bF:36,dC:70,dF:48, halfOn:true, halfDen:[10,36], logic:"freeForm" }),
    avantJazz: GP({ name:"Avant-garde jazz", tempo:[70,150], swing:[50,56], comp:"sustain", bass:"upright", keys:"piano", drums:"free",
      kC:70,kF:60,bC:68,bF:40,dC:72,dF:52, halfOn:true, halfDen:[8,34], logic:"freeForm" }),
    cinematicBigBand: GP({ name:"Modern big band cinematic", tempo:[80,170], swing:[52,58], comp:"fourComp", bass:"upright", keys:"piano", drums:"jazz",
      kC:60,kF:34,bC:60,bF:26,dC:78,dF:46, halfOn:true, halfDen:[12,30], logic:"cinematicBigBand" }),
    brassBand: GP({ name:"Brass band / second line", tempo:[95,150], swing:[56,60], comp:"pushPull", bass:"upright", keys:"piano", drums:"swing",
      kC:60,kF:32,bC:62,bF:26,dC:74,dF:42, halfOn:true, halfDen:[12,26], logic:"tradSwing" }),
    bossaJazz: GP({ name:"Bossa nova jazz", tempo:[120,175], swing:[50,52], groove:"bossa", comp:"montuno", bass:"round", keys:"ep", drums:"perc",
      kC:55,kF:28,bC:55,bF:18,dC:60,dF:35, halfOn:true, halfDen:[14,32], logic:"latinTurns" }),
    sambaJazz: GP({ name:"Samba-jazz (brazuca)", tempo:[120,185], swing:[50,52], groove:"samba", comp:"montuno", bass:"round", keys:"piano", drums:"perc",
      kC:58,kF:32,bC:58,bF:22,dC:65,dF:38, halfOn:true, halfDen:[16,36], logic:"latinTurns" }),
    afroCubanJazz: GP({ name:"Afro-Cuban jazz (clave)", tempo:[105,170], swing:[50,54], groove:"afroCuban", comp:"montuno", bass:"round", keys:"organ", drums:"perc",
      kC:60,kF:35,bC:65,bF:26,dC:68,dF:40, halfOn:true, halfDen:[16,36], logic:"claveDrive" }),
    mamboBigBand: GP({ name:"Mambo big band", tempo:[115,180], swing:[50,54], groove:"afroCuban", comp:"fourComp", bass:"round", keys:"piano", drums:"perc",
      kC:62,kF:34,bC:65,bF:26,dC:72,dF:46, halfOn:true, halfDen:[18,38], logic:"claveDrive" }),
    boleroJazz: GP({ name:"Bolero jazz ballad", tempo:[60,95], swing:[50,52], groove:"afroCuban", comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:42,kF:24,bC:44,bF:18,dC:45,dF:24, halfOn:false, halfDen:[0,12], logic:"claveDrive" }),
    afroPeruvian: GP({ name:"Afro-Peruvian jazz (land√≥)", tempo:[70,115], swing:[50,52], groove:"afroCuban", comp:"montuno", bass:"upright", keys:"piano", drums:"perc",
      kC:55,kF:30,bC:55,bF:22,dC:60,dF:38, halfOn:true, halfDen:[10,26], logic:"claveDrive" }),
    flamencoJazz: GP({ name:"Flamenco-jazz", tempo:[90,150], swing:[50,54], groove:"afroCuban", comp:"montuno", bass:"upright", keys:"piano", drums:"perc",
      kC:60,kF:32,bC:60,bF:24,dC:65,dF:40, halfOn:true, halfDen:[12,30], logic:"latinTurns" }),
    calypsoJazz: GP({ name:"Caribbean calypso-jazz", tempo:[100,160], swing:[50,52], groove:"afroCuban", comp:"pushPull", bass:"round", keys:"piano", drums:"perc",
      kC:58,kF:32,bC:58,bF:24,dC:65,dF:40, halfOn:true, halfDen:[12,30], logic:"claveDrive" }),
    skaJazz: GP({ name:"Ska-jazz", tempo:[120,185], swing:[50,52], groove:"rock", comp:"pushPull", bass:"pickBass", keys:"organ", drums:"rock",
      kC:62,kF:32,bC:62,bF:22,dC:70,dF:40, halfOn:false, halfDen:[0,18], logic:"dubReggae" }),
    reggaeJazz: GP({ name:"Reggae / rocksteady jazz", tempo:[80,120], swing:[50,52], groove:"hiphop", comp:"pushPull", bass:"sub", keys:"organ", drums:"minimal",
      kC:55,kF:30,bC:58,bF:26,dC:60,dF:32, halfOn:false, halfDen:[0,14], logic:"dubReggae" }),
    afrobeatFusion: GP({ name:"Afrobeat jazz fusion", tempo:[100,140], swing:[50,54], groove:"afroCuban", comp:"pushPull", bass:"round", keys:"organ", drums:"perc",
      kC:65,kF:38,bC:68,bF:30,dC:72,dF:44, halfOn:true, halfDen:[14,32], logic:"fusionRock" }),
    highlifeFusion: GP({ name:"Highlife jazz fusion", tempo:[100,140], swing:[50,52], groove:"afroCuban", comp:"pushPull", bass:"round", keys:"piano", drums:"perc",
      kC:62,kF:32,bC:62,bF:26,dC:68,dF:40, halfOn:true, halfDen:[12,30], logic:"fusionRock" }),
    latinFunkJazz: GP({ name:"Latin funk-jazz", tempo:[90,125], swing:[50,54], groove:"funk", comp:"clav", bass:"round", keys:"clavBright", drums:"tight",
      kC:70,kF:45,bC:70,bF:35,dC:75,dF:45, halfOn:true, halfDen:[12,28], logic:"grooveFunk" }),
    jazzFunk: GP({ name:"Jazz-funk", tempo:[90,120], swing:[50,54], groove:"funk", comp:"clav", bass:"round", keys:"ep", drums:"tight",
      kC:70,kF:48,bC:70,bF:38,dC:75,dF:48, halfOn:true, halfDen:[10,26], logic:"grooveFunk" }),
    acidJazz: GP({ name:"Acid jazz", tempo:[95,120], swing:[50,54], groove:"funk", comp:"clav", bass:"sub", keys:"organ", drums:"tight",
      kC:65,kF:45,bC:65,bF:35,dC:70,dF:45, halfOn:false, halfDen:[0,22], logic:"grooveFunk" }),
    nuJazz: GP({ name:"Nu jazz", tempo:[95,125], swing:[50,54], groove:"house", comp:"sustain", bass:"round", keys:"pad", drums:"electro",
      kC:58,kF:38,bC:60,bF:30,dC:65,dF:45, halfOn:false, halfDen:[0,22], logic:"brokenBeat" }),
    jazztronica: GP({ name:"Jazztronica", tempo:[95,125], swing:[50,54], groove:"house", comp:"edmStab", bass:"sub", keys:"pad", drums:"electro",
      kC:60,kF:40,bC:60,bF:30,dC:70,dF:48, halfOn:false, halfDen:[0,22], logic:"brokenBeat" }),
    brokenBeatJazz: GP({ name:"Broken beat jazz", tempo:[95,130], swing:[50,54], groove:"breaks", comp:"pushPull", bass:"round", keys:"ep", drums:"breaks",
      kC:62,kF:42,bC:62,bF:32,dC:70,dF:50, halfOn:false, halfDen:[0,20], logic:"brokenBeat" }),
    boomBapJazz: GP({ name:"Hip-hop jazz / boom-bap", tempo:[80,105], swing:[50,54], groove:"hiphop", comp:"neoSoulPush", bass:"sub", keys:"ep", drums:"lofi",
      kC:62,kF:48,bC:60,bF:36,dC:65,dF:50, halfOn:false, halfDen:[0,18], logic:"grooveFunk" }),
    tripHopJazz: GP({ name:"Trip-hop jazz", tempo:[70,100], swing:[50,54], groove:"hiphop", comp:"sustain", bass:"sub", keys:"pad", drums:"lofi",
      kC:55,kF:35,bC:55,bF:30,dC:60,dF:45, halfOn:false, halfDen:[0,18], logic:"brokenBeat" }),
    neoSoulJazz: GP({ name:"Neo-soul jazz", tempo:[70,110], swing:[50,54], groove:"hiphop", comp:"neoSoulPush", bass:"round", keys:"ep", drums:"lofi",
      kC:68,kF:55,bC:60,bF:35,dC:55,dF:45, halfOn:true, halfDen:[24,50], logic:"grooveFunk" }),
    smoothJazz: GP({ name:"Smooth jazz", tempo:[70,110], swing:[50,52], groove:"hiphop", comp:"sustain", bass:"round", keys:"ep", drums:"minimal",
      kC:55,kF:32,bC:55,bF:24,dC:55,dF:32, halfOn:false, halfDen:[0,18], logic:"coolModal" }),
    quietStorm: GP({ name:"Quiet storm jazz", tempo:[65,95], swing:[50,52], groove:"hiphop", comp:"sustain", bass:"sub", keys:"ep", drums:"minimal",
      kC:50,kF:32,bC:50,bF:24,dC:50,dF:32, halfOn:false, halfDen:[0,16], logic:"coolModal" }),
    jazzRockFusion: GP({ name:"Jazz-rock fusion", tempo:[95,150], swing:[50,54], groove:"rock", comp:"pushPull", bass:"pickBass", keys:"organ", drums:"rock",
      kC:70,kF:40,bC:70,bF:30,dC:78,dF:48, halfOn:false, halfDen:[0,20], logic:"fusionRock" }),
    progFusion: GP({ name:"Prog / jazz-metal fusion", tempo:[110,180], swing:[50,54], groove:"rock", comp:"rockChugs", bass:"pickBass", keys:"organ", drums:"rock",
      kC:75,kF:45,bC:75,bF:35,dC:82,dF:52, halfOn:false, halfDen:[0,22], logic:"fusionRock" }),
  };

  /* ---------- Limiters ---------- */
  function getChordLimiterState(){
    const ids = [
      "qMaj7","qMin7","qDom7","qDim7","qHalfDim","qSus","qMinMaj",
      "x9","x11","x13","x6","xAdd9","xSharp11","xMin11",
      "tAlt","tSlash","tChrom","tB9","tSharp9"
    ];
    const out = {};
    for (const id of ids){
      const el = document.getElementById(id);
      if (el && el.type === "checkbox") out[id] = !!el.checked;
    }
    return out;
  }
  function setChordLimiterState(s){
    if (!s) return;
    for (const k of Object.keys(s)){
      const el = document.getElementById(k);
      if (el && el.type === "checkbox") el.checked = !!s[k];
    }
  }

  function buildQualityOptions(limit){
    const opts = [];
    if (limit.qMaj7){
      opts.push({v:{symbol:"maj7", family:"maj", key:"maj7", display:"maj7"}, w:22});
      if (limit.x9) opts.push({v:{symbol:"maj9", family:"maj", key:"maj9", display:"maj9"}, w:12});
      if (limit.x6) opts.push({v:{symbol:"6/9", family:"maj", key:"6/9", display:"6/9"}, w:10});
      if (limit.x6) opts.push({v:{symbol:"maj6", family:"maj", key:"maj6", display:"6"}, w:7});
      if (limit.xAdd9) opts.push({v:{symbol:"add9", family:"maj", key:"add9", display:"add9"}, w:7});
      if (limit.xSharp11 || limit.x11) opts.push({v:{symbol:"maj9sharp11", family:"maj", key:"maj9sharp11", display:"maj9(#11)"}, w:7});
    }
    if (limit.qMin7){
      opts.push({v:{symbol:"min7", family:"min", key:"min7", display:"m7"}, w:20});
      if (limit.x9) opts.push({v:{symbol:"min9", family:"min", key:"min9", display:"m9"}, w:12});
      if (limit.x6) opts.push({v:{symbol:"min6", family:"min", key:"min6", display:"m6"}, w:8});
      if (limit.xMin11 || limit.x11) opts.push({v:{symbol:"min11", family:"min", key:"min11", display:"m11"}, w:8});
    }
    if (limit.qDom7){
      opts.push({v:{symbol:"dom7", family:"dom", key:"dom7", display:"7"}, w:22});
      if (limit.x9) opts.push({v:{symbol:"dom9", family:"dom", key:"dom9", display:"9"}, w:14});
      if (limit.x11) opts.push({v:{symbol:"dom11", family:"dom", key:"dom11", display:"11"}, w:9});
      if (limit.x13) opts.push({v:{symbol:"dom13", family:"dom", key:"dom13", display:"13"}, w:12});
      if (limit.tB9) opts.push({v:{symbol:"dom7b9", family:"dom", key:"dom7b9", display:"7(b9)"}, w:7});
      if (limit.tSharp9) opts.push({v:{symbol:"dom7sharp9", family:"dom", key:"dom7sharp9", display:"7(#9)"}, w:7});
    }
    if (limit.qMinMaj){
      opts.push({v:{symbol:"minMaj7", family:"minmaj", key:"minMaj7", display:"mMaj7"}, w:7});
      if (limit.x9) opts.push({v:{symbol:"minMaj9", family:"minmaj", key:"minMaj9", display:"mMaj9"}, w:5});
    }
    if (limit.qHalfDim) opts.push({v:{symbol:"halfdim", family:"hdim", key:"halfdim", display:"√∏7"}, w:10});
    if (limit.qDim7)    opts.push({v:{symbol:"dim7", family:"dim", key:"dim7", display:"dim7"}, w:8});
    if (limit.qSus){
      opts.push({v:{symbol:"sus", family:"sus", key:"sus", display:"sus"}, w:6});
      if (limit.x9) opts.push({v:{symbol:"7sus", family:"sus", key:"7sus", display:"7sus"}, w:6});
    }
    if (!opts.length) opts.push({v:{symbol:"dom7", family:"dom", key:"dom7", display:"7"}, w:1});
    return opts;
  }

  /* ---------- Progression logic weights ---------- */
  function macroToWeights(chaos){
    const c = clamp(chaos,0,100)/100;
    return {
      keyStability: Math.round(85 - c*75),
      functional:   Math.round(80 - c*70),
      rootChaos:    Math.round(15 + c*80),
      qualityChaos: Math.round(15 + c*75),
      tension:      Math.round(10 + c*80),
      memoryKill:   Math.round(40 + c*50),
    };
  }

  const PROGRESSION_LOGICS = {
    none: { name:"None (fully random)", apply:(w)=>({...w}) },
    jazzFunctional: { name:"Jazz: functional gravity", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+18,0,100),
        keyStability:clamp(w.keyStability+10,0,100),
        rootChaos:clamp(w.rootChaos-10,0,100),
        tension:clamp(w.tension+(8+10*c),0,100),
        qualityChaos:clamp(w.qualityChaos+6,0,100)
      };
    }},
    jazzModal: { name:"Jazz: modal centers", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-18,0,100),
        keyStability:clamp(w.keyStability+12,0,100),
        rootChaos:clamp(w.rootChaos-10,0,100),
        tension:clamp(w.tension+(3+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+6,0,100)
      };
    }},
    latinTurns: { name:"Latin: turnarounds + cycles", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+10,0,100),
        keyStability:clamp(w.keyStability+8,0,100),
        rootChaos:clamp(w.rootChaos-6,0,100),
        tension:clamp(w.tension+(10+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos+6,0,100)
      };
    }},
    bluesLogic: { name:"Blues: tension & release", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+12,0,100),
        keyStability:clamp(w.keyStability+18,0,100),
        rootChaos:clamp(w.rootChaos-16,0,100),
        tension:clamp(w.tension+(6+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos-4,0,100)
      };
    }},
    rockLogic: { name:"Rock: diatonic + borrowed", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-8,0,100),
        keyStability:clamp(w.keyStability+20,0,100),
        rootChaos:clamp(w.rootChaos-10,0,100),
        tension:clamp(w.tension+(2+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos+2,0,100)
      };
    }},
    discoLogic: { name:"Disco: bright loops", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+2,0,100),
        keyStability:clamp(w.keyStability+18,0,100),
        rootChaos:clamp(w.rootChaos-12,0,100),
        tension:clamp(w.tension+(4+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos+6,0,100)
      };
    }},
    neoSoulLogic: { name:"Neo-Soul: slippery voiceleading", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-10,0,100),
        keyStability:clamp(w.keyStability+10,0,100),
        rootChaos:clamp(w.rootChaos+6,0,100),
        tension:clamp(w.tension+(8+10*c),0,100),
        qualityChaos:clamp(w.qualityChaos+10,0,100)
      };
    }},
    fusionLogic: { name:"Fusion: planing + side-slips", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+6,0,100),
        keyStability:clamp(w.keyStability+6,0,100),
        rootChaos:clamp(w.rootChaos+10,0,100),
        tension:clamp(w.tension+(10+12*c),0,100),
        qualityChaos:clamp(w.qualityChaos+12,0,100)
      };
    }},
    tradSwing: { name:"Trad swing gravity", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+14,0,100),
        keyStability:clamp(w.keyStability+16,0,100),
        rootChaos:clamp(w.rootChaos-12,0,100),
        tension:clamp(w.tension+(4+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos-2,0,100)
      };
    }},
    coolModal: { name:"Cool/modal restraint", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-6,0,100),
        keyStability:clamp(w.keyStability+18,0,100),
        rootChaos:clamp(w.rootChaos-8,0,100),
        tension:clamp(w.tension+(2+4*c),0,100),
        qualityChaos:clamp(w.qualityChaos+4,0,100)
      };
    }},
    modalSpiritual: { name:"Modal / spiritual drift", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-10,0,100),
        keyStability:clamp(w.keyStability+8,0,100),
        rootChaos:clamp(w.rootChaos+8,0,100),
        tension:clamp(w.tension+(6+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+10,0,100)
      };
    }},
    ambientModal: { name:"Ambient modal centers", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-16,0,100),
        keyStability:clamp(w.keyStability+20,0,100),
        rootChaos:clamp(w.rootChaos-6,0,100),
        tension:clamp(w.tension+(1+4*c),0,100),
        qualityChaos:clamp(w.qualityChaos+2,0,100),
        memoryKill:clamp(w.memoryKill-6,0,100)
      };
    }},
    freeForm: { name:"Free / avant", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-25,0,100),
        keyStability:clamp(w.keyStability-10,0,100),
        rootChaos:clamp(w.rootChaos+26,0,100),
        tension:clamp(w.tension+(14+12*c),0,100),
        qualityChaos:clamp(w.qualityChaos+22,0,100),
        memoryKill:clamp(w.memoryKill+18,0,100)
      };
    }},
    cinematicBigBand: { name:"Cinematic big band", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+10,0,100),
        keyStability:clamp(w.keyStability+16,0,100),
        rootChaos:clamp(w.rootChaos-6,0,100),
        tension:clamp(w.tension+(6+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+6,0,100),
        memoryKill:clamp(w.memoryKill-4,0,100)
      };
    }},
    claveDrive: { name:"Clave-driven", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+8,0,100),
        keyStability:clamp(w.keyStability+10,0,100),
        rootChaos:clamp(w.rootChaos-2,0,100),
        tension:clamp(w.tension+(8+10*c),0,100),
        qualityChaos:clamp(w.qualityChaos+4,0,100)
      };
    }},
    grooveFunk: { name:"Groove / funk-jazz", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-6,0,100),
        keyStability:clamp(w.keyStability+4,0,100),
        rootChaos:clamp(w.rootChaos+8,0,100),
        tension:clamp(w.tension+(6+10*c),0,100),
        qualityChaos:clamp(w.qualityChaos+10,0,100)
      };
    }},
    brokenBeat: { name:"Broken beat / nu", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-12,0,100),
        keyStability:clamp(w.keyStability+6,0,100),
        rootChaos:clamp(w.rootChaos+10,0,100),
        tension:clamp(w.tension+(6+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+12,0,100),
        memoryKill:clamp(w.memoryKill+8,0,100)
      };
    }},
    dubReggae: { name:"Dub / reggae lean", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-14,0,100),
        keyStability:clamp(w.keyStability+12,0,100),
        rootChaos:clamp(w.rootChaos-2,0,100),
        tension:clamp(w.tension+(1+4*c),0,100),
        qualityChaos:clamp(w.qualityChaos+4,0,100)
      };
    }},
    fusionRock: { name:"Fusion / rock drive", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-2,0,100),
        keyStability:clamp(w.keyStability+6,0,100),
        rootChaos:clamp(w.rootChaos+8,0,100),
        tension:clamp(w.tension+(10+12*c),0,100),
        qualityChaos:clamp(w.qualityChaos+10,0,100)
      };
    }},
    edmLogic: { name:"EDM: loop-centric", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-18,0,100),
        keyStability:clamp(w.keyStability+26,0,100),
        rootChaos:clamp(w.rootChaos-18,0,100),
        tension:clamp(w.tension-2+6*c,0,100),
        qualityChaos:clamp(w.qualityChaos-8+10*c,0,100),
        memoryKill:clamp(w.memoryKill+12,0,100)
      };
    }},
  };

  /* ---------- Quick UI dropdown init ---------- */
  function initLogicDropdown(){
    E.progressionLogic.innerHTML = "";
    for (const [id,o] of Object.entries(PROGRESSION_LOGICS)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = o.name;
      E.progressionLogic.appendChild(opt);
    }
  }
  function initGenreDropdown(){
    E.genrePreset.innerHTML = "";
    for (const [id,g] of Object.entries(GENRE_PRESETS)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = g.name;
      E.genrePreset.appendChild(opt);
    }
  }

  /* ---------- Themes ---------- */
  const PAGE_THEMES = {
    obsidian: { name:"Obsidian", bg:"#0b0f14", a:"rgba(122,162,255,.08)", b:"rgba(182,124,255,.08)", c:"rgba(63,225,139,.05)",
      ink:"#e9eef6", muted:"#9aa6b2", panel:"rgba(255,255,255,.05)", panel2:"rgba(0,0,0,.20)", line:"rgba(255,255,255,.09)" },
    midnight: { name:"Midnight", bg:"#060812", a:"rgba(0,183,255,.08)", b:"rgba(255,77,255,.07)", c:"rgba(255,255,255,.03)",
      ink:"#eef3ff", muted:"#9aa6b2", panel:"rgba(255,255,255,.045)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.085)" },
    parchment:{ name:"Parchment", bg:"#f4f1ea", a:"rgba(47,107,255,.10)", b:"rgba(182,124,255,.10)", c:"rgba(63,225,139,.06)",
      ink:"#1b2230", muted:"#4b5566", panel:"rgba(0,0,0,.04)", panel2:"rgba(0,0,0,.06)", line:"rgba(0,0,0,.12)" },
    terminal: { name:"Terminal (default)", bg:"#020604", a:"rgba(0,255,154,.10)", b:"rgba(0,183,255,.06)", c:"rgba(255,255,255,.03)",
      ink:"#c9ffe8", muted:"#7ad4b0", panel:"rgba(0,255,154,.04)", panel2:"rgba(0,0,0,.32)", line:"rgba(0,255,154,.10)" },
    sunset: { name:"Sunset", bg:"#0a0610", a:"rgba(255,120,80,.10)", b:"rgba(255,77,255,.08)", c:"rgba(122,162,255,.07)",
      ink:"#f6efff", muted:"#b8a7c6", panel:"rgba(255,255,255,.05)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.09)" },
  };

  function initThemeDropdowns(){
    E.pageTheme.innerHTML = "";
    for (const [id,t] of Object.entries(PAGE_THEMES)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = t.name;
      E.pageTheme.appendChild(opt);
    }
  }

  function applyPageTheme(themeId){
    const t = PAGE_THEMES[themeId] || PAGE_THEMES.terminal;
    document.documentElement.style.setProperty("--pageBg", t.bg);
    document.documentElement.style.setProperty("--pageInk", t.ink);
    document.documentElement.style.setProperty("--pageMuted", t.muted);
    document.documentElement.style.setProperty("--pagePanel", t.panel);
    document.documentElement.style.setProperty("--pagePanel2", t.panel2);
    document.documentElement.style.setProperty("--pageLine", t.line);
    document.documentElement.style.setProperty("--pageGlowA", t.a);
    document.documentElement.style.setProperty("--pageGlowB", t.b);
    document.documentElement.style.setProperty("--pageGlowC", t.c);
    state.pageTheme = themeId;
    try{ localStorage.setItem("fm_page_theme", themeId); }catch{}
  }

  const PIANO_THEMES = {
    classic:{ name:"Classic", vars:{ "--accent":"#2f82ff","--good":"#18e07a","--chord":"#ff4dd2","--keyWhite":"#f2f5fb","--keyBlack":"#161b23","--keyBorder":"#c9d3e2","--keyBlackBorder":"#2a3240","--keyBorderStrong":"rgba(0,0,0,.38)" } },
    neon:{ name:"Neon", vars:{ "--accent":"#00c8ff","--good":"#00ff9a","--chord":"#ff4dff","--keyWhite":"#e9f7ff","--keyBlack":"#0b0f14","--keyBorder":"rgba(233,247,255,.45)","--keyBlackBorder":"rgba(255,255,255,.16)","--keyBorderStrong":"rgba(0,0,0,.36)" } },
    mono:{ name:"Mono", vars:{ "--accent":"#9ecbff","--good":"#7cf7b0","--chord":"#ff63d8","--keyWhite":"#0f131a","--keyBlack":"#05070b","--keyBorder":"#6d7686","--keyBlackBorder":"#d5dbe6","--keyBorderStrong":"rgba(255,255,255,.82)" } },
    pastel:{ name:"Pastel", vars:{ "--accent":"#6aa8ff","--good":"#6ff0c8","--chord":"#ff7fcf","--keyWhite":"#f7fbff","--keyBlack":"#141826","--keyBorder":"rgba(255,255,255,.25)","--keyBlackBorder":"rgba(255,255,255,.12)","--keyBorderStrong":"rgba(0,0,0,.34)" } },
  };

  function initPianoThemeDropdown(){
    E.pianoTheme.innerHTML = "";
    for (const [id,t] of Object.entries(PIANO_THEMES)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = t.name;
      E.pianoTheme.appendChild(opt);
    }
  }

  function applyPianoTheme(id){
    const t = PIANO_THEMES[id] || PIANO_THEMES.classic;
    for (const k of Object.keys(t.vars)) document.documentElement.style.setProperty(k, t.vars[k]);
    state.pianoTheme = id;
    try{ localStorage.setItem("fm_piano_theme", id); }catch{}
  }

  function applyMorphBg(on){
    state.morphBg = !!on;
    document.documentElement.style.setProperty("--morphOn", state.morphBg ? "1" : "0");
    try{ localStorage.setItem("fm_morph_bg", state.morphBg ? "1" : "0"); }catch{}
  }

  /* ---------- Rendering ---------- */
  function flatChartSlots(){
    const slots = [];
    for (let b=0;b<state.chartBars.length;b++){
      const bar = state.chartBars[b];
      const chords = bar?.chords || [];
      for (let h=0;h<chords.length;h++){
        slots.push({ barIndex:b, halfIndex:h, chord: chords[h] });
      }
    }
    return slots;
  }

  function activeChord(){
    const bar = state.chartBars[state.activeBar];
    if (!bar) return null;
    const idx = clamp(state.activeHalf, 0, (bar.chords?.length||1)-1);
    return bar.chords[idx] || null;
  }

  function renderLeadSheet(){
    E.sheet.innerHTML = "";
    for (let b=0;b<state.chartBars.length;b++){
      const bar = state.chartBars[b];
      const el = document.createElement("div");
      el.className = "bar";
      el.dataset.bar = String(b);

      const num = document.createElement("div");
      num.className = "num";
      num.textContent = String(b+1);

      const c1 = bar?.chords?.[0] || null;
      const c2 = bar?.chords?.[1] || null;

      const sym = document.createElement("div");
      sym.className = "sym";
      sym.textContent = c1 ? chordName(c1) : "‚Äî";

      el.appendChild(num);
      el.appendChild(sym);

      if (bar?.split && c2){
        const sym2 = document.createElement("div");
        sym2.className = "sym sym2";
        sym2.textContent = chordName(c2);
        el.appendChild(sym2);

        const hh = document.createElement("div");
        hh.className = "halfHit";
        const top = document.createElement("button");
        const bot = document.createElement("button");
        top.type="button"; bot.type="button";

        top.addEventListener("click",(ev)=>{ ev.stopPropagation(); onBarTap(b,0,true); });
        bot.addEventListener("click",(ev)=>{ ev.stopPropagation(); onBarTap(b,1,true); });

        hh.appendChild(top); hh.appendChild(bot);
        el.appendChild(hh);
      }

      el.addEventListener("click", ()=> onBarTap(b,0,true));
      E.sheet.appendChild(el);
    }
    highlightActiveBar();
    applyEditVisuals();
  }

  function applyEditVisuals(){
    const nodes = E.sheet.querySelectorAll(".bar");
    nodes.forEach(n=>{
      n.classList.toggle("editing", !!state.editMode);
    });
    E.editHint.style.display = state.editMode ? "block" : "none";
    E.btnEdit.classList.toggle("primary", !!state.editMode);
  }

  function highlightActiveBar(){
    const bars = E.sheet.querySelectorAll(".bar");
    bars.forEach(node=>{
      const b = Number(node.dataset.bar||0);
      node.classList.toggle("active", b===state.activeBar);
    });
  }

  function renderHeaderPills(){
    const totalBars = state.chartBars.length || 0;
    const slots = flatChartSlots();
    E.pillLine.textContent = `${totalBars} bars ¬∑ ${Math.max(1, slots.length)} chords`;
    const ch = activeChord();
    E.focusLine.textContent = ch ? chordName(ch) : "‚Äî";
  }

  function renderKeyLine(){
    if (!state.showKey){
      E.leadKey.textContent = "‚Äî";
      return;
    }
    E.leadKey.textContent = `Center: ${noteName(state.keyRoot)} ${state.keyMode}`;
  }

  function placeMarker(svg, cx, cy, kind){
    const style = state.markerStyle || "dots";
    const fillVar = (kind==="root") ? "var(--good)" : "var(--chord)";
    const rootStroke = "rgba(255,255,255,.82)";
    const chordStroke = "rgba(0,0,0,.55)";

    if (style==="dots"){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", String(cx));
      c.setAttribute("cy", String(cy));
      c.setAttribute("r", "10");
      c.setAttribute("fill", fillVar);
      c.setAttribute("stroke", kind==="root" ? rootStroke : chordStroke);
      c.setAttribute("stroke-width", kind==="root" ? "2.2" : "1.4");
      svg.appendChild(c);
      return;
    }
    if (style==="rings"){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", String(cx));
      c.setAttribute("cy", String(cy));
      c.setAttribute("r", "12");
      c.setAttribute("fill", kind==="root" ? fillVar : "transparent");
      c.setAttribute("stroke", kind==="root" ? rootStroke : fillVar);
      c.setAttribute("stroke-width", kind==="root" ? "3.2" : "2.4");
      svg.appendChild(c);
      return;
    }
    if (style==="squares"){
      const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
      r.setAttribute("x", String(cx-10));
      r.setAttribute("y", String(cy-10));
      r.setAttribute("width", "20");
      r.setAttribute("height", "20");
      r.setAttribute("rx", "5");
      r.setAttribute("fill", fillVar);
      r.setAttribute("stroke", kind==="root" ? rootStroke : chordStroke);
      r.setAttribute("stroke-width", kind==="root" ? "2.2" : "1.4");
      svg.appendChild(r);
      return;
    }
    const tri = document.createElementNS("http://www.w3.org/2000/svg","path");
    tri.setAttribute("d", `M ${cx} ${cy-12} L ${cx-12} ${cy+10} L ${cx+12} ${cy+10} Z`);
    tri.setAttribute("fill", fillVar);
    tri.setAttribute("stroke", kind==="root" ? rootStroke : chordStroke);
    tri.setAttribute("stroke-width", kind==="root" ? "2.2" : "1.4");
    svg.appendChild(tri);
  }

  function renderPianoForActive(){
    const ch = activeChord();
    if (!ch){
      E.pianoSvg.innerHTML = "";
      E.pianoTop.textContent = "‚Äî";
      E.pianoHint.textContent = "‚Äî";
      return;
    }

    const prev = (state.activeBar>0) ? (state.chartBars[state.activeBar-1]?.chords?.slice(-1)[0] || null) : null;
    const next = (state.activeBar<state.chartBars.length-1) ? (state.chartBars[state.activeBar+1]?.chords?.[0] || null) : null;

    const {pcs: scalePCs, mode} = scalePCsForChordLocal(ch, prev, next);
    const chordPCs = chordTonesPCs(ch);

    const scaleRoot = (ch && typeof ch.scaleRoot==="number") ? ch.scaleRoot : ch.root;
    E.pianoTop.textContent = chordName(ch);
    E.pianoHint.textContent = `Scale suggestion: ${noteName(scaleRoot)} ${mode} ¬∑ Keyboard: ${state.kbOct} oct.`;

    const svg = E.pianoSvg;
    svg.innerHTML = "";

    const W = 1000, H = 240;
    const baseOct = clamp(Number(state.kbOct)||2, 1, 4);
    const needWide = (ch.intervals?.length||0) >= 5;
    const oct = clamp(needWide ? Math.max(baseOct, 3) : baseOct, 1, 4);
    const whiteKeyCount = 7 * oct;
    const whiteW = W / whiteKeyCount;
    const whiteH = 230;

    const whiteOrder = [0,2,4,5,7,9,11];

    const keyPos = [];
    let x = 0;
    for (let o=0;o<oct;o++){
      for (let i=0;i<7;i++){
        const p = whiteOrder[i];
        keyPos.push({pc:p+12*o, x, white:true});
        x += whiteW;
      }
    }

    for (let i=0;i<keyPos.length;i++){
      const k = keyPos[i];
      const p = pc(k.pc);
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", String(k.x));
      rect.setAttribute("y", "0");
      rect.setAttribute("width", String(whiteW));
      rect.setAttribute("height", String(whiteH));

      const inScale = scalePCs.includes(p);
      rect.setAttribute("fill", inScale ? "var(--accent)" : "var(--keyWhite)");
      rect.setAttribute("stroke", inScale ? `rgba(0,0,0,var(--scaleStrokeAlpha))` : "var(--keyBorderStrong)");
      rect.setAttribute("stroke-width", inScale ? "var(--scaleStrokeWidth)" : "1.6");
      svg.appendChild(rect);

      const isChord = chordPCs.includes(p);
      const isRoot = p === pc(ch.root);
      if (isChord){
        placeMarker(svg, k.x + whiteW*0.5, 175, isRoot ? "root" : "chord");
      }
    }

    const blackW = whiteW*0.62;
    const blackH = 140;
    const blackOffsets = {1:0.70, 3:1.72, 6:3.70, 8:4.72, 10:5.74};
    for (let o=0;o<oct;o++){
      for (const pRel of [1,3,6,8,10]){
        const baseWhiteIndex = blackOffsets[pRel];
        const x0 = (o*7 + baseWhiteIndex) * whiteW - blackW/2;
        const p = pc(pRel + 12*o);
        const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
        rect.setAttribute("x", String(x0));
        rect.setAttribute("y", "0");
        rect.setAttribute("rx", "6");
        rect.setAttribute("ry", "6");
        rect.setAttribute("width", String(blackW));
        rect.setAttribute("height", String(blackH));

        const inScale = scalePCs.includes(p);
        rect.setAttribute("fill", inScale ? "var(--accent)" : "var(--keyBlack)");
        rect.setAttribute("stroke", inScale ? `rgba(0,0,0,var(--scaleStrokeAlpha))` : "var(--keyBlackBorder)");
        rect.setAttribute("stroke-width", inScale ? "var(--scaleStrokeWidth)" : "1.6");
        svg.appendChild(rect);

        const isChord = chordPCs.includes(p);
        const isRoot = p === pc(ch.root);
        if (isChord){
          placeMarker(svg, x0 + blackW*0.5, 95, isRoot ? "root" : "chord");
        }
      }
    }
  }

  function renderAll(){
    renderHeaderPills();
    renderKeyLine();
    renderLeadSheet();
    renderPianoForActive();
  }

  /* ---------- Audio ---------- */
  const AudioKit = (() => {
    let ctx = null;
    let master = null;
    let comp = null;
    let limiter = null;

    function ensure(){
      if (ctx) return ctx;
      const AC = window.AudioContext || window.webkitAudioContext;
      ctx = new AC({ latencyHint: "interactive" });

      master = ctx.createGain();
      master.gain.value = 0.85;

      comp = ctx.createDynamicsCompressor();
      comp.threshold.value = -18;
      comp.knee.value = 22;
      comp.ratio.value = 3.5;
      comp.attack.value = 0.004;
      comp.release.value = 0.16;

      limiter = ctx.createDynamicsCompressor();
      limiter.threshold.value = -6;
      limiter.knee.value = 0;
      limiter.ratio.value = 20;
      limiter.attack.value = 0.002;
      limiter.release.value = 0.12;

      comp.connect(limiter);
      limiter.connect(master);
      master.connect(ctx.destination);
      return ctx;
    }

    function now(){ return ensure().currentTime; }
    function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }

    function env(gainNode, t0, a, d, s, r, peak=0.8){
      const t1 = t0 + a;
      const t2 = t1 + d;
      gainNode.gain.cancelScheduledValues(t0);
      gainNode.gain.setValueAtTime(0.0001, t0);
      gainNode.gain.linearRampToValueAtTime(peak, t1);
      gainNode.gain.linearRampToValueAtTime(Math.max(0.0001, peak*s), t2);
      return (tOff)=>{
        gainNode.gain.cancelScheduledValues(tOff);
        const v = Math.max(0.0001, gainNode.gain.value || 0.0001);
        gainNode.gain.setValueAtTime(v, tOff);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, tOff + r);
      };
    }

    function osc(type="sine"){
      const c = ensure();
      const o = c.createOscillator();
      o.type = type;
      return o;
    }

    function noise(){
      const c = ensure();
      const buffer = c.createBuffer(1, c.sampleRate * 0.25, c.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
      const src = c.createBufferSource();
      src.buffer = buffer;
      return src;
    }

    function createVoiceChain(){
      const c = ensure();
      const g = c.createGain();
      g.gain.value = 1.0;
      g.connect(comp);
      return { ctx:c, out:g };
    }

  function chordVoicingMidi(ch, style="closed"){
    const root = ch.root;
    const tones = chordTonesPCs(ch).slice();
    const base = 52 + (pc(root) - 0); // lower register to reduce brightness
    const mids = tones.map(p=>{
      let m = base + (pc(p - pc(root)));
      while (m < 46) m += 12;
      while (m > 74) m -= 12;
      return m;
    });
    mids.sort((a,b)=>a-b);
    if ((style==="open" || mids.length>=5) && mids.length>=4){
      mids[0] -= 12;
      mids[2] += 12;
      mids.sort((a,b)=>a-b);
    }

    // enforce minimum spacing (>=3 semitones) by nudging upward
    for (let i=1;i<mids.length;i++){
      if (mids[i] - mids[i-1] < 3) mids[i] = mids[i-1] + 3;
    }

    return mids;
  }

    function playChord(ch, preset, t0, dur, vel=0.7){
      const c = ensure();
      const {out} = createVoiceChain();

      const type = ({
        ep:"triangle", piano:"sine", organ:"square", pad:"sine", fm:"sine", chip:"square",
        bell:"sine", glass:"sine", pluck2:"triangle", vibes:"sine", choirPad:"sine", noisePad:"sine",
        guitarish:"triangle", clavBright:"square",
      }[preset] || "triangle");

      const vStyle = (preset==="pad"||preset==="choirPad"||preset==="noisePad") ? "open" : "closed";
      const mids = chordVoicingMidi(ch, vStyle);

      const gain = c.createGain();
      gain.gain.value = 0.0001;
      gain.connect(out);

      const sustain = (preset==="pad"||preset==="choirPad") ? 0.65 : 0.32;
      const release = env(gain, t0, 0.01, 0.08, sustain, 0.14, 0.35*vel);

      for (let i=0;i<mids.length;i++){
        const o = osc(type);
        o.frequency.setValueAtTime(midiToHz(mids[i]), t0);
        if (preset==="pad"||preset==="choirPad"){
          o.detune.setValueAtTime((i-1.5)*6, t0);
        }
        o.connect(gain);
        o.start(t0);
        o.stop(t0 + dur + 0.25);
      }
      release(t0 + dur);
    }

    function playBass(rootPc, preset, t0, dur, vel=0.8){
      const c = ensure();
      const {out} = createVoiceChain();

      const type = ({
        upright:"triangle", round:"sine", sub:"sine", pluck:"triangle",
        fmBass:"sine", rubber:"triangle", acid:"sawtooth", reese:"sawtooth",
        squareBass:"square", wobble:"square", pickBass:"triangle", muted:"triangle"
      }[preset] || "triangle");

      const gain = c.createGain();
      gain.gain.value = 0.0001;
      gain.connect(out);
      const rel = env(gain, t0, 0.004, 0.06, 0.35, 0.12, 0.40*vel);

      let m = 40 + pc(rootPc);
      while (m < 36) m += 12;
      while (m > 52) m -= 12;

      const o = osc(type);
      o.frequency.setValueAtTime(midiToHz(m), t0);
      if (preset==="upright"||preset==="pluck"||preset==="pickBass"){
        o.frequency.setValueAtTime(midiToHz(m)*1.02, t0);
        o.frequency.exponentialRampToValueAtTime(midiToHz(m), t0+0.05);
      }
      o.connect(gain);
      o.start(t0);
      o.stop(t0 + dur + 0.18);
      rel(t0 + dur);
    }

    function playDrumHit(kind, preset, t0, vel=0.8){
      const c = ensure();
      const {out} = createVoiceChain();
      const g = c.createGain();
      g.gain.value = 0.0001;
      g.connect(out);

      const n = noise();
      const f = c.createBiquadFilter();
      f.type = "bandpass";
      f.frequency.value = (kind==="hat"||kind==="ride") ? 9000 : (kind==="snare"? 2200 : 140);
      f.Q.value = (kind==="kick") ? 0.8 : 1.2;

      n.connect(f);
      f.connect(g);

      const peak = 0.55*vel;

      if (kind==="kick"){
        const o = osc("sine");
        const og = c.createGain();
        og.gain.value = 0.0001;
        og.connect(out);
        const rel1 = env(og, t0, 0.001, 0.05, 0.05, 0.12, 0.70*vel);
        o.frequency.setValueAtTime(110, t0);
        o.frequency.exponentialRampToValueAtTime(55, t0+0.08);
        o.connect(og);
        o.start(t0);
        o.stop(t0+0.20);
        rel1(t0+0.14);
        const relN = env(g, t0, 0.001, 0.03, 0.02, 0.10, 0.25*vel);
        n.start(t0); n.stop(t0+0.11); relN(t0+0.07);
        return;
      }

      if (kind==="snare"){
        f.frequency.value = 1800;
        const relN = env(g, t0, 0.001, 0.06, 0.05, 0.14, peak);
        n.start(t0); n.stop(t0+0.20); relN(t0+0.11);
        return;
      }

      if (kind==="hat"){
        f.frequency.value = 9500;
        f.Q.value = 0.9;
        const relN = env(g, t0, 0.001, 0.02, 0.04, 0.09, peak*0.75);
        n.start(t0); n.stop(t0+0.11); relN(t0+0.055);
        return;
      }

      f.frequency.value = 7800;
      f.Q.value = 0.7;
      const relN = env(g, t0, 0.001, 0.06, 0.20, 0.20, peak*0.65);
      n.start(t0); n.stop(t0+0.38); relN(t0+0.22);
    }

    async function resume(){
      ensure();
      if (!ctx) return;
      if (ctx.state === "suspended"){
        try{ await ctx.resume(); }catch(e){}
      }
    }

    function hardStop(){}

    return { ensure, now, resume, playChord, playBass, playDrumHit, hardStop };
  })();

  window.addEventListener("pointerdown", () => { AudioKit.resume(); }, { once:true, passive:true });

  /* ---------- Player (Transport) ---------- */
  const player = (() => {
    let isPlaying = false;
    let timer = null;
    let tempo = DEFAULTS.tempo;
    let swing = DEFAULTS.swing;
    let chart = [];
    let atBar = 0;
    let atHalf = 0;

    function setTempo(t, sw){
      tempo = clamp(Number(t)||120, 30, 320);
      swing = clamp(Number(sw)||58, 50, 80);
    }
    function setChart(bars){ chart = Array.isArray(bars) ? bars : []; }
    function jumpTo(b,h){
      atBar = clamp(b,0,Math.max(0, chart.length-1));
      const bar = chart[atBar];
      atHalf = clamp(h,0,Math.max(0,(bar?.chords?.length||1)-1));
    }

    function barSeconds(){ return 240 / tempo; } // 4/4 bar length
    function halfSeconds(){ return barSeconds()/2; }

    function currentChord(){
      const bar = chart[atBar];
      if (!bar) return null;
      const idx = clamp(atHalf,0,Math.max(0,(bar.chords?.length||1)-1));
      return bar.chords?.[idx] || null;
    }

    function nextStep(){
      const bar = chart[atBar];
      if (!bar) return;

      const halves = bar.split ? 2 : 1;
      if (halves===2){
        if (atHalf===0){ atHalf=1; return; }
        atHalf=0; atBar++;
      }else{
        atHalf=0; atBar++;
      }
      if (atBar >= chart.length){
        atBar = 0;
        atHalf = 0;
      }
    }

    function scheduleStep(){
      if (!isPlaying) return;
      const t0 = AudioKit.now() + 0.02;

      const bar = chart[atBar];
      const ch = currentChord();
      if (!bar || !ch) return;

      // Update UI focus to stay perfectly in sync with audio ‚Äúnow‚Äù
      state.activeBar = atBar;
      state.activeHalf = atHalf;
      highlightActiveBar();
      renderHeaderPills();
      renderPianoForActive();

      // Length
      const dur = (bar.split ? halfSeconds() : barSeconds());

      // --- Keys comp ---
      // Style maps to pattern density
      const comp = state.compStyle;
      const kBusy = clamp(state.keysComplex/100,0,1);
      const kFill = clamp(state.keysFill/100,0,1);

      const stabCount = (() => {
        if (comp==="twoStabs") return 2;
        if (comp==="fourComp") return 4;
        if (comp==="charleston") return 2;
        if (comp==="anticipations") return 3;
        if (comp==="pushPull") return 3;
        if (comp==="sparse") return 1;
        if (comp==="arpeggio") return 3;
        if (comp==="sustain") return 1;
        if (comp==="montuno") return 4;
        if (comp==="clav") return 4;
        if (comp==="rockChugs") return 4;
        if (comp==="discoChop") return 4;
        if (comp==="neoSoulPush") return 3;
        if (comp==="edmStab") return 2;
        return 2;
      })();

      const offsets = [];
      if (stabCount===1){
        offsets.push(0);
      } else if (comp==="charleston"){
        offsets.push(0);
        offsets.push(dur*0.375);
      } else if (comp==="anticipations"){
        offsets.push(0);
        offsets.push(dur*0.25);
        offsets.push(dur*0.75);
      } else if (comp==="pushPull"){
        offsets.push(0);
        offsets.push(dur*0.50);
        offsets.push(dur*0.875);
      } else {
        for (let i=0;i<stabCount;i++) offsets.push((dur*(i/stabCount)));
      }

      // add a tiny randomized humanization
      const human = (amt)=> (Math.random()*2-1)*amt;

      // sustain style: long pad
      if (comp==="sustain"){
        AudioKit.playChord(ch, state.keysPreset, t0, dur*0.95, 0.65);
      } else {
        offsets.forEach((off, i)=>{
          const v = 0.55 + 0.25*kBusy + 0.08*Math.sin(i*1.3);
          const len = dur * (comp==="rockChugs"||comp==="discoChop"||comp==="clav" ? 0.18 : 0.22);
          AudioKit.playChord(ch, state.keysPreset, t0 + off + human(0.008), Math.min(len, dur-off), v);
        });

        // fills: extra little stab near end
        if (chance(kFill*0.55)){
          const off = dur*(0.82 + 0.12*Math.random());
          const len = dur*0.14;
          AudioKit.playChord(ch, state.keysPreset, t0 + off + human(0.010), Math.min(len, dur-off), 0.55);
        }
      }

      // --- Bass ---
      const bBusy = clamp(state.bassComplex/100,0,1);
      const bFill = clamp(state.bassFill/100,0,1);
      const bassNotes = [];

      // basic walking: 1, 5, approach tones
      bassNotes.push({t:0, pc: pc(ch.root), len: dur*0.48, v: 0.75});
      if (dur > halfSeconds()*0.99){ // full bar
        bassNotes.push({t:dur*0.50, pc: pc(ch.root+7), len: dur*0.32, v: 0.72});
      } else {
        bassNotes.push({t:dur*0.50, pc: pc(ch.root+7), len: dur*0.24, v: 0.70});
      }
      if (chance(bBusy*0.55)){
        bassNotes.push({t:dur*0.25, pc: pc(ch.root+12), len: dur*0.20, v: 0.60});
      }
      if (chance(bFill*0.50)){
        bassNotes.push({t:dur*0.86, pc: pc(ch.root + (chance(0.5)? 1 : -1)), len: dur*0.12, v: 0.55});
      }

      bassNotes.forEach(n=>{
        AudioKit.playBass(n.pc, state.bassPreset, t0 + n.t + human(0.006), n.len, n.v);
      });

      // --- Drums ---
      const dLvl = clamp(state.drumsLevel/100,0,1);
      const dBusy = clamp(state.drumsComplex/100,0,1);
      const dFill = clamp(state.drumsFill/100,0,1);

      const groove = state.grooveStyle;
      const sub = 8; // 8th grid
      const step = dur / (sub*2); // 16th-ish
      const swingAmt = (clamp(state.swing,50,75)-50)/25; // 0..1
      const swingDelay = step*0.45*swingAmt;

      function hit(kind, when, vel){
        if (dLvl<=0.01) return;
        AudioKit.playDrumHit(kind, state.drumsPreset, t0 + when, clamp(vel*dLvl,0,1));
      }

      // ride pattern (jazzy)
      if (groove==="swing" || groove==="free"){
        const rideBase = [0, step*4, step*8, step*12]; // quarters
        rideBase.forEach((q, idx)=>{
          hit("ride", q, 0.55 + 0.18*(idx===0));
          // skip/and
          hit("ride", q + step*3 + swingDelay, 0.42 + 0.20*dBusy);
        });
        if (chance(0.25 + 0.45*dBusy)) hit("hat", step*8, 0.42);
        // light comping snare
        if (chance(0.25 + 0.55*dBusy)) hit("snare", step*6 + human(0.004), 0.28);
        if (chance(0.20 + 0.50*dBusy)) hit("snare", step*14 + human(0.004), 0.26);
        // occasional kick
        if (chance(0.18 + 0.35*dBusy)) hit("kick", step*8 + human(0.004), 0.35);
      }
      else if (groove==="brushBallad"){
        // gentle hats + snare swish
        hit("hat", 0, 0.35);
        hit("hat", step*8, 0.33);
        if (chance(0.35 + 0.35*dBusy)) hit("snare", step*10, 0.25);
        if (chance(0.20 + 0.30*dBusy)) hit("kick", step*0, 0.22);
      }
      else if (groove==="bossa" || groove==="samba" || groove==="afroCuban"){
        // simple clave-ish
        hit("hat", 0, 0.35);
        hit("hat", step*4, 0.30);
        hit("hat", step*8, 0.35);
        hit("hat", step*12, 0.30);
        hit("kick", 0, 0.35);
        hit("kick", step*8, 0.30);
        if (chance(0.35 + 0.35*dBusy)) hit("snare", step*6, 0.25);
        if (chance(0.35 + 0.35*dBusy)) hit("snare", step*14, 0.25);
      }
      else if (groove==="funk" || groove==="hiphop"){
        hit("hat", 0, 0.30);
        hit("hat", step*4 + swingDelay, 0.28);
        hit("hat", step*8, 0.30);
        hit("hat", step*12 + swingDelay, 0.28);
        hit("kick", 0, 0.42);
        if (chance(0.4 + 0.4*dBusy)) hit("kick", step*10, 0.35);
        hit("snare", step*8, 0.38);
      }
      else if (groove==="house" || groove==="techno" || groove==="disco"){
        hit("kick", 0, 0.55);
        hit("kick", step*4, 0.55);
        hit("kick", step*8, 0.55);
        hit("kick", step*12, 0.55);
        hit("hat", step*2, 0.28);
        hit("hat", step*6, 0.28);
        hit("hat", step*10, 0.28);
        hit("hat", step*14, 0.28);
        if (groove==="disco") hit("snare", step*8, 0.35);
      }
      else if (groove==="dnb" || groove==="breaks"){
        hit("kick", 0, 0.55);
        hit("snare", step*8, 0.45);
        if (chance(0.5 + 0.4*dBusy)) hit("kick", step*6, 0.40);
        if (chance(0.5 + 0.4*dBusy)) hit("snare", step*14, 0.34);
        hit("hat", step*2, 0.28);
        hit("hat", step*4, 0.26);
        hit("hat", step*6, 0.28);
        hit("hat", step*10, 0.26);
        hit("hat", step*12, 0.28);
      }
      else if (groove==="rock" || groove==="shuffle"){
        hit("kick", 0, 0.55);
        hit("snare", step*8, 0.50);
        if (chance(0.45 + 0.35*dBusy)) hit("kick", step*10, 0.40);
        hit("hat", step*2 + swingDelay*0.5, 0.32);
        hit("hat", step*6 + swingDelay*0.5, 0.30);
        hit("hat", step*10 + swingDelay*0.5, 0.32);
        hit("hat", step*14 + swingDelay*0.5, 0.30);
      }
      else if (groove==="ambient"){
        if (chance(0.25 + 0.55*dBusy)) hit("hat", step*2, 0.18);
        if (chance(0.25 + 0.55*dBusy)) hit("ride", step*9, 0.18);
      }

      // drum fill near end
      if (chance(dFill*0.45)){
        hit("hat", dur*0.86, 0.22 + 0.25*dBusy);
        hit("snare", dur*0.92, 0.22 + 0.25*dBusy);
      }

      // advance
      nextStep();
    }

    function start(){
      if (isPlaying) return;
      isPlaying = true;
      E.btnPlay.textContent = "‚è∏Ô∏è Pause";
      E.btnPlay.classList.add("primary");

      setTempo(state.tempo, state.swing);
      setChart(state.chartBars);
      atBar = state.activeBar;
      atHalf = state.activeHalf;

      // schedule loop at the length of the current step
      const tick = () => {
        if (!isPlaying) return;
        const bar = chart[atBar];
        const dur = (bar?.split ? halfSeconds() : barSeconds());
        scheduleStep();
        timer = window.setTimeout(tick, Math.max(40, dur*1000 - 8));
      };
      tick();
    }

    function stop(){
      if (!isPlaying) return;
      isPlaying = false;
      if (timer) window.clearTimeout(timer);
      timer = null;
      E.btnPlay.textContent = "‚ñ∂Ô∏è Play";
      E.btnPlay.classList.remove("primary");
      // keep UI + chord preview working after pause (bug fix)
      renderHeaderPills();
      renderPianoForActive();
    }

    function toggle(){
      if (isPlaying) stop(); else start();
    }

    function isOn(){ return isPlaying; }

    return { start, stop, toggle, isOn, jumpTo, setTempo, setChart };
  })();

  /* ---------- Undo / Redo (last 5) ---------- */
  const history = {
    undo: [],
    redo: [],
    max: 5
  };

  function snapshot(){
    // keep it small but complete for expected edits
    return {
      chartBars: structuredClone(state.chartBars),
      activeBar: state.activeBar,
      activeHalf: state.activeHalf,
      // settings we want undoable
      bars: state.bars,
      halfEnabled: state.halfEnabled,
      halfDensity: state.halfDensity,
      tempo: state.tempo,
      swing: state.swing,
      chaos: state.chaos,
      rootMode: state.rootMode,
      progressionLogic: state.progressionLogic,
      genrePreset: state.genrePreset,
      grooveStyle: state.grooveStyle,
      compStyle: state.compStyle,
      bassPreset: state.bassPreset,
      keysPreset: state.keysPreset,
      drumsPreset: state.drumsPreset,
      drumsLevel: state.drumsLevel,
      keysComplex: state.keysComplex,
      keysFill: state.keysFill,
      bassComplex: state.bassComplex,
      bassFill: state.bassFill,
      drumsComplex: state.drumsComplex,
      drumsFill: state.drumsFill,
      scalesUsed: state.scalesUsed,
      limiter: structuredClone(state.limiter),
      pageTheme: state.pageTheme,
      pianoTheme: state.pianoTheme,
      markerStyle: state.markerStyle,
      morphBg: state.morphBg,
      kbOct: state.kbOct
    };
  }

  function restoreSnap(s){
    if (!s) return;
    state.chartBars = structuredClone(s.chartBars||[]);
    state.activeBar = s.activeBar||0;
    state.activeHalf = s.activeHalf||0;

    Object.assign(state, {
      bars: s.bars, halfEnabled:s.halfEnabled, halfDensity:s.halfDensity,
      tempo:s.tempo, swing:s.swing, chaos:s.chaos,
      rootMode:s.rootMode, progressionLogic:s.progressionLogic, genrePreset:s.genrePreset,
      grooveStyle:s.grooveStyle, compStyle:s.compStyle,
      bassPreset:s.bassPreset, keysPreset:s.keysPreset, drumsPreset:s.drumsPreset,
      drumsLevel:s.drumsLevel,
      keysComplex:s.keysComplex, keysFill:s.keysFill,
      bassComplex:s.bassComplex, bassFill:s.bassFill,
      drumsComplex:s.drumsComplex, drumsFill:s.drumsFill,
      scalesUsed:s.scalesUsed,
      limiter: structuredClone(s.limiter||state.limiter),
      pageTheme:s.pageTheme, pianoTheme:s.pianoTheme,
      markerStyle:s.markerStyle, morphBg:s.morphBg, kbOct:s.kbOct
    });

    // push to UI
    syncUIFromState();
    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);
    E.markerStyle.value = state.markerStyle;
    applyMorphBg(state.morphBg);
    renderAll();
    saveAll();
  }

  function pushHistory(){
    history.undo.push(snapshot());
    if (history.undo.length > history.max) history.undo.shift();
    history.redo.length = 0;
    updateUndoRedoButtons();
  }

  function doUndo(){
    if (!history.undo.length) return;
    history.redo.push(snapshot());
    const s = history.undo.pop();
    restoreSnap(s);
    updateUndoRedoButtons();
  }

  function doRedo(){
    if (!history.redo.length) return;
    history.undo.push(snapshot());
    const s = history.redo.pop();
    restoreSnap(s);
    updateUndoRedoButtons();
  }

  function updateUndoRedoButtons(){
    E.btnUndo.disabled = history.undo.length===0;
    E.btnRedo.disabled = history.redo.length===0;
  }

  /* ---------- Generation (improved but still lightweight) ---------- */
  function chooseKeyCenter(){
    // "scalesUsed" now caps distinct scales/modes we use and still guides center drift
    // while keeping a visible ‚ÄúCenter‚Äù line for reference (not strict)
    state.keyRoot = rint(0,11);
    state.keyMode = pick(["ionian","dorian","mixolydian","aeolian","lydian"]);
  }

  function stepRoot(prevRoot, weights, allowedSet=null){
    // functional gravity: favor 5th motion when functional is high
    const f = clamp(weights.functional,0,100)/100;
    const rc = clamp(weights.rootChaos,0,100)/100;

    const opts = [
      {v: pc(prevRoot + 7), w: 18*f + 2},   // up a 5th
      {v: pc(prevRoot - 5), w: 18*f + 2},   // also up a 5th (same)
      {v: pc(prevRoot + 2), w: 7*f + 3},    // step
      {v: pc(prevRoot - 2), w: 7*f + 3},
      {v: pc(prevRoot + 1), w: 2 + 10*rc},  // chromatic
      {v: pc(prevRoot - 1), w: 2 + 10*rc},
      {v: rint(0,11), w: 1 + 18*rc}
    ];
    const filtered = allowedSet ? opts.filter(o=>allowedSet.has(pc(o.v))) : opts;
    return weightedPick(filtered.length ? filtered : opts);
  }

  function chooseQuality(limit, weights, scaleSet=null, chordRoot=null){
    const base = buildQualityOptions(limit);
    const qc = clamp(weights.qualityChaos,0,100)/100;
    const t  = clamp(weights.tension,0,100)/100;
    const rootPc = chordRoot!=null ? pc(chordRoot) : null;
    // tilt toward more colorful when chaos/tension higher
    const filtered = base.filter(o=>{
      if (!scaleSet || rootPc==null) return true;
      const tones = (CHORDS[o.v.symbol] || []).map(iv=>pc(rootPc + iv));
      return tones.every(p=>scaleSet.has(p));
    });
    const pool = filtered.length ? filtered : base;
    return weightedPick(pool.map(o=>{
      let w = o.w;
      if (o.v.family==="dom" && (o.v.symbol.includes("b9")||o.v.symbol.includes("sharp9"))) w *= (1 + 1.2*t);
      if (o.v.symbol.includes("9") || o.v.symbol.includes("11") || o.v.symbol.includes("13")) w *= (1 + 0.6*qc);
      if (o.v.family==="dim"||o.v.family==="hdim") w *= (1 + 0.4*qc);
      return {v:o.v, w};
    }));
  }

  function maybeSlash(ch, limit, weights){
    if (!limit.tSlash) return ch;
    const t = clamp(weights.tension,0,100)/100;
    if (!chance(0.10 + 0.25*t)) return ch;

    // choose slash from chord tones or step below root
    const pcs = chordTonesPCs(ch);
    const opt = chance(0.7) ? pick(pcs) : pc(ch.root + (chance(0.5)? -1 : 1));
    return {...ch, slash: opt};
  }

  function maybeAlt(ch, limit, weights){
    if (ch.family!=="dom") return ch;
    if (!limit.tAlt) return ch;
    const t = clamp(weights.tension,0,100)/100;
    if (!chance(0.10 + 0.35*t)) return ch;
    // represent ‚Äúalt‚Äù by choosing altered-ish tensions (we approximate by b9/#9)
    if (limit.tB9 && chance(0.55)) return {...ch, symbol:"dom7b9", intervals:CHORDS.dom7b9};
    if (limit.tSharp9 && chance(0.55)) return {...ch, symbol:"dom7sharp9", intervals:CHORDS.dom7sharp9};
    return ch;
  }

  function makeChord(root, q){
    return {
      root: pc(root),
      symbol: ({
        maj7:"maj7", maj9:"maj9", maj6:"6", "6/9":"6/9", add9:"add9", maj9sharp11:"maj9(#11)",
        min7:"m7", min9:"m9", min6:"m6", min11:"m11",
        minMaj7:"mMaj7", minMaj9:"mMaj9",
        dom7:"7", dom9:"9", dom11:"11", dom13:"13", dom7b9:"7(b9)", dom7sharp9:"7(#9)",
        sus:"sus", "7sus":"7sus",
        halfdim:"√∏7", dim7:"dim7"
      }[q.symbol] || q.display || q.symbol),
      family: q.family,
      key: q.key,
      intervals: CHORDS[q.symbol] || CHORDS.dom7,
      scaleRoot: pc(root)
    };
  }

  function generateChart(){
    if (state.lockProg) return;

    pushHistory();

    chooseKeyCenter();

    const singleScale = (state.scalesUsed===1 && SCALES[state.keyMode])
      ? new Set(SCALES[state.keyMode].map(i=>pc(state.keyRoot+i)))
      : null;
    const ensureInScale = (r)=>{
      if (!singleScale) return pc(r);
      const rp = pc(r);
      if (singleScale.has(rp)) return rp;
      const arr=[...singleScale];
      return arr.length ? arr[0] : rp;
    };

    // weights influenced by chaos + progressionLogic
    let w = macroToWeights(state.chaos);
    const logic = PROGRESSION_LOGICS[state.progressionLogic] || PROGRESSION_LOGICS.jazzFunctional;
    w = logic.apply(w, state.chaos);
    state.weights = w;

    const barsTarget = clamp(Number(state.bars)||8, 2, 32);

    const limit = state.limiter;

    const bars = [];
    let root = ensureInScale(state.keyRoot);

    // controlled ‚Äúcenter drift‚Äù: allow only N center changes, spread across bars
    const driftBudget = clamp(Number(state.scalesUsed)||8, 1, 32);
    let driftLeft = driftBudget;
    let lastDriftAt = -999;

    for (let b=0;b<barsTarget;b++){
      const split = state.halfEnabled && chance(clamp(state.halfDensity,0,100)/100);

      const chordCount = split ? 2 : 1;
      const chordArr = [];

      for (let h=0;h<chordCount;h++){
        // occasional drift
        const driftChance = clamp(w.rootChaos,0,100)/100 * 0.30 + (b>0 && (b-lastDriftAt)>3 ? 0.07 : 0);
        if (driftLeft>0 && chance(driftChance)){
          root = ensureInScale(rint(0,11));
          driftLeft--;
          lastDriftAt = b;
        } else {
          root = ensureInScale(stepRoot(root, w, singleScale));
        }

        // pick quality (tied to limiters)
        const q = chooseQuality(limit, w, singleScale, root);
        let ch = makeChord(root, q);

        // more ‚Äújazz‚Äù feeling: nudge dom chords toward ii-V-ish by biasing a ii before V
        if (logic===PROGRESSION_LOGICS.jazzFunctional && ch.family==="dom" && chance(0.35)){
          // if this is first half, try set this chord as ii and next as V
          if (split && h===0){
            const iiRoot = pc(root - 5); // ii is a 5th below V
            const qii = limit.qMin7 ? {symbol:"min7",family:"min",key:"min7",display:"m7"} : q;
            ch = makeChord(iiRoot, qii);
          }
        }

        ch = maybeAlt(ch, limit, w);
        ch = maybeSlash(ch, limit, w);

        // chromatic option: side-slip roots (only if limiter allows chromatic)
        if (limit.tChrom && chance(clamp(w.rootChaos,0,100)/100 * 0.18)){
          ch.root = pc(ch.root + (chance(0.5)? 1 : -1));
          ch.scaleRoot = ch.root;
        }

        chordArr.push(ch);
      }

      bars.push({ split, chords: chordArr });
    }

    assignChordModesWithLimit(bars);

    state.chartBars = bars;
    state.activeBar = 0;
    state.activeHalf = 0;

    renderAll();
    saveAll();
  }

  /* ---------- Tap behavior (focus + preview) ---------- */
  function onBarTap(b, h, preview){
    state.activeBar = clamp(b,0,Math.max(0,state.chartBars.length-1));
    const bar = state.chartBars[state.activeBar];
    const hh = clamp(h,0,Math.max(0,(bar?.chords?.length||1)-1));
    state.activeHalf = hh;

    highlightActiveBar();
    renderHeaderPills();
    renderPianoForActive();

    // If edit mode, open editor instead of preview
    if (state.editMode){
      openEditFor(b, h);
      return;
    }

    if (preview){
      const ch = activeChord();
      if (ch){
        AudioKit.resume();
        // short preview chord
        AudioKit.playChord(ch, state.keysPreset, AudioKit.now()+0.01, bar?.split ? 0.38 : 0.55, 0.75);
        AudioKit.playBass(pc(ch.root), state.bassPreset, AudioKit.now()+0.01, 0.25, 0.65);
      }
    }
  }

  /* ---------- Edit modal ---------- */
  let editTarget = { bar:0, half:0 };

  function initEditDropdowns(){
    // roots
    E.editRoot.innerHTML = "";
    NOTE_NAMES.forEach((n,i)=>{
      const o=document.createElement("option");
      o.value=String(i);
      o.textContent=n;
      E.editRoot.appendChild(o);
    });

    // qualities (show current limiter-safe set, but allow common items anyway)
    const qualList = [
      {id:"maj7", name:"maj7"},
      {id:"maj9", name:"maj9"},
      {id:"6/9", name:"6/9"},
      {id:"add9", name:"add9"},
      {id:"m7", name:"m7"},
      {id:"m9", name:"m9"},
      {id:"m11", name:"m11"},
      {id:"mMaj7", name:"mMaj7"},
      {id:"7", name:"7"},
      {id:"9", name:"9"},
      {id:"13", name:"13"},
      {id:"7(b9)", name:"7(b9)"},
      {id:"7(#9)", name:"7(#9)"},
      {id:"sus", name:"sus"},
      {id:"7sus", name:"7sus"},
      {id:"√∏7", name:"√∏7"},
      {id:"dim7", name:"dim7"},
    ];
    E.editQual.innerHTML = "";
    qualList.forEach(q=>{
      const o=document.createElement("option");
      o.value=q.id; o.textContent=q.name;
      E.editQual.appendChild(o);
    });

    // slash
    E.editSlash.innerHTML = "";
    const none = document.createElement("option");
    none.value = "none";
    none.textContent = "(none)";
    E.editSlash.appendChild(none);
    NOTE_NAMES.forEach((n,i)=>{
      const o=document.createElement("option");
      o.value=String(i);
      o.textContent=n;
      E.editSlash.appendChild(o);
    });
  }

  function openEditFor(barIndex, halfIndex){
    editTarget = { bar:barIndex, half:halfIndex };
    const bar = state.chartBars[barIndex];
    const ch = bar?.chords?.[halfIndex] || bar?.chords?.[0] || null;

    E.editTitle.textContent = `Edit bar ${barIndex+1}${bar?.split ? (halfIndex===0?" (top)":" (bottom)") : ""}`;

    if (ch){
      E.editRoot.value = String(pc(ch.root));
      // map symbol back to dropdown-ish
      const sym = ch.symbol;
      const mapBack = {
        "m7":"m7","m9":"m9","m11":"m11","mMaj7":"mMaj7",
        "maj7":"maj7","maj9":"maj9","6/9":"6/9","add9":"add9","6":"6/9",
        "7":"7","9":"9","11":"11","13":"13","7(b9)":"7(b9)","7(#9)":"7(#9)",
        "sus":"sus","7sus":"7sus","√∏7":"√∏7","dim7":"dim7"
      };
      E.editQual.value = mapBack[sym] || "7";
      E.editSlash.value = (ch.slash==null) ? "none" : String(pc(ch.slash));
    } else {
      E.editRoot.value = "0";
      E.editQual.value = "7";
      E.editSlash.value = "none";
    }

    // placement default based on current bar split + tap half
    if (bar?.split){
      E.editPlace.value = (halfIndex===0) ? "half1" : "half2";
    } else {
      E.editPlace.value = "whole";
    }

    E.editBack.style.display = "flex";
  }

  function closeEdit(){
    E.editBack.style.display = "none";
  }

  function qualToChordMeta(val){
    // convert dropdown value to internal
    const v = String(val);
    if (v==="maj7") return {symbol:"maj7", family:"maj", key:"maj7", intervals:CHORDS.maj7};
    if (v==="maj9") return {symbol:"maj9", family:"maj", key:"maj9", intervals:CHORDS.maj9};
    if (v==="6/9") return {symbol:"6/9", family:"maj", key:"6/9", intervals:CHORDS["6/9"]};
    if (v==="add9") return {symbol:"add9", family:"maj", key:"add9", intervals:CHORDS.add9};

    if (v==="m7") return {symbol:"min7", family:"min", key:"min7", intervals:CHORDS.min7};
    if (v==="m9") return {symbol:"min9", family:"min", key:"min9", intervals:CHORDS.min9};
    if (v==="m11") return {symbol:"min11", family:"min", key:"min11", intervals:CHORDS.min11};
    if (v==="mMaj7") return {symbol:"minMaj7", family:"minmaj", key:"minMaj7", intervals:CHORDS.minMaj7};

    if (v==="7") return {symbol:"dom7", family:"dom", key:"dom7", intervals:CHORDS.dom7};
    if (v==="9") return {symbol:"dom9", family:"dom", key:"dom9", intervals:CHORDS.dom9};
    if (v==="13") return {symbol:"dom13", family:"dom", key:"dom13", intervals:CHORDS.dom13};
    if (v==="7(b9)") return {symbol:"dom7b9", family:"dom", key:"dom7b9", intervals:CHORDS.dom7b9};
    if (v==="7(#9)") return {symbol:"dom7sharp9", family:"dom", key:"dom7sharp9", intervals:CHORDS.dom7sharp9};

    if (v==="sus") return {symbol:"sus", family:"sus", key:"sus", intervals:CHORDS.sus};
    if (v==="7sus") return {symbol:"7sus", family:"sus", key:"7sus", intervals:CHORDS["7sus"]};

    if (v==="√∏7") return {symbol:"halfdim", family:"hdim", key:"halfdim", intervals:CHORDS.halfdim};
    if (v==="dim7") return {symbol:"dim7", family:"dim", key:"dim7", intervals:CHORDS.dim7};

    return {symbol:"dom7", family:"dom", key:"dom7", intervals:CHORDS.dom7};
  }

  function applyEdit(){
    pushHistory();

    const b = editTarget.bar;
    const h = editTarget.half;

    const root = pc(Number(E.editRoot.value)||0);
    const meta = qualToChordMeta(E.editQual.value);
    const slashVal = E.editSlash.value;
    const slash = (slashVal==="none") ? null : pc(Number(slashVal)||0);

    const newChord = {
      root,
      symbol: ({
        maj7:"maj7", maj9:"maj9", "6/9":"6/9", add9:"add9",
        min7:"m7", min9:"m9", min11:"m11", minMaj7:"mMaj7",
        dom7:"7", dom9:"9", dom13:"13", dom7b9:"7(b9)", dom7sharp9:"7(#9)",
        sus:"sus", "7sus":"7sus",
        halfdim:"√∏7", dim7:"dim7"
      }[meta.symbol] || "7"),
      family: meta.family,
      key: meta.key,
      intervals: meta.intervals,
      slash,
      scaleRoot: root
    };

    const place = E.editPlace.value;

    // ensure bar exists
    if (!state.chartBars[b]) state.chartBars[b] = { split:false, chords:[newChord] };
    const bar = state.chartBars[b];

    if (place==="whole"){
      bar.split = false;
      bar.chords = [newChord];
      state.activeBar = b;
      state.activeHalf = 0;
    } else {
      bar.split = true;
      if (!Array.isArray(bar.chords) || bar.chords.length<2){
        const existing = bar.chords?.[0] || newChord;
        bar.chords = [existing, existing];
      }
      if (place==="half1"){
        bar.chords[0] = newChord;
        state.activeBar = b;
        state.activeHalf = 0;
      } else {
        bar.chords[1] = newChord;
        state.activeBar = b;
        state.activeHalf = 1;
      }
    }

    assignChordModesWithLimit(state.chartBars);
    renderAll();
    saveAll();
    closeEdit();
  }

  function clearEdit(){
    pushHistory();
    const b = editTarget.bar;
    const place = E.editPlace.value;

    if (!state.chartBars[b]) return;
    const bar = state.chartBars[b];

    if (place==="whole"){
      bar.split = false;
      bar.chords = [];
    } else {
      bar.split = true;
      if (!Array.isArray(bar.chords) || bar.chords.length<2) bar.chords = [null,null];
      if (place==="half1") bar.chords[0] = null;
      if (place==="half2") bar.chords[1] = null;

      // if both halves empty, simplify
      if (!bar.chords[0] && !bar.chords[1]){
        bar.split = false;
        bar.chords = [];
      }
    }

    // if chart chord missing, regenerate a safe chord so playback won't break
    const fallback = makeChord(state.keyRoot, {symbol:"maj7",family:"maj",key:"maj7",display:"maj7"});
    if (!bar.chords?.length){
      bar.split = false;
      bar.chords = [fallback];
    } else {
      bar.chords = bar.chords.map(x=>x||fallback);
    }

    assignChordModesWithLimit(state.chartBars);
    renderAll();
    saveAll();
    closeEdit();
  }

  /* ---------- Randomization (respect locks) ---------- */
  function randBetween(a,b){ return rint(a,b); }

  function applyGenrePreset(id){
    const g = GENRE_PRESETS[id] || GENRE_PRESETS.modernJazz;
    state.genrePreset = id;

    // Do not change progression here
    if (!state.lockTime){
      state.tempo = randBetween(g.tempo[0], g.tempo[1]);
      state.swing = randBetween(g.swing[0], g.swing[1]);
      state.halfEnabled = !!g.halfOn;
      state.halfDensity = randBetween(g.halfDen[0], g.halfDen[1]);
    }

    if (!state.lockStyle){
      state.grooveStyle = g.groove;
      state.compStyle = g.comp;
      state.progressionLogic = g.logic;
    }

    if (!state.lockSounds){
      state.bassPreset = g.bass;
      state.keysPreset = g.keys;
      state.drumsPreset = g.drums;
      state.drumsLevel = clamp(g.dC,0,100); // use dC as a base for level-ish
    }

    // complexity/fill (feel-ish, consider under style lock)
    if (!state.lockStyle){
      state.keysComplex = clamp(g.kC,0,100);
      state.keysFill = clamp(g.kF,0,100);
      state.bassComplex = clamp(g.bC,0,100);
      state.bassFill = clamp(g.bF,0,100);
      state.drumsComplex = clamp(g.dC,0,100);
      state.drumsFill = clamp(g.dF,0,100);
    }
  }

  function randomizeGeneratorOnly(){
    if (state.lockProg) return;
    pushHistory();
    // choose logic & chaos a bit
    state.chaos = randBetween(10, 70);
    state.progressionLogic = pick(Object.keys(PROGRESSION_LOGICS));
    state.scalesUsed = randBetween(1, 32);

    generateChart();
    syncUIFromState();
    saveAll();
  }

  function randomizeTimeOnly(){
    if (state.lockTime) return;
    pushHistory();
    state.bars = randBetween(2, 32);
    state.tempo = randBetween(60, 220);
    state.swing = randBetween(50, 70);
    state.halfEnabled = chance(0.6);
    state.halfDensity = randBetween(10, 55);

    syncUIFromState();
    saveAll();
  }

  function randomizeFeelOnly(){
    if (state.lockStyle) return;
    pushHistory();
    state.chaos = randBetween(0, 100);
    state.rootMode = pick(["keyed","drifting","orbiting","freefall"]);
    state.grooveStyle = pick(GROOVES).id;
    state.compStyle = pick(COMP_STYLES).id;

    // some realism: match logic to groove loosely
    if (state.grooveStyle==="bossa" || state.grooveStyle==="afroCuban") state.progressionLogic = "latinTurns";
    if (state.grooveStyle==="rock") state.progressionLogic = "rockLogic";
    if (state.grooveStyle==="disco") state.progressionLogic = "discoLogic";
    if (state.grooveStyle==="house" || state.grooveStyle==="techno") state.progressionLogic = "edmLogic";
    if (state.grooveStyle==="swing") state.progressionLogic = "jazzFunctional";

    syncUIFromState();
    saveAll();
  }

  function randomizeSoundsOnly(){
    if (state.lockSounds) return;
    pushHistory();
    state.bassPreset = pick(["upright","round","sub","pluck","fmBass","rubber","acid","reese","squareBass","wobble","pickBass","muted"]);
    state.keysPreset = pick(["ep","piano","organ","pad","fm","chip","bell","glass","pluck2","vibes","choirPad","noisePad","guitarish","clavBright"]);
    state.drumsPreset = pick(["jazz","brushes","tight","rock","disco","lofi","minimal","electro","house","trap","perc","dnb","techno"]);
    state.drumsLevel = randBetween(35, 75);

    // fill/complexity often lives with ‚Äúsounds/playing‚Äù too
    state.keysComplex = randBetween(20, 90);
    state.keysFill = randBetween(0, 75);
    state.bassComplex = randBetween(20, 90);
    state.bassFill = randBetween(0, 65);
    state.drumsComplex = randBetween(20, 95);
    state.drumsFill = randBetween(0, 85);

    syncUIFromState();
    saveAll();
  }

  function randomizeLimitersOnly(){
    if (state.lockLimiters) return;
    pushHistory();

    const lim = {...state.limiter};

    // core families: keep at least one of maj/min/dom
    lim.qMaj7 = chance(0.85);
    lim.qMin7 = chance(0.85);
    lim.qDom7 = chance(0.85);
    lim.qDim7 = chance(0.20);
    lim.qHalfDim = chance(0.65);
    lim.qSus = chance(0.25);
    lim.qMinMaj = chance(0.20);

    if (!lim.qMaj7 && !lim.qMin7 && !lim.qDom7){
      lim.qDom7 = true;
      lim.qMaj7 = true;
    }

    // extensions
    lim.x9 = chance(0.70);
    lim.x11 = chance(0.45);
    lim.x13 = chance(0.50);
    lim.x6 = chance(0.45);
    lim.xAdd9 = chance(0.30);
    lim.xSharp11 = chance(0.28);
    lim.xMin11 = chance(0.28);

    // tension
    lim.tAlt = chance(0.45);
    lim.tSlash = chance(0.40);
    lim.tChrom = chance(0.35);
    lim.tB9 = chance(0.35);
    lim.tSharp9 = chance(0.35);

    state.limiter = lim;
    setChordLimiterState(lim);
    saveAll();
  }

  function randomizeAll(){
    pushHistory();

    // Style random should keep progression by default; but "Random All" can change it unless locked
    if (!state.lockTheme){
      const themeId = pick(Object.keys(PAGE_THEMES));
      applyPageTheme(themeId);
      const pTheme = pick(Object.keys(PIANO_THEMES));
      applyPianoTheme(pTheme);
      state.markerStyle = pick(["dots","rings","triangles","squares"]);
      E.markerStyle.value = state.markerStyle;
      applyMorphBg(chance(0.8));
    }

    if (!state.lockTime){
      state.bars = randBetween(2, 32);
      state.tempo = randBetween(60, 220);
      state.swing = randBetween(50, 70);
      state.halfEnabled = chance(0.6);
      state.halfDensity = randBetween(10, 60);
    }

    if (!state.lockStyle){
      state.genrePreset = pick(Object.keys(GENRE_PRESETS));
      applyGenrePreset(state.genrePreset);
    } else {
      // if style locked, still allow chaos slight change?
      // no, keep it stable
    }

    if (!state.lockLimiters){
      randomizeLimitersOnly();
    }

    // generator knobs
    if (!state.lockProg){
      state.scalesUsed = randBetween(1, 32);
      state.chaos = randBetween(0, 100);
      // pick logic some
      state.progressionLogic = pick(Object.keys(PROGRESSION_LOGICS));
      generateChart();
    }

    syncUIFromState();
    renderAll();
    saveAll();
  }

  /* ---------- Style Random (keep progression) ---------- */
  function styleRandom(){
    pushHistory();

    // keep progression ALWAYS here (per request)
    if (!state.lockTheme){
      applyPageTheme(pick(Object.keys(PAGE_THEMES)));
      applyPianoTheme(pick(Object.keys(PIANO_THEMES)));
      state.markerStyle = pick(["dots","rings","triangles","squares"]);
      E.markerStyle.value = state.markerStyle;
      applyMorphBg(chance(0.85));
    }

    if (!state.lockStyle){
      state.genrePreset = pick(Object.keys(GENRE_PRESETS));
      applyGenrePreset(state.genrePreset);
    }

    if (!state.lockSounds){
      // also nudge sounds even if genre didn‚Äôt
      if (chance(0.55)) state.keysPreset = pick(["ep","piano","organ","pad","fm","chip","bell","glass","pluck2","vibes","choirPad","noisePad","guitarish","clavBright"]);
      if (chance(0.55)) state.bassPreset = pick(["upright","round","sub","pluck","fmBass","rubber","acid","reese","squareBass","wobble","pickBass","muted"]);
      if (chance(0.55)) state.drumsPreset = pick(["jazz","brushes","tight","rock","disco","lofi","minimal","electro","house","trap","perc","dnb","techno"]);
    }

    syncUIFromState();
    renderAll();
    saveAll();
  }

  /* ---------- Copy chart ---------- */
  function chartToText(){
    const parts = [];
    for (let b=0;b<state.chartBars.length;b++){
      const bar = state.chartBars[b];
      if (!bar) continue;
      if (bar.split && bar.chords?.length>=2){
        const a = bar.chords[0] ? chordName(bar.chords[0]) : "‚Äî";
        const c = bar.chords[1] ? chordName(bar.chords[1]) : "‚Äî";
        parts.push(`${a} / ${c}`);
      } else {
        const a = bar.chords?.[0] ? chordName(bar.chords[0]) : "‚Äî";
        parts.push(a);
      }
    }
    // group in 4-bar lines
    const lines = [];
    for (let i=0;i<parts.length;i+=4){
      lines.push(parts.slice(i,i+4).map(x=>`| ${x} `).join("") + "|");
    }
    return lines.join("\n");
  }

  async function copyChart(){
    const text = chartToText();
    try{
      await navigator.clipboard.writeText(text);
      E.msg.textContent = "Copied chart to clipboard ‚úÖ";
      setTimeout(()=>E.msg.textContent=" ", 1400);
    }catch{
      // fallback
      const ta=document.createElement("textarea");
      ta.value=text;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand("copy"); }catch{}
      document.body.removeChild(ta);
    }
  }

  /* ---------- Locks UI ---------- */
  function setLockBtn(btn, on, label){
    btn.classList.toggle("on", !!on);
    btn.innerHTML = (on ? "üîí" : "üîì") + ` <b>${label}</b>`;
  }

  function syncLocksUI(){
    setLockBtn(E.lockProgMini, state.lockProg, "Progression");
    setLockBtn(E.lockStyleMini, state.lockStyle, "Play style");
    setLockBtn(E.lockThemeMini, state.lockTheme, "Theme");
    setLockBtn(E.lockTimeMini, state.lockTime, "Timing");
    setLockBtn(E.lockSoundMini, state.lockSounds, "Sounds");
    setLockBtn(E.lockLimitMini, state.lockLimiters, "Limiters");
  }

  /* ---------- UI <-> State sync ---------- */
  function bindRangePair(rangeEl, numEl, onChange){
    const pull = ()=> {
      const v = Number(rangeEl.value);
      numEl.value = String(v);
      onChange(v);
    };
    const pullNum = ()=> {
      const v = clamp(Number(numEl.value||0), Number(rangeEl.min), Number(rangeEl.max));
      rangeEl.value = String(v);
      numEl.value = String(v);
      onChange(v);
    };
    rangeEl.addEventListener("input", pull);
    numEl.addEventListener("change", pullNum);
  }

  function syncUIFromState(){
    E.bars.value = String(state.bars);
    E.barsNum.value = String(state.bars);

    E.halfChords.checked = !!state.halfEnabled;
    E.halfDensity.value = String(state.halfDensity);
    E.halfDensityNum.value = String(state.halfDensity);

    E.tempo.value = String(state.tempo);
    E.tempoNum.value = String(state.tempo);

    E.swing.value = String(state.swing);
    E.swingNum.value = String(state.swing);

    E.chaos.value = String(state.chaos);
    E.chaosNum.value = String(state.chaos);

    E.rootMode.value = state.rootMode;

    E.progressionLogic.value = state.progressionLogic;
    E.genrePreset.value = state.genrePreset;

    E.grooveStyle.value = state.grooveStyle;
    E.compStyle.value = state.compStyle;

    E.scalesUsed.value = String(state.scalesUsed);
    E.scalesUsedNum.value = String(state.scalesUsed);

    E.bassPreset.value = state.bassPreset;
    E.keysPreset.value = state.keysPreset;
    E.drumsPreset.value = state.drumsPreset;

    E.drumsLevel.value = String(state.drumsLevel);
    E.drumsLevelNum.value = String(state.drumsLevel);

    E.keysComplex.value = String(state.keysComplex);
    E.keysComplexNum.value = String(state.keysComplex);
    E.keysFill.value = String(state.keysFill);
    E.keysFillNum.value = String(state.keysFill);

    E.bassComplex.value = String(state.bassComplex);
    E.bassComplexNum.value = String(state.bassComplex);
    E.bassFill.value = String(state.bassFill);
    E.bassFillNum.value = String(state.bassFill);

    E.drumsComplex.value = String(state.drumsComplex);
    E.drumsComplexNum.value = String(state.drumsComplex);
    E.drumsFill.value = String(state.drumsFill);
    E.drumsFillNum.value = String(state.drumsFill);

    E.pageTheme.value = state.pageTheme;
    E.pianoTheme.value = state.pianoTheme;
    E.markerStyle.value = state.markerStyle;
    E.morphBg.checked = !!state.morphBg;

    E.kbOct.value = String(state.kbOct);
    E.kbOctNum.value = String(state.kbOct);

    setChordLimiterState(state.limiter);
    syncLocksUI();
    updateUndoRedoButtons();
  }


  /* ---------- Advanced: reorder main menus ---------- */
  const SECTION_IDS = [
    {id:"cardHeader", name:"Title bar"},
    {id:"cardPiano", name:"Piano"},
    {id:"cardLead", name:"Lead sheet"},
    {id:"cardControls", name:"Controls"},
    {id:"cardLimiters", name:"Chord limiters"},
  ];

  function currentOrder(){
    const app = document.querySelector(".app");
    const ids = [];
    SECTION_IDS.forEach(s=>{
      const el = document.getElementById(s.id);
      if (el && el.parentElement===app) ids.push(s.id);
    });
    return ids;
  }

  function applyOrder(order){
    const app = document.querySelector(".app");
    order.forEach(id=>{
      const el = document.getElementById(id);
      if (el) app.appendChild(el);
    });
    try{ localStorage.setItem("fm_order", JSON.stringify(order)); }catch{}
  }

  function renderOrderList(){
    E.orderList.innerHTML = "";
    const order = currentOrder();
    order.forEach((id, idx)=>{
      const meta = SECTION_IDS.find(s=>s.id===id) || {name:id};
      const row = document.createElement("div");
      row.className = "modalRow";

      const left = document.createElement("div");
      left.className = "name";
      left.textContent = meta.name;

      const btns = document.createElement("div");
      btns.className = "reorderBtns";

      const up = document.createElement("button");
      up.className = "btn small";
      up.type = "button";
      up.textContent = "‚Üë";
      up.disabled = idx===0;
      up.addEventListener("click", ()=>{
        const o = currentOrder();
        const t = o[idx-1];
        o[idx-1] = o[idx];
        o[idx] = t;
        applyOrder(o);
        renderOrderList();
      });

      const down = document.createElement("button");
      down.className = "btn small";
      down.type = "button";
      down.textContent = "‚Üì";
      down.disabled = idx===order.length-1;
      down.addEventListener("click", ()=>{
        const o = currentOrder();
        const t = o[idx+1];
        o[idx+1] = o[idx];
        o[idx] = t;
        applyOrder(o);
        renderOrderList();
      });

      btns.appendChild(up);
      btns.appendChild(down);
      row.appendChild(left);
      row.appendChild(btns);
      E.orderList.appendChild(row);
    });
  }

  function resetDefaultOrder(){
    applyOrder(["cardHeader","cardPiano","cardLead","cardControls","cardLimiters"]);
    renderOrderList();
  }

  /* ---------- Persistence ---------- */
  function saveAll(){
    try{
      localStorage.setItem("fm_state", JSON.stringify({
        chartBars: state.chartBars,
        activeBar: state.activeBar,
        activeHalf: state.activeHalf,

        bars: state.bars,
        halfEnabled: state.halfEnabled,
        halfDensity: state.halfDensity,
        tempo: state.tempo,
        swing: state.swing,
        chaos: state.chaos,
        rootMode: state.rootMode,
        progressionLogic: state.progressionLogic,
        genrePreset: state.genrePreset,
        grooveStyle: state.grooveStyle,
        compStyle: state.compStyle,
        bassPreset: state.bassPreset,
        keysPreset: state.keysPreset,
        drumsPreset: state.drumsPreset,
        drumsLevel: state.drumsLevel,
        keysComplex: state.keysComplex,
        keysFill: state.keysFill,
        bassComplex: state.bassComplex,
        bassFill: state.bassFill,
        drumsComplex: state.drumsComplex,
        drumsFill: state.drumsFill,
        scalesUsed: state.scalesUsed,
        limiter: state.limiter,

        pageTheme: state.pageTheme,
        pianoTheme: state.pianoTheme,
        markerStyle: state.markerStyle,
        morphBg: state.morphBg,
        kbOct: state.kbOct,

        locks: {
          lockProg: state.lockProg,
          lockStyle: state.lockStyle,
          lockTheme: state.lockTheme,
          lockTime: state.lockTime,
          lockSounds: state.lockSounds,
          lockLimiters: state.lockLimiters
        }
      }));
    }catch{}
  }

  function loadAll(){
    const saved = safeJSONParse(localStorage.getItem("fm_state"), null);
    if (!saved) return false;

    // chart
    state.chartBars = saved.chartBars || [];
    state.activeBar = saved.activeBar || 0;
    state.activeHalf = saved.activeHalf || 0;

    // settings
    Object.assign(state, {
      bars: saved.bars ?? state.bars,
      halfEnabled: saved.halfEnabled ?? state.halfEnabled,
      halfDensity: saved.halfDensity ?? state.halfDensity,
      tempo: saved.tempo ?? state.tempo,
      swing: saved.swing ?? state.swing,
      chaos: saved.chaos ?? state.chaos,
      rootMode: saved.rootMode ?? state.rootMode,
      progressionLogic: saved.progressionLogic ?? state.progressionLogic,
      genrePreset: saved.genrePreset ?? state.genrePreset,
      grooveStyle: saved.grooveStyle ?? state.grooveStyle,
      compStyle: saved.compStyle ?? state.compStyle,
      bassPreset: saved.bassPreset ?? state.bassPreset,
      keysPreset: saved.keysPreset ?? state.keysPreset,
      drumsPreset: saved.drumsPreset ?? state.drumsPreset,
      drumsLevel: saved.drumsLevel ?? state.drumsLevel,
      keysComplex: saved.keysComplex ?? state.keysComplex,
      keysFill: saved.keysFill ?? state.keysFill,
      bassComplex: saved.bassComplex ?? state.bassComplex,
      bassFill: saved.bassFill ?? state.bassFill,
      drumsComplex: saved.drumsComplex ?? state.drumsComplex,
      drumsFill: saved.drumsFill ?? state.drumsFill,
      scalesUsed: saved.scalesUsed ?? state.scalesUsed,
      limiter: saved.limiter ?? state.limiter,

      pageTheme: saved.pageTheme ?? state.pageTheme,
      pianoTheme: saved.pianoTheme ?? state.pianoTheme,
      markerStyle: saved.markerStyle ?? state.markerStyle,
      morphBg: saved.morphBg ?? state.morphBg,
      kbOct: saved.kbOct ?? state.kbOct,
    });

    // locks
    const L = saved.locks || {};
    state.lockProg = !!L.lockProg;
    state.lockStyle = !!L.lockStyle;
    state.lockTheme = !!L.lockTheme;
    state.lockTime = !!L.lockTime;
    state.lockSounds = !!L.lockSounds;
    state.lockLimiters = !!L.lockLimiters;

    return true;
  }

  function loadOrder(){
    const o = safeJSONParse(localStorage.getItem("fm_order"), null);
    if (Array.isArray(o) && o.length) applyOrder(o);
  }

  /* ---------- Defaults ---------- */
  function applyDefaults(){
    pushHistory();

    Object.assign(state, structuredClone(DEFAULTS));
    state.limiter = structuredClone(DEFAULTS.limiter);
    state.allowedCenters = [];

    // locks remain as-is? user asked ‚Äúdefaults‚Äù to reset after randoms.
    // Keep locks (so you can keep your locking strategy), but reset chart if unlocked:
    const keepLocks = {
      lockProg: state.lockProg,
      lockStyle: state.lockStyle,
      lockTheme: state.lockTheme,
      lockTime: state.lockTime,
      lockSounds: state.lockSounds,
      lockLimiters: state.lockLimiters
    };
    Object.assign(state, keepLocks);

    // apply themes immediately
    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);
    state.markerStyle = DEFAULTS.markerStyle;
    applyMorphBg(DEFAULTS.morphBg);

    // regenerate a safe chart only if progression not locked
    if (!state.lockProg){
      state.bars = DEFAULTS.bars;
      state.halfEnabled = DEFAULTS.halfEnabled;
      state.halfDensity = DEFAULTS.halfDensity;
      state.scalesUsed = DEFAULTS.scalesUsed;
      generateChart();
    }

    syncUIFromState();
    renderAll();
    saveAll();
  }

  /* ---------- Bind UI events ---------- */
  function bindUI(){
    // ranges
    bindRangePair(E.bars, E.barsNum, (v)=>{ state.bars=v; saveAll(); });
    bindRangePair(E.halfDensity, E.halfDensityNum, (v)=>{ state.halfDensity=v; saveAll(); });
    bindRangePair(E.tempo, E.tempoNum, (v)=>{ state.tempo=v; saveAll(); });
    bindRangePair(E.swing, E.swingNum, (v)=>{ state.swing=v; saveAll(); });
    bindRangePair(E.chaos, E.chaosNum, (v)=>{ state.chaos=v; saveAll(); });
    bindRangePair(E.scalesUsed, E.scalesUsedNum, (v)=>{
      state.scalesUsed=v;
      assignChordModesWithLimit(state.chartBars);
      renderPianoForActive();
      saveAll();
    });

    bindRangePair(E.drumsLevel, E.drumsLevelNum, (v)=>{ state.drumsLevel=v; saveAll(); });

    bindRangePair(E.keysComplex, E.keysComplexNum, (v)=>{ state.keysComplex=v; saveAll(); });
    bindRangePair(E.keysFill, E.keysFillNum, (v)=>{ state.keysFill=v; saveAll(); });

    bindRangePair(E.bassComplex, E.bassComplexNum, (v)=>{ state.bassComplex=v; saveAll(); });
    bindRangePair(E.bassFill, E.bassFillNum, (v)=>{ state.bassFill=v; saveAll(); });

    bindRangePair(E.drumsComplex, E.drumsComplexNum, (v)=>{ state.drumsComplex=v; saveAll(); });
    bindRangePair(E.drumsFill, E.drumsFillNum, (v)=>{ state.drumsFill=v; saveAll(); });

    bindRangePair(E.kbOct, E.kbOctNum, (v)=>{ state.kbOct=v; saveAll(); renderPianoForActive(); });

    // checkboxes
    E.halfChords.addEventListener("change", ()=>{
      state.halfEnabled = !!E.halfChords.checked;
      saveAll();
    });

    // selects
    E.rootMode.addEventListener("change", ()=>{ state.rootMode = E.rootMode.value; saveAll(); });
    E.progressionLogic.addEventListener("change", ()=>{ state.progressionLogic = E.progressionLogic.value; saveAll(); });
    E.grooveStyle.addEventListener("change", ()=>{ state.grooveStyle = E.grooveStyle.value; saveAll(); });
    E.compStyle.addEventListener("change", ()=>{ state.compStyle = E.compStyle.value; saveAll(); });
    E.bassPreset.addEventListener("change", ()=>{ state.bassPreset = E.bassPreset.value; saveAll(); });
    E.keysPreset.addEventListener("change", ()=>{ state.keysPreset = E.keysPreset.value; saveAll(); });
    E.drumsPreset.addEventListener("change", ()=>{ state.drumsPreset = E.drumsPreset.value; saveAll(); });
    E.genrePreset.addEventListener("change", ()=>{
      if (!state.lockStyle || !state.lockTime || !state.lockSounds){
        pushHistory();
        applyGenrePreset(E.genrePreset.value);
        syncUIFromState();
        saveAll();
      }
    });

    E.pageTheme.addEventListener("change", ()=>{
      if (state.lockTheme) return;
      pushHistory();
      applyPageTheme(E.pageTheme.value);
      saveAll();
    });
    E.pianoTheme.addEventListener("change", ()=>{
      pushHistory();
      applyPianoTheme(E.pianoTheme.value);
      saveAll();
      renderPianoForActive();
    });
    E.markerStyle.addEventListener("change", ()=>{
      pushHistory();
      state.markerStyle = E.markerStyle.value;
      saveAll();
      renderPianoForActive();
    });

    E.morphBg.addEventListener("change", ()=>{
      pushHistory();
      applyMorphBg(E.morphBg.checked);
      saveAll();
    });

    // limiter checkboxes -> state
    document.getElementById("cardLimiters").addEventListener("change", (ev)=>{
      const t = ev.target;
      if (!(t instanceof HTMLInputElement)) return;
      if (t.type !== "checkbox") return;
      state.limiter = getChordLimiterState();
      saveAll();
    });

    // buttons
    E.btnPlay.addEventListener("click", async ()=>{
      await AudioKit.resume();
      player.toggle();
      saveAll();
    });

    E.btnGenerate.addEventListener("click", async ()=>{
      await AudioKit.resume();
      generateChart();
    });

    E.btnRandomAll.addEventListener("click", async ()=>{
      await AudioKit.resume();
      randomizeAll();
    });

    E.btnStyleRand.addEventListener("click", async ()=>{
      await AudioKit.resume();
      styleRandom();
    });

    E.btnDefaults.addEventListener("click", ()=>{
      applyDefaults();
    });

    E.btnUndo.addEventListener("click", ()=> doUndo());
    E.btnRedo.addEventListener("click", ()=> doRedo());

    E.btnCopy.addEventListener("click", ()=> copyChart());

    // sectional randoms
    E.btnRandGen.addEventListener("click", ()=> randomizeGeneratorOnly());
    E.btnRandTime.addEventListener("click", ()=> randomizeTimeOnly());
    E.btnRandFeel.addEventListener("click", ()=> randomizeFeelOnly());
    E.btnRandSounds.addEventListener("click", ()=> randomizeSoundsOnly());
    E.btnRandLimit.addEventListener("click", ()=> randomizeLimitersOnly());

    // locks
    E.lockProgMini.addEventListener("click", ()=>{
      state.lockProg = !state.lockProg;
      syncLocksUI();
      saveAll();
    });
    E.lockStyleMini.addEventListener("click", ()=>{
      state.lockStyle = !state.lockStyle;
      syncLocksUI();
      saveAll();
    });
    E.lockThemeMini.addEventListener("click", ()=>{
      state.lockTheme = !state.lockTheme;
      syncLocksUI();
      saveAll();
    });
    E.lockTimeMini.addEventListener("click", ()=>{
      state.lockTime = !state.lockTime;
      syncLocksUI();
      saveAll();
    });
    E.lockSoundMini.addEventListener("click", ()=>{
      state.lockSounds = !state.lockSounds;
      syncLocksUI();
      saveAll();
    });
    E.lockLimitMini.addEventListener("click", ()=>{
      state.lockLimiters = !state.lockLimiters;
      syncLocksUI();
      saveAll();
    });

    // edit mode toggle
    E.btnEdit.addEventListener("click", ()=>{
      state.editMode = !state.editMode;
      applyEditVisuals();
      saveAll();
    });

    // edit modal actions
    E.btnEditClose.addEventListener("click", ()=> closeEdit());
    E.btnEditCancel.addEventListener("click", ()=> closeEdit());
    E.btnEditApply.addEventListener("click", ()=> applyEdit());
    E.btnEditClear.addEventListener("click", ()=> clearEdit());
    E.editBack.addEventListener("click", (ev)=>{
      if (ev.target === E.editBack) closeEdit();
    });

    // advanced modal open/close
    E.btnGear.addEventListener("click", ()=>{
      E.advBack.style.display = "flex";
      renderOrderList();
    });
    E.btnCloseAdv.addEventListener("click", ()=>{
      E.advBack.style.display = "none";
      saveAll();
    });
    E.btnResetMenu.addEventListener("click", ()=> resetDefaultOrder());
    E.advBack.addEventListener("click", (ev)=>{
      if (ev.target === E.advBack) E.advBack.style.display = "none";
    });
  }

  /* ---------- Init ---------- */
  function boot(){
    initFeelDropdowns();
    initLogicDropdown();
    initGenreDropdown();
    initThemeDropdowns();
    initPianoThemeDropdown();
    initEditDropdowns();

    loadOrder();

    const loaded = loadAll();
    // defaults for ‚Äúall menus collapsed‚Äù: details are collapsed by default in markup
    // set theme
    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);
    applyMorphBg(state.morphBg);

    // hydrate UI
    syncUIFromState();
    assignChordModesWithLimit(state.chartBars);

    // if no saved chart, generate a default
    if (!loaded || !Array.isArray(state.chartBars) || state.chartBars.length===0){
      generateChart();
    } else {
      renderAll();
    }

    bindUI();
    updateUndoRedoButtons();
  }

  boot();

})();
</script>
</body>
</html>
