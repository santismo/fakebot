<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover"/>
  <title>ü§ñ fakebot</title>

  <script src="https://cdn.jsdelivr.net/npm/js-synthesizer@1.11.0/externals/libfluidsynth-2.4.6.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/js-synthesizer@1.11.0/dist/js-synthesizer.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/vexflow@3.0.9/releases/vexflow-min.js"></script>

  <style>
    :root{
      /* Page theme vars */
      --pageBg:#0b0f14;
      --pageInk:#e9eef6;
      --pageMuted:#9aa6b2;
      --pageLine:rgba(255,255,255,.09);
      --pagePanel:rgba(255,255,255,.05);
      --pagePanel2:rgba(0,0,0,.20);

      --pageGlowA: rgba(122,162,255,.08);
      --pageGlowB: rgba(182,124,255,.08);
      --pageGlowC: rgba(63,225,139,.06);

      /* Morphing gradient (default ON) */
      --morphOn: 1; /* 1=on, 0=off */
      --morphA: rgba(60,180,255,.22);
      --morphB: rgba(255,90,220,.18);
      --morphC: rgba(90,255,170,.16);
      --morphD: rgba(255,210,120,.14);

      /* Piano theme */
      --accent:#2f6bff;  /* scale fill */
      --good:#3fe18b;    /* root marker */
      --chord:#b67cff;   /* chord marker */
      --melody:#ff4b4b;  /* melody highlight */

      --fretWood:#2a1a12;
      --fretLine: rgba(255,255,255,.20);
      --fretLineStrong: rgba(255,255,255,.55);
      --fretInlay: rgba(255,255,255,.65);
      --stringColor: rgba(255,255,255,.70);

      --keyWhite:#f2f5fb;
      --keyBlack:#161b23;
      --keyBorder:#c9d3e2;
      --keyBlackBorder:#2a3240;
      --keyBorderStrong: rgba(0,0,0,.35);

      /* Fixed thin black outline for scale keys */
      --scaleStrokeAlpha: 0.88;
      --scaleStrokeWidth: 2.2;

      --radius:16px;
      --tap:44px;
      --shadow: 0 12px 30px rgba(0,0,0,.35);
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      color:var(--pageInk);
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      -webkit-font-smoothing: antialiased;
      overflow-x:hidden;
      touch-action: manipulation;
      background: var(--pageBg);
    }

    /* Base glows */
    body::before{
      content:"";
      position:fixed;
      inset:0;
      z-index:-2;
      background:
        radial-gradient(1200px 800px at 30% 10%, var(--pageGlowA), transparent 55%),
        radial-gradient(900px 600px at 90% 30%, var(--pageGlowB), transparent 55%),
        radial-gradient(1100px 700px at 55% 95%, var(--pageGlowC), transparent 60%),
        linear-gradient(180deg, var(--pageBg), var(--pageBg));
      background-repeat:no-repeat;
    }

    /* Morphing gradient overlay (toggleable) */
    body::after{
      content:"";
      position:fixed;
      inset:-60px;
      z-index:-1;
      pointer-events:none;
      opacity: calc(var(--morphOn) * 0.95);
      background:
        radial-gradient(1200px 800px at 15% 20%, var(--morphA), transparent 62%),
        radial-gradient(1100px 700px at 80% 25%, var(--morphB), transparent 62%),
        radial-gradient(1200px 850px at 60% 85%, var(--morphC), transparent 62%),
        radial-gradient(900px 600px at 25% 80%, var(--morphD), transparent 62%);
      background-size: 200% 200%;
      filter: blur(12px) saturate(1.2);
      transform: translateZ(0);
      animation: morphMove 22s ease-in-out infinite;
      mix-blend-mode: screen;
    }
    @keyframes morphMove{
      0%   { background-position: 0% 20%; transform: translate3d(-18px,-12px,0) scale(1.06); }
      50%  { background-position: 100% 60%; transform: translate3d(22px,16px,0) scale(1.1); }
      100% { background-position: 0% 20%; transform: translate3d(-18px,-12px,0) scale(1.06); }
    }

    button, input, select, label {font:inherit}
    button { -webkit-tap-highlight-color: transparent; }
    input[type="range"]{width:100%}
    .app{max-width:1100px;margin:0 auto;padding:14px 12px 22px;}

    .card{
      border:1px solid var(--pageLine);border-radius: var(--radius);
      background: var(--pagePanel);box-shadow: var(--shadow);
      overflow:hidden;margin-bottom:12px;
    }
    .cardHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;flex-wrap:wrap;
      padding:12px 12px;border-bottom:1px solid rgba(255,255,255,.06);
      background: rgba(0,0,0,.12);
    }
    .title{font-size:12px;color:var(--pageMuted);letter-spacing:.2px;user-select:none;}
    .cardBody{padding:12px}

    h1{margin:0;font-size:18px;font-weight:900;letter-spacing:.2px;}
    .sub{margin-top:2px;color:var(--pageMuted);font-size:12px;}
    .msg{margin-top:10px;font-size:12px;color: var(--pageMuted);user-select:none;}
    .row{display:flex;gap:10px;flex-wrap:wrap;align-items:center;}
    .grow{flex:1;min-width:220px}
    .miniStat{
      display:inline-flex;align-items:center;gap:8px;
      padding:8px 10px;border:1px solid var(--pageLine);border-radius:999px;
      background: rgba(0,0,0,.18);color: var(--pageMuted);font-size:12px;
      user-select:none;white-space:nowrap;
    }
    .miniStat strong{color:var(--pageInk);font-weight:900}

    .btn{
      min-height: var(--tap);
      padding: 10px 12px;border-radius: 12px;
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      color: var(--pageInk);cursor:pointer;
      display:inline-flex;align-items:center;justify-content:center;gap:8px;
      transition: transform .06s ease, border-color .15s ease,width .15s ease, opacity .15s ease;
      user-select:none;
    }
    .btn:active{transform: translateY(1px)}
    .btn.primary{
      border-color: rgba(122,162,255,.45);
      background: linear-gradient(180deg, rgba(122,162,255,.18), rgba(122,162,255,.06));
    }
    .btn.ghost{background: transparent}
    .btn.small{min-height:36px;padding:7px 8px;border-radius:10px;font-size:13px}
    .btn.tiny{min-height:34px;padding:6px 8px;border-radius:10px;font-size:12px}
    .btn:disabled{opacity:.45;cursor:not-allowed;transform:none}
    .btnRow{display:flex;gap:8px;flex-wrap:wrap}
    .btnRow .btn{flex:1;min-width:120px}
    .compactSlider{
      flex:0 0 110px;
      min-width:80px;
      max-width:120px;
      display:flex;
      align-items:center;
    }
    .compactSlider input[type="range"]{width:100%}

    .iconBtn{
      min-height:30px;
      min-width:32px;
      padding:4px 6px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.12);
      background: rgba(0,0,0,.20);
      color: var(--pageInk);
      display:inline-flex;align-items:center;justify-content:center;
      cursor:pointer;user-select:none;
    }
    .iconBtn.on{
      border-color: rgba(63,225,139,.45);
      background: linear-gradient(180deg, rgba(63,225,139,.14), rgba(0,0,0,.12));
    }
    .fretBox{
      border:1px solid rgba(255,255,255,.10);
      border-radius:16px;
      background: var(--fretWood);
      overflow:hidden;
    }
    .fileInput{
      width:100%;
      min-height:38px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: var(--pageInk);
      padding:8px;
    }
    .textInput{
      width:100%;
      min-height:38px;
      border-radius:10px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.25);
      color: var(--pageInk);
      padding:8px;
    }
    .songList{
      margin-top:10px;
      display:flex;
      flex-direction:column;
      gap:8px;
      max-height:260px;
      overflow:auto;
      padding:6px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.18);
    }
    .songRow{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      padding:8px 10px;
      border:1px solid rgba(255,255,255,.08);
      border-radius:12px;
      background: rgba(0,0,0,.18);
    }
    .songMeta{min-width:0;}
    .songTitle{font-weight:800;font-size:13px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .songSub{font-size:12px;color:var(--pageMuted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis;}
    .songRandomLabel{
      display:flex;
      align-items:center;
      min-height:34px;
      padding:6px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.20);
      color: var(--pageMuted);
      font-size:12px;
      line-height:1;
      flex:1;
      min-width:120px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .songRandomLabel.loaded{
      color: var(--pageInk);
      border-color: rgba(122,162,255,.35);
      background: rgba(122,162,255,.12);
    }

    /* Title bar button alignment */
    #cardHeader .btnRow{justify-content:center;}
    #cardHeader .btnRow .btn{flex:0 1 auto;min-width:clamp(56px, 16vw, 92px); padding:8px 12px;}
    #cardHeader .cardBody > .row{justify-content:center;}
    #cardHeader .cardBody > .row > .grow{flex:1 1 100%;max-width:760px;}
    #cardHeader .cardBody > .row > .grow:last-child{display:flex;flex-direction:column;align-items:center;}

    /* Lead sheet */
    .sheet{display:grid;grid-template-columns: repeat(4, minmax(0, 1fr));gap:10px;}
    @media (max-width: 640px){
      .sheet{grid-template-columns: repeat(4, minmax(0, 1fr));}
      .bar{min-height:54px;padding:9px 6px 7px;}
      .bar .sym{font-size:11px;line-height:1.05;padding-right:16px;letter-spacing:-0.1px;}
      .bar .sym2{font-size:10px;line-height:1.05;}
      .bar .num{font-size:8px;gap:2px;top:7px;right:7px;}
      .repeatGlyph{font-size:8px;}
    }
    .melodyWrap{
      margin-top:10px;
      border-top:1px solid rgba(255,255,255,.08);
      padding-top:10px;
      display:none;
    }
    .melodyWrap.on{display:block;}
    .melodyHead{display:flex;align-items:center;justify-content:space-between;gap:10px;}
    .melodySheet{width:100%;overflow-x:auto;padding:6px 4px 2px;}
    .melodyEmpty{font-size:12px;color:var(--pageMuted);padding:6px 4px;}
    .melodyRow{margin-bottom:8px;}

    .biabSheet{
      background:#ffffff;
      color:#111111;
      border-radius:12px;
      padding:10px;
      border:1px solid rgba(0,0,0,.12);
    }
    .biabRow{margin-bottom:12px;}
    .biabChords{
      display:grid;
      gap:6px;
      margin:0 0 6px 0;
      font-size:13px;
      font-weight:700;
      color:#111111;
    }
    .biabChordCell{
      display:grid;
      gap:4px;
      text-align:left;
      justify-items:start;
      padding:2px 4px 6px;
      border-bottom:1px solid rgba(0,0,0,.12);
    }
    .biabChordSlot{
      font-weight:700;
      font-size:12px;
      color:#111111;
    }
    .biabChordSlot.empty{
      color:transparent;
    }
    .biabSvg{background:#ffffff;}

    .bar{
      position:relative;min-height: 62px;background: rgba(0,0,0,.22);
      border:1px solid rgba(255,255,255,.08);border-radius: 14px;
      padding: 12px 10px 10px;cursor:pointer;
      transition: border-color .15s ease, transform .06s ease, background .15s ease;
      overflow:hidden;user-select:none;
    }
    .bar:active{transform: translateY(1px)}
    .bar.active{border-color: rgba(122,162,255,.70);background: rgba(122,162,255,.08);}
    .bar.editing{border-color: rgba(63,225,139,.55);background: rgba(63,225,139,.06);}
    .bar .sym{font-weight:900;letter-spacing:.2px;font-size:16px;line-height:1.15;white-space:nowrap;overflow:hidden;text-overflow:clip;padding-right:28px;}
    .bar .sym2{margin-top:6px;padding-top:6px;border-top:1px solid rgba(255,255,255,.08);}
    .bar .num{position:absolute;top:10px;right:10px;font-size:12px;color: rgba(154,166,178,.55);display:flex;align-items:center;gap:4px;}

    .repeatGlyph{
      font-size:12px;
      line-height:1;
      color: var(--pageMuted);
      font-family: "Noto Music", "Noto Sans Symbols2", "Segoe UI Symbol", "Apple Symbols", system-ui;
      user-select:none;
      pointer-events:none;
    }

    .bar .halfHit{
      position:absolute; inset:0;
      display:flex; flex-direction:column;
      pointer-events:none;
    }
    .bar .halfHit button{
      flex:1;background:transparent;border:0;padding:0;margin:0;cursor:pointer;pointer-events:auto;
    }
    .bar .halfHit button:active{background: rgba(122,162,255,.06);}
    .bar .halfHit button:first-child{border-bottom:1px solid rgba(255,255,255,.06);}

    /* Piano */
    .legend{display:flex;gap:10px;flex-wrap:wrap;align-items:center;color: var(--pageMuted);font-size:12px;user-select:none;margin-bottom:10px;}
    .dotLegend{display:inline-flex;align-items:center;gap:6px;}
    .sw{width:10px;height:10px;border-radius:999px;border:1px solid rgba(255,255,255,.15);}
    .sw.scale{background: var(--accent); border-color: rgba(47,107,255,.95)}
    .sw.root{background: var(--good); border-color: rgba(63,225,139,.95)}
    .sw.chord{background: var(--chord); border-color: rgba(182,124,255,.95)}
    .sw.melody{background: var(--melody); border-color: rgba(255,75,75,.9)}
    .pianoBox{border:1px solid rgba(255,255,255,.10);border-radius: 16px;background: rgba(0,0,0,.18);overflow:hidden;}
    svg{display:block;width:100%;height:auto}
    .hint{margin-top:10px;color: rgba(154,166,178,.85);font-size:12px;line-height:1.2;user-select:none;}

    /* Collapsible groups (Controls + Limiters) */
    details.group{
      border:1px solid rgba(255,255,255,.08);
      background: rgba(0,0,0,.18);
      border-radius:14px;
      overflow:hidden;
      margin-bottom:10px;
    }
    details.group > summary{
      list-style:none;
      cursor:pointer;
      padding:12px 12px;
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      user-select:none;
      background: rgba(255,255,255,.03);
    }
    details.group > summary::-webkit-details-marker{display:none}
    .sumLeft{display:flex;align-items:center;gap:10px;min-width:0}
    .sumTitle{font-weight:900;font-size:13px;color:rgba(233,238,246,.92);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .sumSub{font-size:12px;color:var(--pageMuted);white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
    .chev{font-size:12px;color:var(--pageMuted); transition: transform .15s ease;}
    details[open] .chev{transform:rotate(180deg)}
    .groupBody{padding:12px}

    /* Controls grid inside groups */
    .controls{display:grid;grid-template-columns: repeat(6, minmax(0,1fr));gap:10px;}
    @media (max-width: 980px){ .controls{grid-template-columns: repeat(3, minmax(0,1fr));} }
    @media (max-width: 520px){ .controls{grid-template-columns: repeat(2, minmax(0,1fr));} }
    .control{
      padding:10px;border-radius:14px;border:1px solid rgba(255,255,255,.08);
      background: var(--pagePanel2);min-width:0;
    }
    .control label{display:block;font-size:11px;color: rgba(154,166,178,.88);margin-bottom:6px;user-select:none;}
    .inline{display:flex;align-items:center;gap:8px;min-width:0;}
    input[type="number"], select{
      width: 98px;min-height: 38px;background: rgba(0,0,0,.25);
      border:1px solid rgba(255,255,255,.10);color: var(--pageInk);
      border-radius: 10px;padding: 8px 8px;outline:none;
    }
    select{width:100%}

    .checkRow{display:flex;flex-wrap:wrap;gap:8px;align-items:center;}
    .chip{
      display:inline-flex;align-items:center;gap:8px;padding:10px 10px;border-radius: 14px;
      border:1px solid rgba(255,255,255,.08);background: rgba(0,0,0,.18);
      min-height: 44px;user-select:none;
    }
    .chip input{transform: scale(1.1)}
    .chip span{font-size:13px;color: rgba(233,238,246,.92)}

    /* Advanced settings modal */
    .modalBack{
      position:fixed;inset:0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:14px;
      z-index:9999;
    }
    .modal{
      width:min(860px,100%);
      border:1px solid rgba(255,255,255,.14);
      border-radius: 18px;
      background: rgba(12,16,22,.96);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
      display:flex;
      flex-direction:column;
      max-height: calc(100vh - 28px);
    }
    .modalHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:12px 12px;
      border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .modalTitle{font-weight:900;font-size:14px;letter-spacing:.2px;}
    .modalBody{
      padding:12px;
      overflow:auto;
      min-height:0;
      -webkit-overflow-scrolling: touch;
    }
    .modalRow{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:10px 10px;border:1px solid rgba(255,255,255,.08);
      border-radius:14px;background: rgba(0,0,0,.22);
      margin-bottom:10px;
    }
    .modalRow .name{font-size:13px;color: rgba(233,238,246,.92);font-weight:800}
    .reorderBtns{display:flex;gap:8px;flex-wrap:wrap}
    .gearBtn{
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      border-radius: 12px;
      min-height: 38px;
      padding:8px 10px;
      cursor:pointer;
      color: var(--pageInk);
      display:inline-flex;align-items:center;gap:8px;
      user-select:none;
    }
    .splitLine{height:1px;background: rgba(255,255,255,.10);margin:12px 0;}
    .modalSubTitle{font-size:12px;color: var(--pageMuted);margin:0 0 8px 2px;}
    .modalGrid{display:grid;grid-template-columns: 1fr 1fr; gap:10px;}
    @media (max-width: 560px){ .modalGrid{grid-template-columns: 1fr;} }
    .miniCtl{
      border:1px solid rgba(255,255,255,.08);
      border-radius:14px;
      background: rgba(0,0,0,.22);
      padding:10px;
    }
    .miniCtl label{display:block;font-size:11px;color: rgba(154,166,178,.88);margin-bottom:6px;}
    .miniRow{display:flex;gap:8px;align-items:center;}
    .miniRow input[type="range"]{flex:1}
    .miniRow input[type="number"]{width:86px}

    /* Lock buttons: per-area, emoji toggles */
    .lockMini{
      min-height:34px;
      padding:6px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.10);
      background: rgba(0,0,0,.18);
      color: var(--pageInk);
      cursor:pointer;
      user-select:none;
      display:inline-flex;align-items:center;gap:8px;
      font-size:12px;
      white-space:nowrap;
    }
    .lockMini.on{
      border-color: rgba(63,225,139,.45);
      background: linear-gradient(180deg, rgba(63,225,139,.14), rgba(0,0,0,.12));
    }
    .lockMini b{font-weight:900}

    /* Edit chord modal */
    .editModalBack{
      position:fixed; inset:0;
      background: rgba(0,0,0,.62);
      display:none;
      align-items:flex-end;
      justify-content:center;
      padding:14px;
      z-index:10000;
    }
    .editModal{
      width:min(860px,100%);
      border:1px solid rgba(255,255,255,.14);
      border-radius:18px;
      background: rgba(12,16,22,.97);
      box-shadow: 0 20px 60px rgba(0,0,0,.55);
      overflow:hidden;
    }
    .editHead{
      display:flex;align-items:center;justify-content:space-between;gap:10px;
      padding:12px 12px;border-bottom:1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
    }
    .editTitle{font-weight:900;font-size:14px;}
    .editBody{padding:12px}
    .editGrid{display:grid;grid-template-columns: repeat(2, minmax(0,1fr)); gap:10px;}
    @media (max-width: 560px){ .editGrid{grid-template-columns: 1fr;} }
    .editNote{margin:10px 0 0 0;color:var(--pageMuted);font-size:12px;}
    .editActions{display:flex;gap:8px;flex-wrap:wrap;margin-top:12px;}
    .editActions .btn{flex:1;min-width:140px;}
  </style>
</head>

<body>
  <div class="app">

    <!-- TITLE BAR -->
    <section class="card" id="cardHeader" data-section="header">
      <div class="cardHead">
        <div class="title">ü§ñ</div>
        <button class="gearBtn" id="btnGear" aria-label="Advanced settings" title="Advanced settings">
          ‚öôÔ∏è <span style="font-size:12px;color:var(--pageMuted);"> </span>
        </button>
      </div>
      <div class="cardBody">
        <div class="row">
          <div class="grow">
            <div class="sub"> </div>
            <div class="msg" id="msg"> </div>
          </div>

          <div class="grow" style="min-width:260px">
            <div class="btnRow">
              <button class="btn tiny" id="btnCopy" title="Copy chart">üìã</button>
              <button class="btn tiny" id="btnStyleRand" title="Randomize style (keeps progression)">üé®</button>
              <button class="btn primary tiny" id="btnPlay" title="Play / Pause">‚ñ∂Ô∏è</button>
            </div>
            <div class="btnRow" style="margin-top:8px">
              <button class="btn tiny" id="btnGenerate" title="Generate new chart">üé∞</button>
              <button class="btn tiny" id="btnRandomAll" title="Randomize everything">üé≤</button>
              <button class="btn tiny" id="btnDefaults" title="Defaults">üîÑ</button>
            </div>

            <div class="btnRow" style="margin-top:8px">
              <button class="btn tiny" id="btnUndo" title="Undo (up to 5)">‚Ü©Ô∏è</button>
              <div class="compactSlider" title="Complexity">
                <input id="complexity" type="range" min="0" max="100" value="45" aria-label="Complexity">
              </div>
              <button class="btn tiny" id="btnRedo" title="Redo">‚Ü™Ô∏è</button>
            </div>
            <div class="msg" id="complexityMsg" style="margin-top:6px;display:none;"> </div>

            <div class="row" style="margin-top:10px">
              <span class="miniStat" id="pillLine">‚Äî</span>
              <span class="miniStat">Focused: <strong id="focusLine">‚Äî</strong></span>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- DEFAULT ORDER: title bar, piano, lead sheet, control, limiters -->

    <!-- PIANO -->
    <section class="card" id="cardPiano" data-section="piano">
      <div class="cardHead">
        <div class="row" style="gap:6px;align-items:center;">
          <button class="iconBtn" id="btnPianoToggle" type="button" aria-label="Show piano view" title="Show piano view">üéπ</button>
          <button class="iconBtn" id="btnFretToggle" type="button" aria-label="Show fretboard view" title="Show fretboard view">üé∏</button>
        </div>
        <div class="title" id="pianoTop">‚Äî</div>
      </div>
      <div class="cardBody">
        <div class="legend">
          <span class="dotLegend"><span class="sw scale"></span>Scale</span>
          <span class="dotLegend"><span class="sw root"></span>Root</span>
          <span class="dotLegend"><span class="sw chord"></span>Chord</span>
          <span class="dotLegend"><span class="sw melody"></span>Melody</span>
        </div>
        <div class="pianoBox" id="pianoBox">
          <svg id="pianoSvg" viewBox="0 0 1000 240" preserveAspectRatio="none" aria-label="Piano keyboard"></svg>
        </div>
        <div class="fretBox" id="fretBox" style="display:none;">
          <svg id="fretSvg" viewBox="0 0 1000 240" preserveAspectRatio="none" aria-label="Guitar fretboard"></svg>
        </div>
        <div class="hint" id="pianoHint">‚Äî</div>
      </div>
    </section>

    <!-- LEAD SHEET -->
    <section class="card" id="cardLead" data-section="lead">
      <div class="cardHead">
        <div class="row" style="gap:8px;align-items:center;">
          <div class="title">üéº</div>
          <button class="btn tiny" id="btnEdit" title="Edit chart">‚úèÔ∏è</button>
        </div>
        <div class="title" id="leadKey">‚Äî</div>
      </div>
      <div class="cardBody">
        <div class="sheet" id="sheet"></div>
        <div class="melodyWrap" id="melodyWrap">
          <div class="melodyHead">
            <div class="title">Lead Sheet + Melody (BIAB)</div>
            <div class="msg" id="melodyStatus">No BIAB melody loaded.</div>
          </div>
          <div class="melodySheet" id="melodySheet"></div>
        </div>
        <div class="msg" id="editHint" style="display:none;margin-top:10px;">
          Edit mode ON: tap a bar (or half) to change that chord. Use ‚ÄúClear‚Äù to remove it.
        </div>
      </div>
    </section>

    <!-- Controls -->
    <section class="card" id="cardControls" data-section="controls">
      <div class="cardHead">
        <div class="title">üéõÔ∏è</div>
        <div class="title"> </div>
      </div>
      <div class="cardBody">

        <details class="group" id="grpGen">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Generate</div>
                <div class="sumSub"> </div>
              </div>
              <div class="row" style="gap:8px;">
                <button class="lockMini" id="lockProgMini" type="button" title="Lock progression so Generate/Random won't change it">üîì</button>
                <button class="btn tiny" id="btnRandGen" type="button" title="Randomize only generator controls (respects locks)">üé≤</button>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">
              <div class="control">
                <label>Progression logic</label>
                <select id="progressionLogic"></select>
                <div class="msg" style="margin:6px 0 0 0;"> </div>
              </div>

              <div class="control">
                <label>Genre preset</label>
                <select id="genrePreset"></select>
              </div>

              <div class="control">
                <label>Scales used (1‚Äì32)</label>
                <div class="checkRow" style="margin-bottom:8px;">
                  <label class="chip" style="width:100%;justify-content:space-between;">
                    <span>Limit</span>
                    <input type="checkbox" id="scaleLimitEnabled" checked>
                  </label>
                </div>
                <div class="inline">
                  <input id="scalesUsed" type="range" min="1" max="32" value="8">
                  <input id="scalesUsedNum" type="number" min="1" max="32" value="8">
                </div>
                <div class="msg" id="scalesUsedMsg" style="margin:6px 0 0 0;"> </div>
              </div>

            </div>
          </div>
        </details>

                <details class="group" id="grpSongs">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Songs</div>
                <div class="sumSub"> </div>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">
              <div class="control" style="grid-column: 1 / -1;">
                <div class="msg" id="songStatus" style="margin:0;">Loading playlist...</div>
              </div>
              <div class="control">
                <label>Search</label>
                <input class="textInput" type="text" id="songSearch" placeholder="Title or composer">
              </div>
              <div class="control">
                <label>Sort</label>
                <select id="songSort">
                  <option value="playlist" selected>Playlist order</option>
                  <option value="style">Style</option>
                  <option value="az">A‚ÄìZ</option>
                </select>
              </div>
              <div class="control">
                <label>Random</label>
                <div class="row" style="gap:8px;">
                  <button class="btn tiny" id="btnSongRandom" type="button">Load random song</button>
                  <div class="songRandomLabel" id="songRandomLabel">No song loaded</div>
                </div>
              </div>
              <div class="control" style="grid-column: 1 / -1;">
                <label>BIAB upload (.mgu/.sgu/.mg1/.sg1...)</label>
                <input class="fileInput" type="file" id="biabFile" accept=".mgu,.sgu,.mg1,.sg1,.mg2,.sg2,.mg3,.sg3,.mg4,.sg4,.mg5,.sg5,application/octet-stream">
                <div class="msg" id="biabStatus"> </div>
              </div>
              <div class="control" style="grid-column: 1 / -1;">
                <div class="songList" id="songList"></div>
              </div>
            </div>
          </div>
        </details>


        <details class="group" id="grpTime">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Timing + Form</div>
                <div class="sumSub"> </div>
              </div>
              <div class="row" style="gap:8px;">
                <button class="lockMini" id="lockTimeMini" type="button" title="Lock timing so Random won't change it">üîì</button>
                <button class="btn tiny" id="btnRandTime" type="button" title="Randomize timing/form only (respects locks)">üé≤</button>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">

              <div class="control">
                <label>Bars (2‚Äì32)</label>
                <div class="inline">
                  <input id="bars" type="range" min="2" max="32" value="8">
                  <input id="barsNum" type="number" min="2" max="32" value="8">
                </div>
              </div>

              <div class="control">
                <label>2 chords / bar (random bars)</label>
                <div class="checkRow" style="margin-bottom:8px;">
                  <label class="chip" style="width:100%;justify-content:space-between;">
                    <span>Enable occasional ¬Ω-bars</span>
                    <input type="checkbox" id="halfChords">
                  </label>
                </div>
                <div class="inline">
                  <input id="halfDensity" type="range" min="0" max="100" value="22">
                  <input id="halfDensityNum" type="number" min="0" max="100" value="22">
                </div>
                <div class="msg" style="margin:6px 0 0 0;">Density %</div>
              </div>

              <div class="control">
                <label>Tempo</label>
                <div class="inline">
                  <input id="tempo" type="range" min="60" max="220" value="140">
                  <input id="tempoNum" type="number" min="40" max="300" value="140">
                </div>
              </div>

              <div class="control">
                <label>Swing</label>
                <div class="inline">
                  <input id="swing" type="range" min="50" max="75" value="58">
                  <input id="swingNum" type="number" min="50" max="80" value="58">
                </div>
              </div>

            </div>
          </div>
        </details>

        <details class="group" id="grpFeel">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Feel</div>
                <div class="sumSub"> </div>
              </div>
              <div class="row" style="gap:8px;">
                <button class="lockMini" id="lockStyleMini" type="button" title="Lock play style so Style/Random won't change it">üîì</button>
                <button class="btn tiny" id="btnRandFeel" type="button" title="Randomize feel (respects locks)">üé≤</button>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">

              <div class="control">
                <label>Chaos</label>
                <div class="inline">
                  <input id="chaos" type="range" min="0" max="100" value="35">
                  <input id="chaosNum" type="number" min="0" max="100" value="35">
                </div>
                <div class="msg" style="margin:6px 0 0 0;"> </div>
              </div>

              <div class="control">
                <label>Root mode</label>
                <select id="rootMode">
                  <option value="keyed" selected>Keyed</option>
                  <option value="drifting">Drifting</option>
                  <option value="orbiting">Orbiting</option>
                  <option value="freefall">Freefall</option>
                </select>
              </div>

              <div class="control">
                <label>Groove (drums)</label>
                <select id="grooveStyle"></select>
              </div>

              <div class="control">
                <label>Keys play style</label>
                <select id="compStyle"></select>
              </div>

            </div>
          </div>
        </details>

        <details class="group" id="grpSounds">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Sounds + Fill / Complexity</div>
                <div class="sumSub"> </div>
              </div>
              <div class="row" style="gap:8px;">
                <button class="lockMini" id="lockSoundMini" type="button" title="Lock sounds so Style/Random won't change them">üîì</button>
                <button class="btn tiny" id="btnRandSounds" type="button" title="Randomize sounds/mix only (respects locks)">üé≤</button>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="controls">

              <div class="control">
                <label>SoundFont engine</label>
                <label class="chip" style="width:100%;justify-content:space-between;margin:0;">
                  <span>Enable SoundFont</span>
                  <input type="checkbox" id="sfEnabled" checked>
                </label>
              </div>

              <div class="control">
                <label>Bass sound (minimal)</label>
                <select id="bassPreset">
                  <option value="upright" selected>Upright</option>
                  <option value="contra">Contra</option>
                  <option value="fretless">Fretless</option>
                  <option value="pizz">Pizz</option>
                  <option value="round">Round</option>
                  <option value="sub">Sub</option>
                  <option value="pluck">Pluck</option>
                  <option value="pickBass">Pick bass</option>
                  <option value="muted">Muted</option>
                  <option value="fmBass">FM bass</option>
                  <option value="rubber">Rubber</option>
                  <option value="acid">Acid</option>
                  <option value="reese">Reese</option>
                  <option value="squareBass">Square bass</option>
                  <option value="wobble">Wobble</option>
                  <option value="mono">Mono synth</option>
                </select>
              </div>

              <div class="control">
                <label>Keys sound (minimal)</label>
                <select id="keysPreset">
                  <option value="ep" selected>EP</option>
                  <option value="piano">Piano</option>
                  <option value="organ">Organ</option>
                  <option value="harpsichord">Harpsichord</option>
                  <option value="accordion">Accordion</option>
                  <option value="strings">Strings</option>
                  <option value="pad">Pad</option>
                  <option value="choirPad">Choir pad</option>
                  <option value="noisePad">Noise pad</option>
                  <option value="fm">FM keys</option>
                  <option value="chip">Chip</option>
                  <option value="bell">Bell</option>
                  <option value="glass">Glass</option>
                  <option value="celesta">Celesta</option>
                  <option value="vibes">Vibes</option>
                  <option value="marimba">Marimba</option>
                  <option value="harp">Harp</option>
                  <option value="pluck2">Pluck 2</option>
                  <option value="guitarish">Guitar-ish</option>
                  <option value="clavBright">Clav bright</option>
                </select>
              </div>

              <div class="control">
                <label>Drums sound (minimal)</label>
                <select id="drumsPreset">
                  <option value="jazz" selected>Jazz kit</option>
                  <option value="swing">Swing kit</option>
                  <option value="shuffle">Shuffle kit</option>
                  <option value="brushes">Brushes</option>
                  <option value="tight">Tight</option>
                  <option value="rock">Rock kit</option>
                  <option value="room">Room kit</option>
                  <option value="disco">Disco kit</option>
                  <option value="lofi">Lo-fi</option>
                  <option value="minimal">Minimal clicks</option>
                  <option value="ambient">Ambient</option>
                  <option value="electro">Electro</option>
                  <option value="analog">Analog</option>
                  <option value="house">House</option>
                  <option value="trap">Trap hats</option>
                  <option value="breaks">Breaks</option>
                  <option value="dnb">DnB kit</option>
                  <option value="techno">Techno kit</option>
                  <option value="boomBap">Boom-bap</option>
                  <option value="perc">Perc kit</option>
                  <option value="latinKit">Latin kit</option>
                  <option value="orchestral">Orchestral</option>
                  <option value="free">Free</option>
                </select>
              </div>

              <div class="control">
                <label>Drums level</label>
                <div class="inline">
                  <input id="drumsLevel" type="range" min="0" max="100" value="55">
                  <input id="drumsLevelNum" type="number" min="0" max="100" value="55">
                </div>
              </div>

              <div class="control">
                <label>Keys: complexity / fills</label>
                <div class="inline" style="margin-bottom:8px;">
                  <input id="keysComplex" type="range" min="0" max="100" value="55">
                  <input id="keysComplexNum" type="number" min="0" max="100" value="55">
                </div>
                <div class="inline">
                  <input id="keysFill" type="range" min="0" max="100" value="30">
                  <input id="keysFillNum" type="number" min="0" max="100" value="30">
                </div>
              </div>

              <div class="control">
                <label>Bass: complexity / fills</label>
                <div class="inline" style="margin-bottom:8px;">
                  <input id="bassComplex" type="range" min="0" max="100" value="55">
                  <input id="bassComplexNum" type="number" min="0" max="100" value="55">
                </div>
                <div class="inline">
                  <input id="bassFill" type="range" min="0" max="100" value="25">
                  <input id="bassFillNum" type="number" min="0" max="100" value="25">
                </div>
              </div>

              <div class="control">
                <label>Drums: complexity / fills</label>
                <div class="inline" style="margin-bottom:8px;">
                  <input id="drumsComplex" type="range" min="0" max="100" value="65">
                  <input id="drumsComplexNum" type="number" min="0" max="100" value="65">
                </div>
                <div class="inline">
                  <input id="drumsFill" type="range" min="0" max="100" value="40">
                  <input id="drumsFillNum" type="number" min="0" max="100" value="40">
                </div>
              </div>

            </div>
          </div>
        </details>

      </div>
    </section>

    <!-- CHORD LIMITERS -->
    <section class="card" id="cardLimiters" data-section="limiters">
      <div class="cardHead">
        <div class="row" style="gap:8px;align-items:center;">
          <div class="title">üé∂</div>
          <button class="lockMini" id="lockLimitMini" type="button" title="Lock limiters so Random won't change them">üîì</button>
          <button class="btn tiny" id="btnRandLimit" type="button" title="Randomize limiters only (respects locks)">üé≤</button>
        </div>
        <div class="title"> </div>
      </div>
      <div class="cardBody">

        <details class="group" id="limQual">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Core qualities</div>
                <div class="sumSub"> </div>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="qMaj7" checked><span>maj7</span></label>
              <label class="chip"><input type="checkbox" id="qMin7" checked><span>m7</span></label>
              <label class="chip"><input type="checkbox" id="qDom7" checked><span>7</span></label>
              <label class="chip"><input type="checkbox" id="qDim7" checked><span>dim7</span></label>
              <label class="chip"><input type="checkbox" id="qHalfDim"><span>√∏7</span></label>
              <label class="chip"><input type="checkbox" id="qSus"><span>sus</span></label>
              <label class="chip"><input type="checkbox" id="qMinMaj"><span>mMaj7</span></label>
            </div>
          </div>
        </details>

        <details class="group" id="limExt">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Extensions</div>
                <div class="sumSub"> </div>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="x9"><span>9</span></label>
              <label class="chip"><input type="checkbox" id="x11"><span>11</span></label>
              <label class="chip"><input type="checkbox" id="x13"><span>13</span></label>
              <label class="chip"><input type="checkbox" id="x6"><span>6 / 6-9</span></label>
              <label class="chip"><input type="checkbox" id="xAdd9"><span>add9</span></label>
              <label class="chip"><input type="checkbox" id="xSharp11"><span>#11</span></label>
              <label class="chip"><input type="checkbox" id="xMin11"><span>m11</span></label>
            </div>
          </div>
        </details>

        <details class="group" id="limTen">
          <summary>
            <div class="sumLeft">
              <div>
                <div class="sumTitle">Tension</div>
                <div class="sumSub"> </div>
              </div>
            </div>
            <div class="chev">‚ñº</div>
          </summary>
          <div class="groupBody">
            <div class="checkRow">
              <label class="chip"><input type="checkbox" id="tAlt"><span>alt dom</span></label>
              <label class="chip"><input type="checkbox" id="tSlash"><span>slash</span></label>
              <label class="chip"><input type="checkbox" id="tChrom"><span>chromatic</span></label>
              <label class="chip"><input type="checkbox" id="tB9"><span>‚ô≠9</span></label>
              <label class="chip"><input type="checkbox" id="tSharp9"><span>#9</span></label>
            </div>
          </div>
        </details>

        <div class="msg" style="margin-top:10px;"> </div>
      </div>
    </section>

  </div><!-- /app -->

  <!-- Advanced Settings Modal -->
  <div class="modalBack" id="advBack" role="dialog" aria-modal="true" aria-label="Advanced settings">
    <div class="modal">
      <div class="modalHead">
        <div class="modalTitle">Advanced settings</div>
        <div class="reorderBtns">
          <button class="btn small" id="btnResetMenu" type="button">Reset</button>
          <button class="btn primary small" id="btnCloseAdv" type="button">Done</button>
        </div>
      </div>

      <div class="modalBody">
        <div class="msg" style="margin:0 0 10px 0;">
          Menu order (main sections). Visual + keyboard settings live here.
        </div>

        <div id="orderList"></div>

        <div class="splitLine"></div>

        <div class="modalSubTitle">Visuals</div>
        <div class="modalGrid">
          <div class="miniCtl">
            <label style="display:flex;align-items:center;justify-content:space-between;gap:10px;">
              <span>Page theme</span>
              <button class="lockMini" id="lockThemeMini" type="button" title="Lock theme so Style/Random won't change it">üîì</button>
            </label>
            <select id="pageTheme"></select>
          </div>
          <div class="miniCtl">
            <label>Piano theme</label>
            <select id="pianoTheme"></select>
          </div>
          <div class="miniCtl">
            <label>Fretboard theme</label>
            <select id="fretTheme"></select>
          </div>
          <div class="miniCtl">
            <label>Fretboard layout</label>
            <label class="chip" style="width:100%;justify-content:space-between;margin:0;">
              <span>Left-handed view</span>
              <input type="checkbox" id="fretLefty">
            </label>
          </div>
          <div class="miniCtl">
            <label>Fret numbers</label>
            <label class="chip" style="width:100%;justify-content:space-between;margin:0;">
              <span>Show numbers</span>
              <input type="checkbox" id="fretNumbers">
            </label>
          </div>
          <div class="miniCtl">
            <label>Tone markers</label>
            <select id="markerStyle">
              <option value="dots" selected>Dots</option>
              <option value="rings">Rings</option>
              <option value="triangles">Triangles</option>
              <option value="squares">Squares</option>
            </select>
          </div>

          <div class="miniCtl">
            <label>Morphing gradient background</label>
            <label class="chip" style="width:100%;justify-content:space-between;margin:0;">
              <span>Enable morph</span>
              <input type="checkbox" id="morphBg" checked>
            </label>
          </div>

          <div class="miniCtl">
            <label>Keyboard length (octaves)</label>
            <div class="miniRow">
              <input id="kbOct" type="range" min="1" max="4" value="2">
              <input id="kbOctNum" type="number" min="1" max="4" value="2">
            </div>
            <div class="msg" style="margin:8px 0 0 0;">2 = default (14 white keys). 4 = wider view.</div>
          </div>
        </div>

        <div class="splitLine"></div>

        <div class="modalSubTitle">SoundFont</div>
        <div class="modalGrid">
          <div class="miniCtl" style="grid-column: 1 / -1;">
            <label>SoundFont URL</label>
            <div class="inline">
              <input class="textInput" type="text" id="sfUrl" placeholder="https://...">
              <button class="btn tiny" id="btnSfLoad" type="button">Load</button>
            </div>
            <div class="msg" id="sfStatus" style="margin:8px 0 0 0;"> </div>
          </div>
          <div class="miniCtl" style="grid-column: 1 / -1;">
            <label>Manual upload (.sf2)</label>
            <input class="fileInput" type="file" id="sfFile" accept=".sf2,application/octet-stream">
          </div>
        </div>

        <div class="splitLine"></div>

        <div class="modalSubTitle">Songs (advanced)</div>
        <div class="modalGrid">
          <div class="miniCtl" style="grid-column: 1 / -1;">
            <label>Playlist URL</label>
            <div class="inline">
              <input class="textInput" type="text" id="songUrl" placeholder="https://...">
              <button class="btn tiny" id="btnSongFetch" type="button">Fetch</button>
            </div>
          </div>
          <div class="miniCtl" style="grid-column: 1 / -1;">
            <label>Manual upload (.txt/.ireal/.mgu)</label>
            <input class="fileInput" type="file" id="songFile" accept=".txt,.ireal,.irealbook,.csv,.mgu,.sgu,.mg1,.sg1,.mg2,.sg2,.mg3,.sg3,.mg4,.sg4,.mg5,.sg5,application/octet-stream">
          </div>
        </div>

        <div class="msg" style="margin-top:10px;"></div>
      </div>
    </div>
  </div>

  <!-- Edit Chord Modal -->
  <div class="editModalBack" id="editBack" role="dialog" aria-modal="true" aria-label="Edit chord">
    <div class="editModal">
      <div class="editHead">
        <div class="editTitle" id="editTitle">Edit chord</div>
        <div class="reorderBtns">
          <button class="btn small" id="btnEditClose" type="button">Done</button>
        </div>
      </div>
      <div class="editBody">
        <div class="editGrid">
          <div class="miniCtl">
            <label>Root</label>
            <select id="editRoot"></select>
          </div>
          <div class="miniCtl">
            <label>Quality</label>
            <select id="editQual"></select>
          </div>
          <div class="miniCtl">
            <label>Slash (optional)</label>
            <select id="editSlash"></select>
            <div class="msg" style="margin:8px 0 0 0;">Set ‚Äú(none)‚Äù for no slash bass.</div>
          </div>
          <div class="miniCtl">
            <label>Placement</label>
            <select id="editPlace">
              <option value="whole">Whole bar</option>
              <option value="half1">Half (top)</option>
              <option value="half2">Half (bottom)</option>
            </select>
            <div class="msg" style="margin:8px 0 0 0;">Choosing a half will split the bar into 2 halves.</div>
          </div>
        </div>

        <div class="editActions">
          <button class="btn primary" id="btnEditApply" type="button">‚úÖ Apply</button>
          <button class="btn" id="btnEditClear" type="button">üßπ Clear</button>
          <button class="btn ghost" id="btnEditCancel" type="button">‚úñÔ∏è Cancel</button>
        </div>

        <div class="editNote" id="editNote"> </div>
      </div>
    </div>
  </div>

<script>
(() => {
  "use strict";

  /* ---------- Core helpers ---------- */
  const NOTE_NAMES = ["C","C#","D","Eb","E","F","F#","G","Ab","A","Bb","B"];
  const NOTE_TO_PC = {
    C:0, "B#":0, "C#":1, Db:1, D:2, "D#":3, Eb:3, E:4, Fb:4, "E#":5, F:5, "F#":6, Gb:6,
    G:7, "G#":8, Ab:8, A:9, "A#":10, Bb:10, B:11, Cb:11
  };
  const pc = (n)=>((n%12)+12)%12;
  const pcDistance = (a,b)=>{
    const d1 = (a - b + 12) % 12;
    const d2 = (b - a + 12) % 12;
    return Math.min(d1, d2);
  };
  const clamp = (n,a,b)=>Math.max(a,Math.min(b,n));
  const rint = (a,b)=>Math.floor(a + Math.random()*(b-a+1));
  const pick = (arr)=>arr[Math.floor(Math.random()*arr.length)];
  const chance = (p)=>Math.random()<p;
  const noteName = (p)=>NOTE_NAMES[pc(p)];

  function weightedPick(opts){
    const sum = opts.reduce((s,o)=>s+o.w,0);
    let t = Math.random()*sum;
    for (const o of opts){ t -= o.w; if (t<=0) return o.v; }
    return opts[opts.length-1].v;
  }

  function safeJSONParse(s, fallback=null){
    try{ return JSON.parse(s); }catch{ return fallback; }
  }

  function safeStorageGet(key){
    try{ return localStorage.getItem(key); }catch{ return null; }
  }

  /* ---------- Scales / chords ---------- */
  const SCALES = {
    ionian:[0,2,4,5,7,9,11],
    dorian:[0,2,3,5,7,9,10],
    phryg:[0,1,3,5,7,8,10],
    lydian:[0,2,4,6,7,9,11],
    mixo:  [0,2,4,5,7,9,10],
    mixolydian:[0,2,4,5,7,9,10],
    mixoB13:[0,2,4,5,7,8,10],
    aeolian:[0,2,3,5,7,8,10],
    locrian:[0,1,3,5,6,8,10],
    melodicMinor:[0,2,3,5,7,9,11],
    lydianDom:[0,2,4,6,7,9,10],
    altered:[0,1,3,4,6,8,10],
    harmonicMinor:[0,2,3,5,7,8,11],
  };

  const CHORDS = {
    maj:[0,4,7],
    min:[0,3,7],
    maj7:[0,4,7,11],
    maj9:[0,4,7,11,14],
    maj6:[0,4,7,9],
    "6/9":[0,4,7,9,14],
    add9:[0,4,7,14],
    maj9sharp11:[0,4,7,11,14,18],

    min7:[0,3,7,10],
    min9:[0,3,7,10,14],
    min6:[0,3,7,9],
    min11:[0,3,7,10,14,17],

    minMaj7:[0,3,7,11],
    minMaj9:[0,3,7,11,14],

    dom7:[0,4,7,10],
    dom9:[0,4,7,10,14],
    dom11:[0,4,7,10,14,17],
    dom13:[0,4,7,10,14,21],
    dom7b9:[0,4,7,10,13],
    dom7sharp9:[0,4,7,10,15],
    dom7b13:[0,4,7,10,20],

    sus:[0,5,7,10],
    "7sus":[0,5,7,10,14],

    halfdim:[0,3,6,10],
    dim7:[0,3,6,9],
  };

  function chordIntervals(ch){
    if (Array.isArray(ch?.intervals) && ch.intervals.length) return ch.intervals;
    const key = ch?.key;
    if (key && CHORDS[key]) return CHORDS[key];
    const sym = ch?.symbol;
    const bySymbol = {
      "maj7":"maj7", "maj9":"maj9", "6/9":"6/9", "6":"maj6", "add9":"add9", "maj9(#11)":"maj9sharp11",
      "m7":"min7", "m9":"min9", "m6":"min6", "m11":"min11", "mMaj7":"minMaj7", "mMaj9":"minMaj9",
      "7":"dom7", "9":"dom9", "11":"dom11", "13":"dom13", "7(b9)":"dom7b9", "7(#9)":"dom7sharp9", "7(b13)":"dom7b13",
      "sus":"sus", "7sus":"7sus",
      "√∏7":"halfdim", "dim7":"dim7"
    }[sym];
    if (bySymbol && CHORDS[bySymbol]) return CHORDS[bySymbol];
    const fam = ch?.family;
    if (fam==="maj") return CHORDS.maj7;
    if (fam==="min") return CHORDS.min7;
    if (fam==="dom") return CHORDS.dom7;
    if (fam==="hdim") return CHORDS.halfdim;
    if (fam==="dim") return CHORDS.dim7;
    if (fam==="sus") return CHORDS.sus;
    return CHORDS.dom7;
  }

  function chordName(ch){
    const base = `${noteName(ch.root)}${ch.symbol}`;
    return (ch.slash!=null) ? `${base}/${noteName(ch.slash)}` : base;
  }
  function chordTonesPCs(ch){
    return [...new Set(chordIntervals(ch).map(i=>pc(ch.root+i)))];
  }

  /* ---------- Chord-local scale selection (context-aware) ---------- */
  function candidatesForChord(ch){
    const pcs = chordTonesPCs(ch);
    const hasSharp11 = pcs.includes(pc(ch.root + 6)) || (ch.symbol||"").includes("#11");
    if (ch.family === "maj") return hasSharp11 ? ["lydian","ionian"] : ["ionian","lydian"];
    if (ch.family === "min") return ["dorian","aeolian","phryg"];
    if (ch.family === "minmaj") return ["melodicMinor","dorian","aeolian"];
    if (ch.family === "dom"){
      const hasSharp11Dom = pcs.includes(pc(ch.root+6));
      const hasFlat13 = pcs.includes(pc(ch.root+8)) || (ch.symbol||"").includes("b13");
      const base = hasFlat13
        ? ["mixoB13","altered"]
        : (hasSharp11Dom ? ["lydianDom","mixo","altered"] : ["mixo","lydianDom","altered"]);
      base.push("harmonicMinor","melodicMinor");
      return base;
    }
    if (ch.family === "sus") return ["mixo","dorian"];
    if (ch.family === "hdim") return ["locrian"];
    if (ch.family === "dim") return ["harmonicMinor","locrian"];
    return ["mixo"];
  }

  function scoreModeForContext(ch, mode, prevCh, nextCh, scaleRootOverride=null){
    const scaleRoot = (scaleRootOverride!=null) ? pc(scaleRootOverride) : ((ch && typeof ch.scaleRoot==="number") ? ch.scaleRoot : ch.root);
    const scale = SCALES[mode] || SCALES.mixo;
    const scalePC = new Set(scale.map(i=>pc(scaleRoot+i)));
    const ctxPCs = [];
    if (prevCh) ctxPCs.push(...chordTonesPCs(prevCh));
    if (nextCh) ctxPCs.push(...chordTonesPCs(nextCh));
    if (prevCh && prevCh.slash!=null) ctxPCs.push(pc(prevCh.slash));
    if (nextCh && nextCh.slash!=null) ctxPCs.push(pc(nextCh.slash));

    let score = 0;
    for (const p of ctxPCs) if (scalePC.has(p)) score += 2;

    if (mode==="ionian") score += 1.2;
    if (mode==="dorian") score += 1.1;
    if (mode==="mixo") score += 1.0;
    if (mode==="lydian") score += 0.6;
    if (mode==="aeolian") score += 0.6;
    if (mode==="phryg") score += 0.2;
    if (mode==="altered") score += 0.2;
    if (mode==="lydianDom") score += 0.4;
    if (mode==="melodicMinor") score += 0.8;
    if (mode==="harmonicMinor") score += 0.6;
    if (mode==="mixoB13") score += 0.9;

    const chordPCs = chordTonesPCs(ch);
    if (chordPCs.includes(pc(ch.root+6))){
      if (mode==="lydian" || mode==="lydianDom") score += 2.5;
      if (mode==="ionian" || mode==="mixo") score -= 0.5;
    }
    if (chordPCs.includes(pc(ch.root+8))){
      if (mode==="mixoB13") score += 2.2;
      if (mode==="altered") score += 0.6;
      if (mode==="mixo" || mode==="lydianDom") score -= 0.6;
    }

    if (ch?.family === "dom" && nextCh){
      const targetRoot = pc(nextCh.root);
      const isVtoI = pc(ch.root + 5) === targetRoot;
      if (isVtoI && pc(scaleRoot) === targetRoot){
        const nextFam = nextCh.family;
        const toMinor = nextFam === "min" || nextFam === "minmaj" || nextFam === "hdim" || nextFam === "dim";
        if (toMinor){
          if (mode === "melodicMinor") score += 3.2;
          if (mode === "harmonicMinor") score += 1.4;
        } else if (nextFam === "dom"){
          if (mode === "harmonicMinor") score += 2.6;
          if (mode === "melodicMinor") score += 0.9;
        } else {
          if (mode === "harmonicMinor") score += 2.4;
          if (mode === "melodicMinor") score += 1.2;
        }
      }
    }
    return score;
  }

  function chooseChordLocalMode(ch, prevCh, nextCh){
    const cand = candidatesForChord(ch);
    let best = cand[0], bestScore = -1e9;
    for (const m of cand){
      const s = scoreModeForContext(ch, m, prevCh, nextCh);
      if (s > bestScore){ bestScore = s; best = m; }
    }
    return best;
  }

  function scalePCsForChordLocal(ch, prevCh, nextCh){
    const mode = ch?.mode || chooseChordLocalMode(ch, prevCh, nextCh);
    const scaleRoot = (ch && typeof ch.scaleRoot==="number") ? ch.scaleRoot : ch.root;
    const base = SCALES[mode] || SCALES.mixo;
    const pcsSet = new Set();
    const baseSet = new Set();
    base.forEach(i => {
      const p = pc(scaleRoot + i);
      pcsSet.add(p);
      baseSet.add(p);
    });
    chordTonesPCs(ch).forEach(p=>{
      const pp = pc(p);
      if (baseSet.has(pp)) pcsSet.add(pp);
    });
    if (ch.slash!=null){
      const s = pc(ch.slash);
      if (baseSet.has(s)) pcsSet.add(s);
    }
    return { pcs:[...pcsSet], mode };
  }

  /* ---------- Limit how many distinct scales are used ---------- */
  function candidateModesWithLimit(ch, limit){
    const base = candidatesForChord(ch);
    if (limit<=2){
      if (ch.family==="dom"){
        const pcs = chordTonesPCs(ch);
        const hasFlat13 = pcs.includes(pc(ch.root+8)) || (ch.symbol||"").includes("b13");
        return hasFlat13 ? ["mixoB13"] : ["mixo"];
      }
      if (ch.family==="maj") return ["ionian"];
      if (ch.family==="min") return ["dorian","aeolian"];
      if (ch.family==="sus") return ["mixo"];
      if (ch.family==="minmaj") return ["melodicMinor","dorian"];
      if (ch.family==="dim") return ["harmonicMinor","locrian"];
    }
    return base;
  }

  function assignChordModesWithLimit(chartBars, overrideLimit, overrideLimiterEnabled){
    if (!Array.isArray(chartBars) || !chartBars.length) return;

    const slots = [];
    for (let b=0;b<chartBars.length;b++){
      const bar = chartBars[b];
      const chords = bar?.chords || [];
      for (let h=0;h<chords.length;h++){
        const chord = chords[h];
        if (!chord) continue;
        slots.push({ barIndex:b, halfIndex:h, chord });
      }
    }
    if (!slots.length) return;

    const limitEnabled = (overrideLimiterEnabled != null)
      ? overrideLimiterEnabled
      : (state.biabActive ? false : (state.scaleLimitEnabled ?? true));
    const maxLimit = 32;
    const limit = limitEnabled
      ? clamp(Number(overrideLimit ?? state.scalesUsed)||1, 1, maxLimit)
      : Number.POSITIVE_INFINITY;

    const contextSpan = 4;
    const sameChord = (a,b)=>{
      if (!a || !b) return false;
      const aSlash = (a.slash!=null) ? pc(a.slash) : null;
      const bSlash = (b.slash!=null) ? pc(b.slash) : null;
      return pc(a.root)===pc(b.root) && a.symbol===b.symbol && aSlash===bSlash;
    };
    const findPrevContext = (idx)=>{
      const cur = slots[idx]?.chord || null;
      for (let i=idx-1, steps=0; i>=0 && steps<contextSpan; i--, steps++){
        const cand = slots[i]?.chord || null;
        if (!cand) continue;
        if (!cur || !sameChord(cur, cand)) return cand;
      }
      return slots[idx-1]?.chord || null;
    };
    const findNextContext = (idx)=>{
      const cur = slots[idx]?.chord || null;
      for (let i=idx+1, steps=0; i<slots.length && steps<contextSpan; i++, steps++){
        const cand = slots[i]?.chord || null;
        if (!cand) continue;
        if (!cur || !sameChord(cur, cand)) return cand;
      }
      return slots[idx+1]?.chord || null;
    };

    // Single-scale hard clamp: force all chords to key root/mode
    if (limitEnabled && limit===1 && SCALES[state.keyMode]){
      const rootPc = pc(state.keyRoot);
      for (const slot of slots){
        slot.chord.mode = state.keyMode;
        slot.chord.scaleRoot = rootPc;
      }
      return;
    }

    const pcsFor = (center, mode)=>{
      const base = SCALES[mode] || SCALES.mixo;
      return new Set(base.map(i=>pc(center + i)));
    };
    const chordFits = (ch, center, mode)=>{
      const set = pcsFor(center, mode);
      for (const p of chordTonesPCs(ch)) if (!set.has(pc(p))) return false;
      if (ch.slash!=null && !set.has(pc(ch.slash))) return false;
      return true;
    };

    const candidateCentersForMode = (ch, mode)=>{
      const intervals = SCALES[mode] || SCALES.mixo;
      const centers = [];
      const seen = new Set();
      for (const iv of intervals){
        const center = pc(ch.root - iv);
        if (seen.has(center)) continue;
        seen.add(center);
        if (chordFits(ch, center, mode)) centers.push(center);
      }
      return centers;
    };

    const sigFor = (rootPc, mode)=>{
      const base = SCALES[mode] || SCALES.mixo;
      const pcs = base.map(i=>pc(rootPc + i)).sort((a,b)=>a-b);
      return pcs.join(",");
    };

    const keyMode = SCALES[state.keyMode] ? state.keyMode : null;
    const keyCenter = (keyMode != null) ? pc(state.keyRoot) : null;
    const keySig = (keyMode != null) ? sigFor(keyCenter, keyMode) : null;

    // collect candidate modes per chord (root fixed to chord root)
    const sigTotals = new Map();
    const sigMeta = new Map(); // sig -> {root, mode}
    const candPer = slots.map((slot, idx)=>{
      const prev = findPrevContext(idx);
      const next = findNextContext(idx);
      const chord = slot.chord;
      const cand = [];
      const seen = new Set();
      const addCandidate = (mode, center)=>{
        const sig = sigFor(center, mode);
        const key = `${sig}|${center}|${mode}`;
        if (seen.has(key)) return;
        seen.add(key);
        const score = scoreModeForContext(chord, mode, prev, next, center);
        sigTotals.set(sig, (sigTotals.get(sig)||0) + score);
        if (!sigMeta.has(sig)) sigMeta.set(sig, {root:center, mode});
        cand.push({mode, score, center, sig});
      };
      const modes = candidateModesWithLimit(chord, limit);
      modes.forEach(mode=>{
        const centers = candidateCentersForMode(chord, mode);
        centers.forEach(center=> addCandidate(mode, center));
      });
      if (keyMode && chordFits(chord, keyCenter, keyMode)) addCandidate(keyMode, keyCenter);
      if (!cand.length){
        const fallbackMode = modes[0] || "mixo";
        const center = pc(chord.root);
        addCandidate(fallbackMode, center);
      }
      return cand;
    });

    const sigCounts = new Map();
    candPer.forEach(list=>{
      const seen = new Set();
      list.forEach(c=>{
        if (seen.has(c.sig)) return;
        seen.add(c.sig);
        sigCounts.set(c.sig, (sigCounts.get(c.sig)||0) + 1);
      });
    });

    const sigFirst = new Map();
    candPer.forEach((list, idx)=>{
      list.forEach(c=>{
        if (!sigFirst.has(c.sig)) sigFirst.set(c.sig, idx);
      });
    });

    // Exact cover (limit=2): pick signatures that cover all chords with best total score
    const sigArr = [...sigTotals.keys()];
    let palette = [];
    if (!limitEnabled){
      palette = sigArr.slice();
    }
    if (limitEnabled && limit === 2 && sigArr.length){
      let bestScore = -Infinity;
      let bestPair = null;
      for (let a=0;a<sigArr.length;a++){
        for (let b=a;b<sigArr.length;b++){
          const pair = [sigArr[a], sigArr[b]];
          let ok = true;
          let total = 0;
          for (let i=0;i<candPer.length;i++){
            const cand = candPer[i].filter(c=>pair.includes(c.sig) && chordFits(slots[i].chord, c.center, c.mode));
            if (!cand.length){ ok = false; break; }
            const best = cand.reduce((m,c)=> c.score>m?c.score:m, -Infinity);
            total += best;
          }
          if (ok && total > bestScore){
            bestScore = total;
            bestPair = pair;
          }
        }
      }
      if (bestPair) palette = bestPair;
    }

    // Greedy cover: pick signatures that cover as many chords as possible up to limit
    const allSigs = new Set(sigArr);
    const covered = new Array(slots.length).fill(false);
    if (!palette.length){
      palette = [];
    }

    function chordHasSig(idx, sig){
      const cand = candPer[idx];
      return cand.some(c=>c.sig===sig && chordFits(slots[idx].chord, c.center, c.mode));
    }

    while (limitEnabled && palette.length < limit && allSigs.size){
      let bestSig = null, bestGain = -Infinity;
      for (const sig of allSigs){
        let gain = 0;
        for (let i=0;i<slots.length;i++){
          if (covered[i]) continue;
          const cand = candPer[i].filter(c=>c.sig===sig && chordFits(slots[i].chord, c.center, c.mode));
          if (cand.length){
            // use best score for this chord under this sig
            const s = cand.reduce((m,c)=> c.score>m?c.score:m, -Infinity);
            gain += s;
          }
        }
        if (gain > bestGain){
          bestGain = gain;
          bestSig = sig;
        }
      }
      if (bestSig==null || bestGain===-Infinity) break;
      palette.push(bestSig);
      allSigs.delete(bestSig);
      for (let i=0;i<slots.length;i++){
        if (covered[i]) continue;
        if (chordHasSig(i, bestSig)) covered[i] = true;
      }
    }

    if (!palette.length && candPer.length){
      const fallbackSig = candPer[0][0]?.sig || "";
      palette.push(fallbackSig);
      if (!sigMeta.has(fallbackSig)) sigMeta.set(fallbackSig, {root: pc(slots[0].chord.root), mode:"mixo"});
    }
    const paletteSet = new Set(palette);

    const sigSetCache = new Map();
    const sigToSet = (sig)=>{
      if (!sigSetCache.has(sig)){
        const set = new Set(String(sig).split(",").filter(Boolean).map(n=>Number(n)));
        sigSetCache.set(sig, set);
      }
      return sigSetCache.get(sig);
    };
    const sharedCount = (aSet, bSet)=>{
      if (!aSet || !bSet) return 0;
      let n = 0;
      for (const p of aSet) if (bSet.has(p)) n++;
      return n;
    };
    const pcDist = (a,b)=>{
      const d1 = (a - b + 12) % 12;
      const d2 = (b - a + 12) % 12;
      return Math.min(d1, d2);
    };
    const totalSlots = Math.max(1, slots.length);
    const baseScoreFor = (c)=>{
      let s = c.score;
      const sig = c.sig;
      const sigTotal = sigTotals.get(sig) || 0;
      const sigCount = sigCounts.get(sig) || 0;
      s += (sigTotal / totalSlots) * 0.08;
      s += (sigCount / totalSlots) * 1.6;
      if (sigCount <= 1) s -= 0.35;
      const firstIdx = sigFirst.get(sig);
      if (firstIdx != null){
        const early = (totalSlots - firstIdx) / totalSlots;
        s += early * 0.7;
      }
      if (keySig && sig === keySig) s += 2.6;
      return s;
    };
    const transitionScore = (prev, cur)=>{
      if (!prev || !cur) return 0;
      let s = 0;
      if (prev.sig === cur.sig) s += 2.1;
      else s -= 0.6;
      const shared = sharedCount(sigToSet(prev.sig), sigToSet(cur.sig));
      s += shared * 0.35;
      s -= pcDist(prev.center, cur.center) * 0.25;
      if (prev.center === cur.center) s += 0.7;
      if (prev.mode === cur.mode && prev.center === cur.center) s += 0.25;
      return s;
    };

    function nearestScaleTone(rootPc, scaleSet){
      let best = rootPc;
      let bestDist = 99;
      for (const p of scaleSet){
        const d = Math.min((p - rootPc + 12) % 12, (rootPc - p + 12) % 12);
        if (d < bestDist){
          bestDist = d;
          best = p;
        }
      }
      return best;
    }

    function retuneChordToScale(slot, scaleRoot, mode){
      const scaleSet = pcsFor(scaleRoot, mode);
      const limiters = state.limiter || DEFAULTS.limiter;
      const weights = state.weights || macroToWeights(state.chaos);
      const baseOpts = buildQualityOptions(limiters);
      const scaleTones = [...scaleSet];

      let rootPc = pc(slot.chord.root);
      if (!scaleSet.has(rootPc)) rootPc = nearestScaleTone(rootPc, scaleSet);

      // If current root can't support any in-scale quality, find a nearby scale root that can.
      const hasFitAt = (r)=>baseOpts.some(o=>{
        const tones = (CHORDS[o.v.symbol] || []).map(iv=>pc(r + iv));
        return tones.every(p=>scaleSet.has(p));
      });
      if (!hasFitAt(rootPc)){
        let best = rootPc;
        let bestDist = 99;
        for (const t of scaleTones){
          if (!hasFitAt(t)) continue;
          const d = Math.min((t - rootPc + 12) % 12, (rootPc - t + 12) % 12);
          if (d < bestDist){ bestDist = d; best = t; }
        }
        rootPc = best;
      }
      const q = chooseQuality(limiters, weights, scaleSet, rootPc, scaleSet);
      const replacement = makeChord(rootPc, q);
      replacement.mode = mode;
      replacement.scaleRoot = pc(scaleRoot);
      if (slot.chord.slash!=null && scaleSet.has(pc(slot.chord.slash))) replacement.slash = pc(slot.chord.slash);
      Object.assign(slot.chord, replacement);
    }

    const candLists = slots.map((slot, idx)=>{
      const chord = slot.chord;
      let list = candPer[idx].filter(c=> paletteSet.has(c.sig));
      if (!list.length){
        list = [];
        for (const sig of palette){
          const meta = sigMeta.get(sig);
          if (!meta) continue;
          if (!chordFits(chord, meta.root, meta.mode)) continue;
          const score = scoreModeForContext(chord, meta.mode, null, null, meta.root);
          list.push({mode:meta.mode, score, center:meta.root, sig});
        }
      }
      if (!list.length) list = candPer[idx].slice();
      return list;
    });

    const dp = [];
    const back = [];
    for (let i=0;i<candLists.length;i++){
      const list = candLists[i];
      dp[i] = new Array(list.length).fill(-Infinity);
      back[i] = new Array(list.length).fill(-1);
      for (let j=0;j<list.length;j++){
        const base = baseScoreFor(list[j]);
        if (i===0){
          dp[i][j] = base;
          continue;
        }
        for (let k=0;k<candLists[i-1].length;k++){
          const val = dp[i-1][k] + base + transitionScore(candLists[i-1][k], list[j]);
          if (val > dp[i][j]){
            dp[i][j] = val;
            back[i][j] = k;
          }
        }
      }
    }

    let endIdx = 0;
    let bestScore = -Infinity;
    const last = dp[dp.length - 1] || [];
    for (let i=0;i<last.length;i++){
      if (last[i] > bestScore){
        bestScore = last[i];
        endIdx = i;
      }
    }
    const chosenIdx = new Array(candLists.length).fill(0);
    for (let i=candLists.length-1;i>=0;i--){
      chosenIdx[i] = endIdx;
      endIdx = back[i][endIdx] != null ? back[i][endIdx] : 0;
    }

    for (let i=0;i<slots.length;i++){
      const chord = slots[i].chord;
      const list = candLists[i];
      const chosen = list[chosenIdx[i]] || list[0];
      if (!chosen){
        const fallbackSig = palette[0] || candPer[i][0]?.sig || sigFor(pc(chord.root), "mixo");
        const meta = sigMeta.get(fallbackSig) || {root: pc(chord.root), mode:"mixo"};
        retuneChordToScale(slots[i], meta.root, meta.mode);
        continue;
      }

      chord.mode = chosen.mode || "mixo";
      chord.scaleRoot = pc((chosen && typeof chosen.center==="number") ? chosen.center : chord.root);
    }

    // Hard cap: if any extra signatures slipped through, remap them into the top `limit`
    const usedCounts = new Map();
    slots.forEach(slot=>{
      const sig = sigFor(pc(slot.chord.scaleRoot ?? slot.chord.root), slot.chord.mode || "mixo");
      usedCounts.set(sig, (usedCounts.get(sig)||0)+1);
      if (!sigMeta.has(sig)) sigMeta.set(sig, {root: pc(slot.chord.scaleRoot ?? slot.chord.root), mode: slot.chord.mode||"mixo"});
    });

    if (limitEnabled && usedCounts.size > limit){
      const keep = [...usedCounts.entries()].sort((a,b)=>b[1]-a[1]).slice(0, limit).map(([sig])=>sig);
      const keepSet = new Set(keep);
      slots.forEach(slot=>{
        const currentSig = sigFor(pc(slot.chord.scaleRoot ?? slot.chord.root), slot.chord.mode || "mixo");
        if (keepSet.has(currentSig)) return;

        let reassigned = false;
        for (const sig of keep){
          const meta = sigMeta.get(sig);
          if (meta && chordFits(slot.chord, meta.root, meta.mode)){
            slot.chord.mode = meta.mode;
            slot.chord.scaleRoot = meta.root;
            reassigned = true;
            break;
          }
        }

        if (!reassigned){
          const fallbackSig = keep[0];
          const meta = sigMeta.get(fallbackSig) || {root: pc(slot.chord.root), mode:"mixo"};
          retuneChordToScale(slot, meta.root, meta.mode);
        }
      });
    }
  }

  /* ---------- Defaults / State ---------- */
  const DEFAULT_SOUNDFONT_URL = "https://raw.githubusercontent.com/santismo/fakebot/main/Roland.SC-55.sf2";

  const DEFAULTS = {
    bars: 4,
    halfEnabled: false,
    halfDensity: 22,
    tempo: 140,
    swing: 58,
    chaos: 35,
    complexity: 45,
    rootMode: "keyed",
    progressionLogic: "jazzFunctional",
    genrePreset: "modernJazz",
    grooveStyle: "swing",
    compStyle: "twoStabs",
    bassPreset: "upright",
    keysPreset: "ep",
    drumsPreset: "jazz",
    drumsLevel: 55,
    keysComplex: 55,
    keysFill: 30,
    bassComplex: 55,
    bassFill: 25,
    drumsComplex: 65,
    drumsFill: 40,
    scalesUsed: 2,
    scaleLimitEnabled: true,
    limiter: {
      qMaj7:true, qMin7:true, qDom7:true, qDim7:false,
      qHalfDim:true, qSus:false, qMinMaj:false,
      x9:false, x11:false, x13:false, x6:false, xAdd9:false, xSharp11:false, xMin11:false,
      tAlt:false, tSlash:false, tChrom:false, tB9:false, tSharp9:false,
    },
    pageTheme: "terminal",
    pianoTheme: "classic",
    markerStyle: "dots",
    viewMode: "piano",
    fretTheme: "rosewood",
    fretLefty: false,
    fretNumbers: false,
    morphBg: true,
    kbOct: 2, /* 2 octaves = 14 white keys (default) */
    playbackOrder: [],
    currentSongTitle: "",
    soundFontUrl: DEFAULT_SOUNDFONT_URL,
    soundFontEnabled: true
  };

  const state = {
    chartBars: [],
    showKey: true,
    keyRoot: 0,
    keyMode: "ionian",
    activeBar: 0,
    activeHalf: 0,

    biabActive: false,
    biabMeta: null,
    biabMelody: [],
    biabMelodyBars: [],
    biabDisplayBars: [],
    biabMidiBars: [],
    biabMidiPrograms: [],
    biabTicksPerBeat: 120,
    biabBarTicks: 480,
    biabTimeSig: { num: 4, den: 4 },
    biabMelodyGenerated: false,

    bars: DEFAULTS.bars,
    halfEnabled: DEFAULTS.halfEnabled,
    halfDensity: DEFAULTS.halfDensity,
    tempo: DEFAULTS.tempo,
    swing: DEFAULTS.swing,
    chaos: DEFAULTS.chaos,
    complexity: DEFAULTS.complexity,
    rootMode: DEFAULTS.rootMode,
    progressionLogic: DEFAULTS.progressionLogic,
    genrePreset: DEFAULTS.genrePreset,
    grooveStyle: DEFAULTS.grooveStyle,
    compStyle: DEFAULTS.compStyle,
    bassPreset: DEFAULTS.bassPreset,
    keysPreset: DEFAULTS.keysPreset,
    drumsPreset: DEFAULTS.drumsPreset,
    drumsLevel: DEFAULTS.drumsLevel,
    keysComplex: DEFAULTS.keysComplex,
    keysFill: DEFAULTS.keysFill,
    bassComplex: DEFAULTS.bassComplex,
    bassFill: DEFAULTS.bassFill,
    drumsComplex: DEFAULTS.drumsComplex,
    drumsFill: DEFAULTS.drumsFill,
    scalesUsed: DEFAULTS.scalesUsed,
    scaleLimitEnabled: DEFAULTS.scaleLimitEnabled,
    limiter: {...DEFAULTS.limiter},

    pageTheme: DEFAULTS.pageTheme,
    pianoTheme: DEFAULTS.pianoTheme,
    markerStyle: DEFAULTS.markerStyle,
    viewMode: DEFAULTS.viewMode,
    fretTheme: DEFAULTS.fretTheme,
    fretLefty: DEFAULTS.fretLefty,
    fretNumbers: DEFAULTS.fretNumbers,
    morphBg: DEFAULTS.morphBg,
    kbOct: DEFAULTS.kbOct,
    playbackOrder: structuredClone(DEFAULTS.playbackOrder),
    currentSongTitle: DEFAULTS.currentSongTitle,
    soundFontUrl: DEFAULTS.soundFontUrl,
    soundFontEnabled: DEFAULTS.soundFontEnabled,
    allowedCenters: [],

    weights: null,

    lockProg: false,
    lockStyle: false,
    lockTheme: false,
    lockTime: false,
    lockSounds: false,
    lockLimiters: false,

    editMode: false,
  };

  /* ---------- UI refs ---------- */
  const E = window.els = {
    msg: document.getElementById("msg"),
    pillLine: document.getElementById("pillLine"),
    focusLine: document.getElementById("focusLine"),

    btnPlay: document.getElementById("btnPlay"),
    btnGenerate: document.getElementById("btnGenerate"),
    btnRandomAll: document.getElementById("btnRandomAll"),
    btnStyleRand: document.getElementById("btnStyleRand"),
    btnUndo: document.getElementById("btnUndo"),
    btnRedo: document.getElementById("btnRedo"),
    btnCopy: document.getElementById("btnCopy"),
    btnDefaults: document.getElementById("btnDefaults"),
    btnPianoToggle: document.getElementById("btnPianoToggle"),
    btnFretToggle: document.getElementById("btnFretToggle"),

    btnEdit: document.getElementById("btnEdit"),
    editHint: document.getElementById("editHint"),

    btnRandGen: document.getElementById("btnRandGen"),
    btnRandTime: document.getElementById("btnRandTime"),
    btnRandFeel: document.getElementById("btnRandFeel"),
    btnRandSounds: document.getElementById("btnRandSounds"),
    btnRandLimit: document.getElementById("btnRandLimit"),

    lockProgMini: document.getElementById("lockProgMini"),
    lockStyleMini: document.getElementById("lockStyleMini"),
    lockThemeMini: document.getElementById("lockThemeMini"),
    lockTimeMini: document.getElementById("lockTimeMini"),
    lockSoundMini: document.getElementById("lockSoundMini"),
    lockLimitMini: document.getElementById("lockLimitMini"),

    sheet: document.getElementById("sheet"),
    melodyWrap: document.getElementById("melodyWrap"),
    melodySheet: document.getElementById("melodySheet"),
    melodyStatus: document.getElementById("melodyStatus"),
    leadKey: document.getElementById("leadKey"),

    pianoSvg: document.getElementById("pianoSvg"),
    pianoBox: document.getElementById("pianoBox"),
    fretBox: document.getElementById("fretBox"),
    fretSvg: document.getElementById("fretSvg"),
    pianoTop: document.getElementById("pianoTop"),
    pianoHint: document.getElementById("pianoHint"),
    markerStyle: document.getElementById("markerStyle"),

    progressionLogic: document.getElementById("progressionLogic"),
    genrePreset: document.getElementById("genrePreset"),

    songUrl: document.getElementById("songUrl"),
    btnSongFetch: document.getElementById("btnSongFetch"),
    songFile: document.getElementById("songFile"),
    biabFile: document.getElementById("biabFile"),
    biabStatus: document.getElementById("biabStatus"),
    sfEnabled: document.getElementById("sfEnabled"),
    sfUrl: document.getElementById("sfUrl"),
    btnSfLoad: document.getElementById("btnSfLoad"),
    sfFile: document.getElementById("sfFile"),
    sfStatus: document.getElementById("sfStatus"),
    songSearch: document.getElementById("songSearch"),
    songSort: document.getElementById("songSort"),
    btnSongRandom: document.getElementById("btnSongRandom"),
    songRandomLabel: document.getElementById("songRandomLabel"),
    songList: document.getElementById("songList"),
    songStatus: document.getElementById("songStatus"),

    bars: document.getElementById("bars"),
    barsNum: document.getElementById("barsNum"),
    halfChords: document.getElementById("halfChords"),
    halfDensity: document.getElementById("halfDensity"),
    halfDensityNum: document.getElementById("halfDensityNum"),
    tempo: document.getElementById("tempo"),
    tempoNum: document.getElementById("tempoNum"),
    swing: document.getElementById("swing"),
    swingNum: document.getElementById("swingNum"),
    chaos: document.getElementById("chaos"),
    chaosNum: document.getElementById("chaosNum"),
    complexity: document.getElementById("complexity"),
    complexityMsg: document.getElementById("complexityMsg"),
    rootMode: document.getElementById("rootMode"),
    grooveStyle: document.getElementById("grooveStyle"),
    compStyle: document.getElementById("compStyle"),

    scalesUsed: document.getElementById("scalesUsed"),
    scalesUsedNum: document.getElementById("scalesUsedNum"),
    scaleLimitEnabled: document.getElementById("scaleLimitEnabled"),
    scalesUsedMsg: document.getElementById("scalesUsedMsg"),

    bassPreset: document.getElementById("bassPreset"),
    keysPreset: document.getElementById("keysPreset"),
    drumsPreset: document.getElementById("drumsPreset"),
    drumsLevel: document.getElementById("drumsLevel"),
    drumsLevelNum: document.getElementById("drumsLevelNum"),

    keysComplex: document.getElementById("keysComplex"),
    keysComplexNum: document.getElementById("keysComplexNum"),
    keysFill: document.getElementById("keysFill"),
    keysFillNum: document.getElementById("keysFillNum"),

    bassComplex: document.getElementById("bassComplex"),
    bassComplexNum: document.getElementById("bassComplexNum"),
    bassFill: document.getElementById("bassFill"),
    bassFillNum: document.getElementById("bassFillNum"),

    drumsComplex: document.getElementById("drumsComplex"),
    drumsComplexNum: document.getElementById("drumsComplexNum"),
    drumsFill: document.getElementById("drumsFill"),
    drumsFillNum: document.getElementById("drumsFillNum"),

    pageTheme: document.getElementById("pageTheme"),
    pianoTheme: document.getElementById("pianoTheme"),
    fretTheme: document.getElementById("fretTheme"),
    fretLefty: document.getElementById("fretLefty"),
    fretNumbers: document.getElementById("fretNumbers"),

    advBack: document.getElementById("advBack"),
    btnGear: document.getElementById("btnGear"),
    btnCloseAdv: document.getElementById("btnCloseAdv"),
    btnResetMenu: document.getElementById("btnResetMenu"),
    orderList: document.getElementById("orderList"),

    morphBg: document.getElementById("morphBg"),
    kbOct: document.getElementById("kbOct"),
    kbOctNum: document.getElementById("kbOctNum"),

    // edit modal
    editBack: document.getElementById("editBack"),
    editTitle: document.getElementById("editTitle"),
    btnEditClose: document.getElementById("btnEditClose"),
    btnEditApply: document.getElementById("btnEditApply"),
    btnEditClear: document.getElementById("btnEditClear"),
    btnEditCancel: document.getElementById("btnEditCancel"),
    editRoot: document.getElementById("editRoot"),
    editQual: document.getElementById("editQual"),
    editSlash: document.getElementById("editSlash"),
    editPlace: document.getElementById("editPlace"),
  };

  /* ---------- Old-ish feel dropdowns: restore/expand grooves + comp styles ---------- */
  const GROOVES = [
    {id:"swing", name:"Swing ride"},
    {id:"brushBallad", name:"Brush ballad"},
    {id:"bossa", name:"Bossa"},
    {id:"samba", name:"Samba"},
    {id:"afroCuban", name:"Afro-Cuban"},
    {id:"funk", name:"Funk"},
    {id:"disco", name:"Disco"},
    {id:"rock", name:"Rock"},
    {id:"shuffle", name:"Shuffle"},
    {id:"hiphop", name:"Hip-hop"},
    {id:"boomBap", name:"Boom-bap"},
    {id:"trap", name:"Trap hats"},
    {id:"reggae", name:"Reggae one-drop"},
    {id:"afrobeat", name:"Afrobeat"},
    {id:"halfTime", name:"Half-time"},
    {id:"house", name:"House"},
    {id:"techno", name:"Techno"},
    {id:"dnb", name:"DnB"},
    {id:"breaks", name:"Breakbeat"},
    {id:"ambient", name:"Ambient ticks"},
    {id:"free", name:"Free cymbals"},
  ];

  const COMP_STYLES = [
    {id:"twoStabs", name:"2 stabs"},
    {id:"fourComp", name:"4-to-the-bar"},
    {id:"charleston", name:"Charleston"},
    {id:"anticipations", name:"Anticipations"},
    {id:"pushPull", name:"Push / pull"},
    {id:"sparse", name:"Sparse sync"},
    {id:"arpeggio", name:"Arp flutter"},
    {id:"sustain", name:"Sustain pad"},
    {id:"montuno", name:"Montuno (latin)"},
    {id:"clav", name:"Clav comp (funk)"},
    {id:"rockChugs", name:"Rock chugs"},
    {id:"discoChop", name:"Disco chop"},
    {id:"neoSoulPush", name:"Neo-soul pushes"},
    {id:"edmStab", name:"EDM stabs"},
  ];

  function initFeelDropdowns(){
    E.grooveStyle.innerHTML = "";
    GROOVES.forEach(g=>{
      const o=document.createElement("option");
      o.value=g.id; o.textContent=g.name;
      E.grooveStyle.appendChild(o);
    });
    E.compStyle.innerHTML = "";
    COMP_STYLES.forEach(s=>{
      const o=document.createElement("option");
      o.value=s.id; o.textContent=s.name;
      E.compStyle.appendChild(o);
    });
  }

  const GENRE_BASE = {
    tempo:[120,180], swing:[55,60], groove:"swing", comp:"twoStabs",
    bass:"upright", keys:"piano", drums:"jazz",
    kC:60,kF:30,bC:60,bF:20,dC:70,dF:40, halfOn:true, halfDen:[18,38],
    logic:"jazzFunctional"
  };
  const GP = (cfg)=>({...GENRE_BASE, ...cfg});

  /* ---------- Genre Presets (expanded + old-ish coverage) ---------- */
  const GENRE_PRESETS = {
    modernJazz: { name:"Modern jazz", tempo:[120,190], swing:[56,62], groove:"swing", comp:"twoStabs", bass:"upright", keys:"ep", drums:"jazz",
      kC:60,kF:30,bC:60,bF:22,dC:70,dF:40, halfOn:true, halfDen:[18,38], logic:"jazzFunctional" },
    bebop: { name:"Bebop", tempo:[160,240], swing:[58,64], groove:"swing", comp:"charleston", bass:"upright", keys:"piano", drums:"jazz",
      kC:75,kF:40,bC:72,bF:20,dC:78,dF:40, halfOn:true, halfDen:[22,45], logic:"jazzFunctional" },
    jazzBallad: { name:"Jazz ballad", tempo:[60,110], swing:[54,58], groove:"brushBallad", comp:"sustain", bass:"upright", keys:"ep", drums:"brushes",
      kC:35,kF:20,bC:30,bF:12,dC:45,dF:20, halfOn:false, halfDen:[0,10], logic:"jazzModal" },
    hardBop: { name:"Hard bop", tempo:[130,210], swing:[57,63], groove:"swing", comp:"pushPull", bass:"upright", keys:"piano", drums:"jazz",
      kC:70,kF:35,bC:70,bF:22,dC:78,dF:45, halfOn:true, halfDen:[18,44], logic:"jazzFunctional" },
    bossa: { name:"Bossa", tempo:[120,180], swing:[50,52], groove:"bossa", comp:"montuno", bass:"round", keys:"ep", drums:"perc",
      kC:55,kF:28,bC:55,bF:18,dC:60,dF:35, halfOn:true, halfDen:[14,32], logic:"latinTurns" },
    afroCuban: { name:"Afro-Cuban", tempo:[110,175], swing:[50,54], groove:"afroCuban", comp:"montuno", bass:"round", keys:"organ", drums:"perc",
      kC:60,kF:35,bC:65,bF:22,dC:65,dF:38, halfOn:true, halfDen:[18,40], logic:"latinTurns" },
    funk: { name:"Funk", tempo:[85,115], swing:[50,56], groove:"funk", comp:"clav", bass:"round", keys:"clavBright", drums:"tight",
      kC:70,kF:50,bC:70,bF:35,dC:72,dF:50, halfOn:true, halfDen:[18,44], logic:"neoSoulLogic" },
    neoSoul: { name:"Neo-soul", tempo:[70,110], swing:[50,56], groove:"hiphop", comp:"neoSoulPush", bass:"round", keys:"ep", drums:"lofi",
      kC:68,kF:55,bC:60,bF:35,dC:55,dF:45, halfOn:true, halfDen:[28,55], logic:"neoSoulLogic" },
    disco: { name:"Disco", tempo:[115,132], swing:[50,52], groove:"disco", comp:"discoChop", bass:"pickBass", keys:"clavBright", drums:"disco",
      kC:55,kF:35,bC:55,bF:25,dC:70,dF:40, halfOn:false, halfDen:[0,18], logic:"discoLogic" },
    rock: { name:"Rock", tempo:[90,160], swing:[50,52], groove:"rock", comp:"rockChugs", bass:"pickBass", keys:"organ", drums:"rock",
      kC:55,kF:20,bC:55,bF:10,dC:65,dF:25, halfOn:false, halfDen:[0,12], logic:"rockLogic" },
    ambient: { name:"Ambient", tempo:[55,90], swing:[50,52], groove:"ambient", comp:"sustain", bass:"sub", keys:"pad", drums:"minimal",
      kC:22,kF:20,bC:18,bF:10,dC:18,dF:18, halfOn:false, halfDen:[0,10], logic:"jazzModal" },
    dnb: { name:"DnB", tempo:[160,182], swing:[50,54], groove:"dnb", comp:"edmStab", bass:"reese", keys:"pad", drums:"dnb",
      kC:55,kF:35,bC:65,bF:30,dC:85,dF:55, halfOn:false, halfDen:[0,18], logic:"edmLogic" },
    edm: { name:"EDM", tempo:[118,150], swing:[50,52], groove:"house", comp:"edmStab", bass:"sub", keys:"pad", drums:"house",
      kC:45,kF:25,bC:55,bF:20,dC:80,dF:45, halfOn:false, halfDen:[0,14], logic:"edmLogic" },
    newOrleans: GP({ name:"New Orleans trad", tempo:[95,140], swing:[56,62], comp:"twoStabs", bass:"upright", keys:"piano", drums:"jazz",
      kC:55,kF:22,bC:55,bF:18,dC:68,dF:32, halfDen:[10,26], logic:"tradSwing" }),
    chicagoStyle: GP({ name:"Chicago style", tempo:[105,150], swing:[56,62], comp:"twoStabs", bass:"upright", keys:"piano", drums:"jazz",
      kC:58,kF:24,bC:58,bF:18,dC:70,dF:35, halfDen:[12,28], logic:"tradSwing" }),
    kcSwing: GP({ name:"Kansas City swing", tempo:[115,175], swing:[57,63], comp:"pushPull", bass:"upright", keys:"piano", drums:"jazz",
      kC:62,kF:32,bC:62,bF:24,dC:72,dF:40, halfDen:[16,32], logic:"tradSwing" }),
    swingBigBand: GP({ name:"Swing era big band", tempo:[110,180], swing:[57,63], comp:"fourComp", bass:"upright", keys:"piano", drums:"jazz",
      kC:60,kF:30,bC:60,bF:24,dC:75,dF:45, halfDen:[16,34], logic:"tradSwing" }),
    gypsyJazz: GP({ name:"Gypsy jazz / manouche", tempo:[180,240], swing:[58,64], comp:"fourComp", bass:"upright", keys:"guitarish", drums:"jazz",
      kC:68,kF:32,bC:62,bF:24,dC:74,dF:35, halfOn:false, halfDen:[0,12], logic:"tradSwing" }),
    westCoastCool: GP({ name:"West Coast cool", tempo:[90,130], swing:[54,58], comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:45,kF:22,bC:48,bF:18,dC:55,dF:22, halfOn:false, halfDen:[0,16], logic:"coolModal" }),
    milesCool: GP({ name:"Cool jazz (Miles/Gil)", tempo:[78,118], swing:[53,58], comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:48,kF:24,bC:50,bF:18,dC:55,dF:24, halfOn:false, halfDen:[0,16], logic:"coolModal" }),
    thirdStream: GP({ name:"Third stream", tempo:[70,130], swing:[52,56], comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:50,kF:26,bC:50,bF:18,dC:55,dF:24, halfOn:false, halfDen:[0,14], logic:"cinematicBigBand" }),
    soulJazz: GP({ name:"Soul jazz", tempo:[90,125], swing:[54,58], comp:"pushPull", bass:"upright", keys:"organ", drums:"tight",
      kC:65,kF:40,bC:65,bF:35,dC:70,dF:45, halfOn:true, halfDen:[12,32], logic:"grooveFunk" }),
    organGroove: GP({ name:"Organ trio groove", tempo:[95,135], swing:[54,58], comp:"pushPull", bass:"upright", keys:"organ", drums:"tight",
      kC:60,kF:38,bC:62,bF:32,dC:70,dF:40, halfOn:true, halfDen:[12,30], logic:"grooveFunk" }),
    gospelJazz: GP({ name:"Gospel jazz", tempo:[70,115], swing:[52,56], comp:"sustain", bass:"upright", keys:"ep", drums:"brushes",
      kC:55,kF:35,bC:55,bF:30,dC:60,dF:35, halfOn:false, halfDen:[0,20], logic:"grooveFunk" }),
    jazzBlues: GP({ name:"Jazz blues shuffle", tempo:[95,150], swing:[56,62], comp:"charleston", bass:"upright", keys:"piano", drums:"shuffle",
      kC:60,kF:32,bC:60,bF:26,dC:72,dF:42, halfOn:true, halfDen:[10,28], logic:"bluesLogic" }),
    jazzWaltz: GP({ name:"Jazz waltz", tempo:[85,135], swing:[54,58], comp:"fourComp", bass:"upright", keys:"piano", drums:"brushes",
      kC:55,kF:28,bC:55,bF:22,dC:60,dF:30, halfOn:false, halfDen:[0,18], logic:"tradSwing" }),
    modalJazz: GP({ name:"Modal jazz", tempo:[80,140], swing:[53,57], comp:"sustain", bass:"upright", keys:"piano", drums:"jazz",
      kC:50,kF:26,bC:52,bF:22,dC:55,dF:26, halfOn:true, halfDen:[8,24], logic:"modalSpiritual" }),
    spiritualJazz: GP({ name:"Spiritual jazz", tempo:[70,125], swing:[52,56], comp:"sustain", bass:"upright", keys:"organ", drums:"ambient",
      kC:52,kF:30,bC:52,bF:24,dC:50,dF:26, halfOn:true, halfDen:[10,24], logic:"modalSpiritual" }),
    postBop: GP({ name:"Post-bop", tempo:[110,180], swing:[55,60], comp:"pushPull", bass:"upright", keys:"piano", drums:"jazz",
      kC:62,kF:32,bC:62,bF:24,dC:70,dF:38, halfOn:true, halfDen:[14,30], logic:"coolModal" }),
    ecm: GP({ name:"ECM / Nordic ambient", tempo:[60,110], swing:[50,54], comp:"sustain", bass:"upright", keys:"pad", drums:"ambient",
      kC:35,kF:24,bC:40,bF:18,dC:40,dF:22, halfOn:false, halfDen:[0,12], logic:"ambientModal" }),
    chamberJazz: GP({ name:"Chamber jazz", tempo:[70,125], swing:[50,54], comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:42,kF:24,bC:44,bF:18,dC:45,dF:20, halfOn:false, halfDen:[0,12], logic:"ambientModal" }),
    freeJazz: GP({ name:"Free jazz", tempo:[90,170], swing:[50,56], comp:"sustain", bass:"upright", keys:"piano", drums:"free",
      kC:70,kF:55,bC:70,bF:40,dC:75,dF:55, halfOn:true, halfDen:[10,40], logic:"freeForm" }),
    loftJazz: GP({ name:"Loft jazz", tempo:[85,150], swing:[50,56], comp:"sustain", bass:"upright", keys:"piano", drums:"free",
      kC:68,kF:52,bC:68,bF:36,dC:70,dF:48, halfOn:true, halfDen:[10,36], logic:"freeForm" }),
    avantJazz: GP({ name:"Avant-garde jazz", tempo:[70,150], swing:[50,56], comp:"sustain", bass:"upright", keys:"piano", drums:"free",
      kC:70,kF:60,bC:68,bF:40,dC:72,dF:52, halfOn:true, halfDen:[8,34], logic:"freeForm" }),
    cinematicBigBand: GP({ name:"Modern big band cinematic", tempo:[80,170], swing:[52,58], comp:"fourComp", bass:"upright", keys:"piano", drums:"jazz",
      kC:60,kF:34,bC:60,bF:26,dC:78,dF:46, halfOn:true, halfDen:[12,30], logic:"cinematicBigBand" }),
    brassBand: GP({ name:"Brass band / second line", tempo:[95,150], swing:[56,60], comp:"pushPull", bass:"upright", keys:"piano", drums:"swing",
      kC:60,kF:32,bC:62,bF:26,dC:74,dF:42, halfOn:true, halfDen:[12,26], logic:"tradSwing" }),
    bossaJazz: GP({ name:"Bossa nova jazz", tempo:[120,175], swing:[50,52], groove:"bossa", comp:"montuno", bass:"round", keys:"ep", drums:"perc",
      kC:55,kF:28,bC:55,bF:18,dC:60,dF:35, halfOn:true, halfDen:[14,32], logic:"latinTurns" }),
    sambaJazz: GP({ name:"Samba-jazz (brazuca)", tempo:[120,185], swing:[50,52], groove:"samba", comp:"montuno", bass:"round", keys:"piano", drums:"perc",
      kC:58,kF:32,bC:58,bF:22,dC:65,dF:38, halfOn:true, halfDen:[16,36], logic:"latinTurns" }),
    afroCubanJazz: GP({ name:"Afro-Cuban jazz (clave)", tempo:[105,170], swing:[50,54], groove:"afroCuban", comp:"montuno", bass:"round", keys:"organ", drums:"perc",
      kC:60,kF:35,bC:65,bF:26,dC:68,dF:40, halfOn:true, halfDen:[16,36], logic:"claveDrive" }),
    mamboBigBand: GP({ name:"Mambo big band", tempo:[115,180], swing:[50,54], groove:"afroCuban", comp:"fourComp", bass:"round", keys:"piano", drums:"perc",
      kC:62,kF:34,bC:65,bF:26,dC:72,dF:46, halfOn:true, halfDen:[18,38], logic:"claveDrive" }),
    boleroJazz: GP({ name:"Bolero jazz ballad", tempo:[60,95], swing:[50,52], groove:"afroCuban", comp:"sustain", bass:"upright", keys:"piano", drums:"brushes",
      kC:42,kF:24,bC:44,bF:18,dC:45,dF:24, halfOn:false, halfDen:[0,12], logic:"claveDrive" }),
    afroPeruvian: GP({ name:"Afro-Peruvian jazz (land√≥)", tempo:[70,115], swing:[50,52], groove:"afroCuban", comp:"montuno", bass:"upright", keys:"piano", drums:"perc",
      kC:55,kF:30,bC:55,bF:22,dC:60,dF:38, halfOn:true, halfDen:[10,26], logic:"claveDrive" }),
    flamencoJazz: GP({ name:"Flamenco-jazz", tempo:[90,150], swing:[50,54], groove:"afroCuban", comp:"montuno", bass:"upright", keys:"piano", drums:"perc",
      kC:60,kF:32,bC:60,bF:24,dC:65,dF:40, halfOn:true, halfDen:[12,30], logic:"latinTurns" }),
    calypsoJazz: GP({ name:"Caribbean calypso-jazz", tempo:[100,160], swing:[50,52], groove:"afroCuban", comp:"pushPull", bass:"round", keys:"piano", drums:"perc",
      kC:58,kF:32,bC:58,bF:24,dC:65,dF:40, halfOn:true, halfDen:[12,30], logic:"claveDrive" }),
    skaJazz: GP({ name:"Ska-jazz", tempo:[120,185], swing:[50,52], groove:"rock", comp:"pushPull", bass:"pickBass", keys:"organ", drums:"rock",
      kC:62,kF:32,bC:62,bF:22,dC:70,dF:40, halfOn:false, halfDen:[0,18], logic:"dubReggae" }),
    reggaeJazz: GP({ name:"Reggae / rocksteady jazz", tempo:[80,120], swing:[50,52], groove:"hiphop", comp:"pushPull", bass:"sub", keys:"organ", drums:"minimal",
      kC:55,kF:30,bC:58,bF:26,dC:60,dF:32, halfOn:false, halfDen:[0,14], logic:"dubReggae" }),
    afrobeatFusion: GP({ name:"Afrobeat jazz fusion", tempo:[100,140], swing:[50,54], groove:"afroCuban", comp:"pushPull", bass:"round", keys:"organ", drums:"perc",
      kC:65,kF:38,bC:68,bF:30,dC:72,dF:44, halfOn:true, halfDen:[14,32], logic:"fusionRock" }),
    highlifeFusion: GP({ name:"Highlife jazz fusion", tempo:[100,140], swing:[50,52], groove:"afroCuban", comp:"pushPull", bass:"round", keys:"piano", drums:"perc",
      kC:62,kF:32,bC:62,bF:26,dC:68,dF:40, halfOn:true, halfDen:[12,30], logic:"fusionRock" }),
    latinFunkJazz: GP({ name:"Latin funk-jazz", tempo:[90,125], swing:[50,54], groove:"funk", comp:"clav", bass:"round", keys:"clavBright", drums:"tight",
      kC:70,kF:45,bC:70,bF:35,dC:75,dF:45, halfOn:true, halfDen:[12,28], logic:"grooveFunk" }),
    jazzFunk: GP({ name:"Jazz-funk", tempo:[90,120], swing:[50,54], groove:"funk", comp:"clav", bass:"round", keys:"ep", drums:"tight",
      kC:70,kF:48,bC:70,bF:38,dC:75,dF:48, halfOn:true, halfDen:[10,26], logic:"grooveFunk" }),
    acidJazz: GP({ name:"Acid jazz", tempo:[95,120], swing:[50,54], groove:"funk", comp:"clav", bass:"sub", keys:"organ", drums:"tight",
      kC:65,kF:45,bC:65,bF:35,dC:70,dF:45, halfOn:false, halfDen:[0,22], logic:"grooveFunk" }),
    nuJazz: GP({ name:"Nu jazz", tempo:[95,125], swing:[50,54], groove:"house", comp:"sustain", bass:"round", keys:"pad", drums:"electro",
      kC:58,kF:38,bC:60,bF:30,dC:65,dF:45, halfOn:false, halfDen:[0,22], logic:"brokenBeat" }),
    jazztronica: GP({ name:"Jazztronica", tempo:[95,125], swing:[50,54], groove:"house", comp:"edmStab", bass:"sub", keys:"pad", drums:"electro",
      kC:60,kF:40,bC:60,bF:30,dC:70,dF:48, halfOn:false, halfDen:[0,22], logic:"brokenBeat" }),
    brokenBeatJazz: GP({ name:"Broken beat jazz", tempo:[95,130], swing:[50,54], groove:"breaks", comp:"pushPull", bass:"round", keys:"ep", drums:"breaks",
      kC:62,kF:42,bC:62,bF:32,dC:70,dF:50, halfOn:false, halfDen:[0,20], logic:"brokenBeat" }),
    boomBapJazz: GP({ name:"Hip-hop jazz / boom-bap", tempo:[80,105], swing:[50,54], groove:"hiphop", comp:"neoSoulPush", bass:"sub", keys:"ep", drums:"lofi",
      kC:62,kF:48,bC:60,bF:36,dC:65,dF:50, halfOn:false, halfDen:[0,18], logic:"grooveFunk" }),
    tripHopJazz: GP({ name:"Trip-hop jazz", tempo:[70,100], swing:[50,54], groove:"hiphop", comp:"sustain", bass:"sub", keys:"pad", drums:"lofi",
      kC:55,kF:35,bC:55,bF:30,dC:60,dF:45, halfOn:false, halfDen:[0,18], logic:"brokenBeat" }),
    neoSoulJazz: GP({ name:"Neo-soul jazz", tempo:[70,110], swing:[50,54], groove:"hiphop", comp:"neoSoulPush", bass:"round", keys:"ep", drums:"lofi",
      kC:68,kF:55,bC:60,bF:35,dC:55,dF:45, halfOn:true, halfDen:[24,50], logic:"grooveFunk" }),
    smoothJazz: GP({ name:"Smooth jazz", tempo:[70,110], swing:[50,52], groove:"hiphop", comp:"sustain", bass:"round", keys:"ep", drums:"minimal",
      kC:55,kF:32,bC:55,bF:24,dC:55,dF:32, halfOn:false, halfDen:[0,18], logic:"coolModal" }),
    quietStorm: GP({ name:"Quiet storm jazz", tempo:[65,95], swing:[50,52], groove:"hiphop", comp:"sustain", bass:"sub", keys:"ep", drums:"minimal",
      kC:50,kF:32,bC:50,bF:24,dC:50,dF:32, halfOn:false, halfDen:[0,16], logic:"coolModal" }),
    jazzRockFusion: GP({ name:"Jazz-rock fusion", tempo:[95,150], swing:[50,54], groove:"rock", comp:"pushPull", bass:"pickBass", keys:"organ", drums:"rock",
      kC:70,kF:40,bC:70,bF:30,dC:78,dF:48, halfOn:false, halfDen:[0,20], logic:"fusionRock" }),
    progFusion: GP({ name:"Prog / jazz-metal fusion", tempo:[110,180], swing:[50,54], groove:"rock", comp:"rockChugs", bass:"pickBass", keys:"organ", drums:"rock",
      kC:75,kF:45,bC:75,bF:35,dC:82,dF:52, halfOn:false, halfDen:[0,22], logic:"fusionRock" }),
  };

  /* ---------- Limiters ---------- */
  function getChordLimiterState(){
    const ids = [
      "qMaj7","qMin7","qDom7","qDim7","qHalfDim","qSus","qMinMaj",
      "x9","x11","x13","x6","xAdd9","xSharp11","xMin11",
      "tAlt","tSlash","tChrom","tB9","tSharp9"
    ];
    const out = {};
    for (const id of ids){
      const el = document.getElementById(id);
      if (el && el.type === "checkbox") out[id] = !!el.checked;
    }
    return out;
  }
  function setChordLimiterState(s){
    if (!s) return;
    for (const k of Object.keys(s)){
      const el = document.getElementById(k);
      if (el && el.type === "checkbox") el.checked = !!s[k];
    }
  }

  function buildQualityOptions(limit){
    const opts = [];
    if (limit.qMaj7){
      opts.push({v:{symbol:"maj7", family:"maj", key:"maj7", display:"maj7"}, w:22});
      if (limit.x9) opts.push({v:{symbol:"maj9", family:"maj", key:"maj9", display:"maj9"}, w:12});
      if (limit.x6) opts.push({v:{symbol:"6/9", family:"maj", key:"6/9", display:"6/9"}, w:10});
      if (limit.x6) opts.push({v:{symbol:"maj6", family:"maj", key:"maj6", display:"6"}, w:7});
      if (limit.xAdd9) opts.push({v:{symbol:"add9", family:"maj", key:"add9", display:"add9"}, w:7});
      if (limit.xSharp11 || limit.x11) opts.push({v:{symbol:"maj9sharp11", family:"maj", key:"maj9sharp11", display:"maj9(#11)"}, w:7});
    }
    if (limit.qMin7){
      opts.push({v:{symbol:"min7", family:"min", key:"min7", display:"m7"}, w:20});
      if (limit.x9) opts.push({v:{symbol:"min9", family:"min", key:"min9", display:"m9"}, w:12});
      if (limit.x6) opts.push({v:{symbol:"min6", family:"min", key:"min6", display:"m6"}, w:8});
      if (limit.xMin11 || limit.x11) opts.push({v:{symbol:"min11", family:"min", key:"min11", display:"m11"}, w:8});
    }
    if (limit.qDom7){
      opts.push({v:{symbol:"dom7", family:"dom", key:"dom7", display:"7"}, w:22});
      if (limit.x9) opts.push({v:{symbol:"dom9", family:"dom", key:"dom9", display:"9"}, w:14});
      if (limit.x11) opts.push({v:{symbol:"dom11", family:"dom", key:"dom11", display:"11"}, w:9});
      if (limit.x13) opts.push({v:{symbol:"dom13", family:"dom", key:"dom13", display:"13"}, w:12});
      if (limit.tB9) opts.push({v:{symbol:"dom7b9", family:"dom", key:"dom7b9", display:"7(b9)"}, w:7});
      if (limit.tSharp9) opts.push({v:{symbol:"dom7sharp9", family:"dom", key:"dom7sharp9", display:"7(#9)"}, w:7});
    }
    if (limit.qMinMaj){
      opts.push({v:{symbol:"minMaj7", family:"minmaj", key:"minMaj7", display:"mMaj7"}, w:7});
      if (limit.x9) opts.push({v:{symbol:"minMaj9", family:"minmaj", key:"minMaj9", display:"mMaj9"}, w:5});
    }
    if (limit.qHalfDim) opts.push({v:{symbol:"halfdim", family:"hdim", key:"halfdim", display:"√∏7"}, w:10});
    if (limit.qDim7)    opts.push({v:{symbol:"dim7", family:"dim", key:"dim7", display:"dim7"}, w:8});
    if (limit.qSus){
      opts.push({v:{symbol:"sus", family:"sus", key:"sus", display:"sus"}, w:6});
      if (limit.x9) opts.push({v:{symbol:"7sus", family:"sus", key:"7sus", display:"7sus"}, w:6});
    }
    if (!opts.length) opts.push({v:{symbol:"dom7", family:"dom", key:"dom7", display:"7"}, w:1});
    return opts;
  }

  /* ---------- Progression logic weights ---------- */
  function macroToWeights(chaos){
    const c = clamp(chaos,0,100)/100;
    return {
      keyStability: Math.round(85 - c*75),
      functional:   Math.round(80 - c*70),
      rootChaos:    Math.round(15 + c*80),
      qualityChaos: Math.round(15 + c*75),
      tension:      Math.round(10 + c*80),
      memoryKill:   Math.round(40 + c*50),
    };
  }

  function modeHasLeadingTone(mode){
    const scale = SCALES[mode];
    return scale ? scale.includes(11) : true;
  }

  function degreeIndexForRoot(rootPc, keyRoot, keyMode){
    const scale = SCALES[keyMode];
    if (!scale) return -1;
    const rel = pc(rootPc - keyRoot);
    return scale.indexOf(rel);
  }

  function functionGroupForDegree(deg, hasLeadingTone){
    if (deg < 0) return "other";
    if (deg===0 || deg===2 || deg===5) return "tonic";
    if (deg===1 || deg===3) return "predom";
    if (deg===4) return "dominant";
    if (deg===6) return hasLeadingTone ? "dominant" : "predom";
    return "other";
  }

  function buildCadencePlan(totalBars, keyRoot, keyMode, weights){
    const plan = new Map();
    if (!SCALES[keyMode] || totalBars < 2) return plan;
    const f = clamp(weights.functional,0,100)/100;
    const rootPc = pc(keyRoot);
    const dom = pc(keyRoot + 7);
    const subdom = pc(keyRoot + 5);

    plan.set(totalBars-1, {root: rootPc, weight: 0.45 + 0.45*f});
    plan.set(totalBars-2, {root: dom, weight: 0.25 + 0.35*f});

    if (totalBars >= 6){
      const mid = Math.floor(totalBars/2) - 1;
      if (mid > 0 && mid < totalBars-2){
        plan.set(mid, {root: subdom, weight: 0.18 + 0.25*f});
      }
    }
    return plan;
  }

  const PROGRESSION_LOGICS = {
    none: { name:"None (fully random)", apply:(w)=>({...w}) },
    jazzFunctional: { name:"Jazz: functional gravity", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+22,0,100),
        keyStability:clamp(w.keyStability+14,0,100),
        rootChaos:clamp(w.rootChaos-14,0,100),
        tension:clamp(w.tension+(4+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+2,0,100)
      };
    }},
    jazzModal: { name:"Jazz: modal centers", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-18,0,100),
        keyStability:clamp(w.keyStability+18,0,100),
        rootChaos:clamp(w.rootChaos-12,0,100),
        tension:clamp(w.tension+(2+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos+4,0,100)
      };
    }},
    latinTurns: { name:"Latin: turnarounds + cycles", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+12,0,100),
        keyStability:clamp(w.keyStability+10,0,100),
        rootChaos:clamp(w.rootChaos-10,0,100),
        tension:clamp(w.tension+(6+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos+4,0,100)
      };
    }},
    bluesLogic: { name:"Blues: tension & release", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+14,0,100),
        keyStability:clamp(w.keyStability+20,0,100),
        rootChaos:clamp(w.rootChaos-18,0,100),
        tension:clamp(w.tension+(4+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos-6,0,100)
      };
    }},
    rockLogic: { name:"Rock: diatonic + borrowed", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-4,0,100),
        keyStability:clamp(w.keyStability+22,0,100),
        rootChaos:clamp(w.rootChaos-12,0,100),
        tension:clamp(w.tension+(1+5*c),0,100),
        qualityChaos:clamp(w.qualityChaos+1,0,100)
      };
    }},
    discoLogic: { name:"Disco: bright loops", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+2,0,100),
        keyStability:clamp(w.keyStability+22,0,100),
        rootChaos:clamp(w.rootChaos-14,0,100),
        tension:clamp(w.tension+(2+4*c),0,100),
        qualityChaos:clamp(w.qualityChaos+4,0,100)
      };
    }},
    neoSoulLogic: { name:"Neo-Soul: slippery voiceleading", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-6,0,100),
        keyStability:clamp(w.keyStability+12,0,100),
        rootChaos:clamp(w.rootChaos+2,0,100),
        tension:clamp(w.tension+(6+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+7,0,100)
      };
    }},
    fusionLogic: { name:"Fusion: planing + side-slips", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+4,0,100),
        keyStability:clamp(w.keyStability+8,0,100),
        rootChaos:clamp(w.rootChaos+4,0,100),
        tension:clamp(w.tension+(8+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+9,0,100)
      };
    }},
    tradSwing: { name:"Trad swing gravity", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+16,0,100),
        keyStability:clamp(w.keyStability+18,0,100),
        rootChaos:clamp(w.rootChaos-14,0,100),
        tension:clamp(w.tension+(3+5*c),0,100),
        qualityChaos:clamp(w.qualityChaos-4,0,100)
      };
    }},
    coolModal: { name:"Cool/modal restraint", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-6,0,100),
        keyStability:clamp(w.keyStability+20,0,100),
        rootChaos:clamp(w.rootChaos-10,0,100),
        tension:clamp(w.tension+(1+3*c),0,100),
        qualityChaos:clamp(w.qualityChaos+2,0,100)
      };
    }},
    classicalCommon: { name:"Classical: common-practice cadences", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+22,0,100),
        keyStability:clamp(w.keyStability+24,0,100),
        rootChaos:clamp(w.rootChaos-18,0,100),
        tension:clamp(w.tension-8+3*c,0,100),
        qualityChaos:clamp(w.qualityChaos-8,0,100),
        memoryKill:clamp(w.memoryKill-8,0,100)
      };
    }},
    classicalFugue: { name:"Fugue: strict counterpoint", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+24,0,100),
        keyStability:clamp(w.keyStability+26,0,100),
        rootChaos:clamp(w.rootChaos-20,0,100),
        tension:clamp(w.tension-10+3*c,0,100),
        qualityChaos:clamp(w.qualityChaos-12,0,100),
        memoryKill:clamp(w.memoryKill-12,0,100)
      };
    }},
    bachStyle: { name:"Bach style: chorale gravity", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+20,0,100),
        keyStability:clamp(w.keyStability+22,0,100),
        rootChaos:clamp(w.rootChaos-16,0,100),
        tension:clamp(w.tension-2+4*c,0,100),
        qualityChaos:clamp(w.qualityChaos-6,0,100),
        memoryKill:clamp(w.memoryKill-8,0,100)
      };
    }},
    classicalSymphony: { name:"Symphony: thematic development", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+12,0,100),
        keyStability:clamp(w.keyStability+16,0,100),
        rootChaos:clamp(w.rootChaos-8,0,100),
        tension:clamp(w.tension+2+5*c,0,100),
        qualityChaos:clamp(w.qualityChaos+1,0,100),
        memoryKill:clamp(w.memoryKill-4,0,100)
      };
    }},
    classicalOpera: { name:"Opera: dramatic arcs", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+8,0,100),
        keyStability:clamp(w.keyStability+10,0,100),
        rootChaos:clamp(w.rootChaos+2,0,100),
        tension:clamp(w.tension+10+7*c,0,100),
        qualityChaos:clamp(w.qualityChaos+5,0,100),
        memoryKill:clamp(w.memoryKill+2,0,100)
      };
    }},
    beethovenStyle: { name:"Beethoven style: bold cadences", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+14,0,100),
        keyStability:clamp(w.keyStability+12,0,100),
        rootChaos:clamp(w.rootChaos+2,0,100),
        tension:clamp(w.tension+10+6*c,0,100),
        qualityChaos:clamp(w.qualityChaos+4,0,100),
        memoryKill:clamp(w.memoryKill+2,0,100)
      };
    }},
    romanticChromatic: { name:"Romantic: chromatic drama", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+6,0,100),
        keyStability:clamp(w.keyStability+6,0,100),
        rootChaos:clamp(w.rootChaos+6,0,100),
        tension:clamp(w.tension+14+7*c,0,100),
        qualityChaos:clamp(w.qualityChaos+8,0,100),
        memoryKill:clamp(w.memoryKill+4,0,100)
      };
    }},
    neoClassicalMetal: { name:"Neo-classical metal: virtuosic drive", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+8,0,100),
        keyStability:clamp(w.keyStability+8,0,100),
        rootChaos:clamp(w.rootChaos+10,0,100),
        tension:clamp(w.tension+14+8*c,0,100),
        qualityChaos:clamp(w.qualityChaos+12,0,100),
        memoryKill:clamp(w.memoryKill+8,0,100)
      };
    }},

    modalSpiritual: { name:"Modal / spiritual drift", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-8,0,100),
        keyStability:clamp(w.keyStability+12,0,100),
        rootChaos:clamp(w.rootChaos+2,0,100),
        tension:clamp(w.tension+(4+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos+6,0,100)
      };
    }},
    ambientModal: { name:"Ambient modal centers", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-16,0,100),
        keyStability:clamp(w.keyStability+22,0,100),
        rootChaos:clamp(w.rootChaos-10,0,100),
        tension:clamp(w.tension-4+3*c,0,100),
        qualityChaos:clamp(w.qualityChaos+1,0,100),
        memoryKill:clamp(w.memoryKill-8,0,100)
      };
    }},
    freeForm: { name:"Free / avant", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-18,0,100),
        keyStability:clamp(w.keyStability-4,0,100),
        rootChaos:clamp(w.rootChaos+16,0,100),
        tension:clamp(w.tension+(10+10*c),0,100),
        qualityChaos:clamp(w.qualityChaos+14,0,100),
        memoryKill:clamp(w.memoryKill+12,0,100)
      };
    }},
    cinematicBigBand: { name:"Cinematic big band", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+12,0,100),
        keyStability:clamp(w.keyStability+18,0,100),
        rootChaos:clamp(w.rootChaos-8,0,100),
        tension:clamp(w.tension+(4+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos+4,0,100),
        memoryKill:clamp(w.memoryKill-6,0,100)
      };
    }},
    claveDrive: { name:"Clave-driven", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+10,0,100),
        keyStability:clamp(w.keyStability+12,0,100),
        rootChaos:clamp(w.rootChaos-6,0,100),
        tension:clamp(w.tension+(6+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+2,0,100)
      };
    }},
    grooveFunk: { name:"Groove / funk-jazz", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-4,0,100),
        keyStability:clamp(w.keyStability+6,0,100),
        rootChaos:clamp(w.rootChaos+2,0,100),
        tension:clamp(w.tension+(4+7*c),0,100),
        qualityChaos:clamp(w.qualityChaos+7,0,100)
      };
    }},
    brokenBeat: { name:"Broken beat / nu", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-10,0,100),
        keyStability:clamp(w.keyStability+8,0,100),
        rootChaos:clamp(w.rootChaos+4,0,100),
        tension:clamp(w.tension+(4+6*c),0,100),
        qualityChaos:clamp(w.qualityChaos+9,0,100),
        memoryKill:clamp(w.memoryKill+6,0,100)
      };
    }},
    dubReggae: { name:"Dub / reggae lean", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-12,0,100),
        keyStability:clamp(w.keyStability+14,0,100),
        rootChaos:clamp(w.rootChaos-4,0,100),
        tension:clamp(w.tension-2+3*c,0,100),
        qualityChaos:clamp(w.qualityChaos+2,0,100)
      };
    }},
    fusionRock: { name:"Fusion / rock drive", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional+2,0,100),
        keyStability:clamp(w.keyStability+8,0,100),
        rootChaos:clamp(w.rootChaos+4,0,100),
        tension:clamp(w.tension+(8+8*c),0,100),
        qualityChaos:clamp(w.qualityChaos+7,0,100)
      };
    }},
    edmLogic: { name:"EDM: loop-centric", apply:(w,chaos)=>{
      const c=clamp(chaos,0,100)/100;
      return {...w,
        functional:clamp(w.functional-12,0,100),
        keyStability:clamp(w.keyStability+28,0,100),
        rootChaos:clamp(w.rootChaos-20,0,100),
        tension:clamp(w.tension-4+5*c,0,100),
        qualityChaos:clamp(w.qualityChaos-12+8*c,0,100),
        memoryKill:clamp(w.memoryKill+14,0,100)
      };
    }},
  };

  /* ---------- Quick UI dropdown init ---------- */
  function initLogicDropdown(){
    E.progressionLogic.innerHTML = "";
    for (const [id,o] of Object.entries(PROGRESSION_LOGICS)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = o.name;
      E.progressionLogic.appendChild(opt);
    }
  }
  function initGenreDropdown(){
    E.genrePreset.innerHTML = "";
    for (const [id,g] of Object.entries(GENRE_PRESETS)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = g.name;
      E.genrePreset.appendChild(opt);
    }
  }

  /* ---------- Themes ---------- */
  const PAGE_THEMES = {
    obsidian: { name:"Obsidian", bg:"#0b0f14", a:"rgba(122,162,255,.08)", b:"rgba(182,124,255,.08)", c:"rgba(63,225,139,.05)",
      ink:"#e9eef6", muted:"#9aa6b2", panel:"rgba(255,255,255,.05)", panel2:"rgba(0,0,0,.20)", line:"rgba(255,255,255,.09)" },
    midnight: { name:"Midnight", bg:"#060812", a:"rgba(0,183,255,.08)", b:"rgba(255,77,255,.07)", c:"rgba(255,255,255,.03)",
      ink:"#eef3ff", muted:"#9aa6b2", panel:"rgba(255,255,255,.045)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.085)" },
    parchment:{ name:"Parchment", bg:"#f4f1ea", a:"rgba(47,107,255,.10)", b:"rgba(182,124,255,.10)", c:"rgba(63,225,139,.06)",
      ink:"#1b2230", muted:"#4b5566", panel:"rgba(0,0,0,.04)", panel2:"rgba(0,0,0,.06)", line:"rgba(0,0,0,.12)" },
    terminal: { name:"Terminal (default)", bg:"#020604", a:"rgba(0,255,154,.10)", b:"rgba(0,183,255,.06)", c:"rgba(255,255,255,.03)",
      ink:"#c9ffe8", muted:"#7ad4b0", panel:"rgba(0,255,154,.04)", panel2:"rgba(0,0,0,.32)", line:"rgba(0,255,154,.10)" },
    sunset: { name:"Sunset", bg:"#0a0610", a:"rgba(255,120,80,.10)", b:"rgba(255,77,255,.08)", c:"rgba(122,162,255,.07)",
      ink:"#f6efff", muted:"#b8a7c6", panel:"rgba(255,255,255,.05)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.09)" },
    aurora: { name:"Aurora", bg:"#071019", a:"rgba(42,206,162,.12)", b:"rgba(72,146,255,.10)", c:"rgba(255,198,89,.06)",
      ink:"#e6f3ff", muted:"#8aa3b5", panel:"rgba(255,255,255,.04)", panel2:"rgba(0,0,0,.20)", line:"rgba(255,255,255,.08)" },
    dune: { name:"Dune", bg:"#120f0a", a:"rgba(255,176,90,.10)", b:"rgba(190,137,70,.08)", c:"rgba(99,205,162,.05)",
      ink:"#f6efe4", muted:"#b5a48d", panel:"rgba(255,255,255,.04)", panel2:"rgba(0,0,0,.24)", line:"rgba(255,255,255,.08)" },
    slate: { name:"Slate", bg:"#0c1116", a:"rgba(120,168,205,.10)", b:"rgba(140,122,200,.06)", c:"rgba(90,180,160,.05)",
      ink:"#e6edf5", muted:"#92a1b3", panel:"rgba(255,255,255,.04)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.08)" },
    forest: { name:"Forest", bg:"#08110d", a:"rgba(92,210,128,.12)", b:"rgba(33,146,111,.08)", c:"rgba(255,210,120,.05)",
      ink:"#e6fff0", muted:"#7ea99b", panel:"rgba(255,255,255,.04)", panel2:"rgba(0,0,0,.24)", line:"rgba(255,255,255,.08)" },
    tide: { name:"Tide", bg:"#07121a", a:"rgba(64,200,255,.12)", b:"rgba(68,130,255,.08)", c:"rgba(120,255,200,.05)",
      ink:"#e6f6ff", muted:"#87a4b5", panel:"rgba(255,255,255,.04)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.08)" },
    ember: { name:"Ember", bg:"#140b09", a:"rgba(255,120,70,.12)", b:"rgba(255,90,40,.08)", c:"rgba(255,210,120,.05)",
      ink:"#fff2e8", muted:"#c4a08d", panel:"rgba(255,255,255,.04)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.08)" },
    studio: { name:"Studio", bg:"#0b0c10", a:"rgba(190,190,190,.10)", b:"rgba(70,140,255,.07)", c:"rgba(255,190,90,.05)",
      ink:"#eef0f3", muted:"#98a3af", panel:"rgba(255,255,255,.04)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.08)" },
    peach: { name:"Peach", bg:"#1a0f0c", a:"rgba(255,150,120,.12)", b:"rgba(255,210,160,.10)", c:"rgba(120,210,190,.06)",
      ink:"#fff4ee", muted:"#c9a89a", panel:"rgba(255,255,255,.04)", panel2:"rgba(0,0,0,.22)", line:"rgba(255,255,255,.08)" },
  };

  function initThemeDropdowns(){
    E.pageTheme.innerHTML = "";
    for (const [id,t] of Object.entries(PAGE_THEMES)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = t.name;
      E.pageTheme.appendChild(opt);
    }
  }

  function applyPageTheme(themeId){
    const t = PAGE_THEMES[themeId] || PAGE_THEMES.terminal;
    document.documentElement.style.setProperty("--pageBg", t.bg);
    document.documentElement.style.setProperty("--pageInk", t.ink);
    document.documentElement.style.setProperty("--pageMuted", t.muted);
    document.documentElement.style.setProperty("--pagePanel", t.panel);
    document.documentElement.style.setProperty("--pagePanel2", t.panel2);
    document.documentElement.style.setProperty("--pageLine", t.line);
    document.documentElement.style.setProperty("--pageGlowA", t.a);
    document.documentElement.style.setProperty("--pageGlowB", t.b);
    document.documentElement.style.setProperty("--pageGlowC", t.c);
    state.pageTheme = themeId;
    try{ localStorage.setItem("fm_page_theme", themeId); }catch{}
  }

  const PIANO_THEMES = {
    classic:{ name:"Classic", vars:{ "--accent":"#2f82ff","--good":"#18e07a","--chord":"#ff4dd2","--keyWhite":"#f2f5fb","--keyBlack":"#161b23","--keyBorder":"#c9d3e2","--keyBlackBorder":"#2a3240","--keyBorderStrong":"rgba(0,0,0,.38)" } },
    neon:{ name:"Neon", vars:{ "--accent":"#00c8ff","--good":"#00ff9a","--chord":"#ff4dff","--keyWhite":"#e9f7ff","--keyBlack":"#0b0f14","--keyBorder":"rgba(233,247,255,.45)","--keyBlackBorder":"rgba(255,255,255,.16)","--keyBorderStrong":"rgba(0,0,0,.36)" } },
    mono:{ name:"Mono", vars:{ "--accent":"#9ecbff","--good":"#7cf7b0","--chord":"#ff63d8","--keyWhite":"#0f131a","--keyBlack":"#05070b","--keyBorder":"#6d7686","--keyBlackBorder":"#d5dbe6","--keyBorderStrong":"rgba(255,255,255,.82)" } },
    pastel:{ name:"Pastel", vars:{ "--accent":"#6aa8ff","--good":"#6ff0c8","--chord":"#ff7fcf","--keyWhite":"#f7fbff","--keyBlack":"#141826","--keyBorder":"rgba(255,255,255,.25)","--keyBlackBorder":"rgba(255,255,255,.12)","--keyBorderStrong":"rgba(0,0,0,.34)" } },
  };

  const FRET_THEMES = {
    rosewood:{ name:"Rosewood", vars:{ "--fretWood":"#3a2418", "--fretLine":"rgba(255,255,255,.18)", "--fretLineStrong":"rgba(255,255,255,.45)", "--fretInlay":"rgba(255,255,255,.55)", "--stringColor":"rgba(255,255,255,.70)" } },
    maple:{ name:"Maple", vars:{ "--fretWood":"#e6d4b2", "--fretLine":"rgba(0,0,0,.18)", "--fretLineStrong":"rgba(0,0,0,.48)", "--fretInlay":"rgba(255,255,255,.75)", "--stringColor":"rgba(255,255,255,.75)" } },
    ebony:{ name:"Ebony", vars:{ "--fretWood":"#0d0f13", "--fretLine":"rgba(255,255,255,.20)", "--fretLineStrong":"rgba(255,255,255,.55)", "--fretInlay":"rgba(255,255,255,.60)", "--stringColor":"rgba(255,255,255,.75)" } },
    seafoam:{ name:"Seafoam", vars:{ "--fretWood":"#0f1f20", "--fretLine":"rgba(120,255,214,.30)", "--fretLineStrong":"rgba(120,255,214,.55)", "--fretInlay":"rgba(160,255,230,.65)", "--stringColor":"rgba(200,255,240,.75)" } },
  };

  function initPianoThemeDropdown(){
    E.pianoTheme.innerHTML = "";
    for (const [id,t] of Object.entries(PIANO_THEMES)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = t.name;
      E.pianoTheme.appendChild(opt);
    }
  }

  function initFretThemeDropdown(){
    E.fretTheme.innerHTML = "";
    for (const [id,t] of Object.entries(FRET_THEMES)){
      const opt = document.createElement("option");
      opt.value = id;
      opt.textContent = t.name;
      E.fretTheme.appendChild(opt);
    }
  }

  function applyPianoTheme(id){
    const t = PIANO_THEMES[id] || PIANO_THEMES.classic;
    for (const k of Object.keys(t.vars)) document.documentElement.style.setProperty(k, t.vars[k]);
    state.pianoTheme = id;
    try{ localStorage.setItem("fm_piano_theme", id); }catch{}
  }

  function applyFretTheme(id){
    const t = FRET_THEMES[id] || FRET_THEMES.rosewood;
    for (const k of Object.keys(t.vars)) document.documentElement.style.setProperty(k, t.vars[k]);
    state.fretTheme = id;
    try{ localStorage.setItem("fm_fret_theme", id); }catch{}
  }

  function applyMorphBg(on){
    state.morphBg = !!on;
    document.documentElement.style.setProperty("--morphOn", state.morphBg ? "1" : "0");
    try{ localStorage.setItem("fm_morph_bg", state.morphBg ? "1" : "0"); }catch{}
  }



  /* ---------- iReal playlist loader ---------- */
  const DEFAULT_PLAYLIST_URL = "https://raw.githubusercontent.com/santismo/fakebot/main/real%20playlist.txt";
  const IREAL_MUSIC_PREFIX = "1r34LbKcu7";
  let songLibrary = [];
  let songQuery = "";
  let songSort = "playlist";

  function normalizePlaylistUrl(url){
    let u = String(url || "").trim();
    if (!u) return "";
    const m = u.match(/^https?:\/\/github\.com\/([^/]+)\/([^/]+)\/blob\/([^#?]+)/i);
    if (m){
      u = `https://raw.githubusercontent.com/${m[1]}/${m[2]}/${m[3]}`;
    }
    return u;
  }

  function normalizeSoundFontUrl(url){
    let u = String(url || "").trim();
    if (!u) return "";
    const m = u.match(/^https?:\/\/github\.com\/([^/]+)\/([^/]+)\/blob\/([^#?]+)/i);
    if (m){
      u = `https://raw.githubusercontent.com/${m[1]}/${m[2]}/${m[3]}`;
    }
    return u;
  }

  function parseSongKey(key){
    if (!key) return null;
    const clean = String(key).replace(/\s+/g, "");
    const minor = clean.includes("-");
    const rootName = clean.replace(/[^A-G#b]/g, "");
    if (!rootName) return null;
    const pcVal = NOTE_TO_PC[rootName] ?? 0;
    return { rootPc: pcVal, mode: minor ? "aeolian" : "ionian" };
  }

  function mapIrealQuality(raw){
    if (raw == null) return "maj7";
    const low = String(raw).toLowerCase();
    if (!low) return "maj7";
    const has = (re)=> re.test(low);

    if (has(/m7b5|√∏|h/)) return "√∏7";
    if (has(/dim|o/)) return "dim7";

    const isMinorMajor = has(/-\^|m\^|mmaj|minmaj/);
    const isSus = has(/sus/);
    const isAdd = has(/add/);
    const isMajor = has(/\^|maj/);
    const isMinor = has(/(^|[^a-z])m(?!a)|-|min/);

    const hasB9 = has(/b9/);
    const hasS9 = has(/#9/);
    const hasB13 = has(/b13/);
    const has13 = has(/13/);
    const has11 = has(/11/);
    const has9 = has(/9/);
    const has6 = has(/6/);
    const has7 = has(/7/);
    const has69 = has(/69/);

    if (isMinorMajor) return "mMaj7";
    if (isSus) return (has7 || has9 || has11 || has13) ? "7sus" : "sus";
    if (isAdd && has9) return "add9";
    if (has69) return "6/9";

    if (isMajor){
      if (has9) return "maj9";
      if (has6 && !has7) return "6";
      return "maj7";
    }
    if (isMinor){
      if (has11) return "m11";
      if (has9) return "m9";
      if (has6 && !has7) return "m6";
      return "m7";
    }

    if (hasB9) return "7(b9)";
    if (hasS9) return "7(#9)";
    if (hasB13) return "7(b13)";
    if (has13) return "13";
    if (has11) return "11";
    if (has9) return "9";
    if (has6 && !has7) return "6";
    if (has7) return "7";
    return "7";
  }

  function qualityMetaFromSymbol(sym){
    const map = {
      "maj": {symbol:"maj", family:"maj", key:"maj", display:""},
      "m": {symbol:"min", family:"min", key:"min", display:"m"},
      "min": {symbol:"min", family:"min", key:"min", display:"m"},
      "maj7": {symbol:"maj7", family:"maj", key:"maj7", display:"maj7"},
      "maj9": {symbol:"maj9", family:"maj", key:"maj9", display:"maj9"},
      "6": {symbol:"maj6", family:"maj", key:"maj6", display:"6"},
      "6/9": {symbol:"6/9", family:"maj", key:"6/9", display:"6/9"},
      "add9": {symbol:"add9", family:"maj", key:"add9", display:"add9"},
      "m7": {symbol:"min7", family:"min", key:"min7", display:"m7"},
      "m9": {symbol:"min9", family:"min", key:"min9", display:"m9"},
      "m11": {symbol:"min11", family:"min", key:"min11", display:"m11"},
      "m6": {symbol:"min6", family:"min", key:"min6", display:"m6"},
      "mMaj7": {symbol:"minMaj7", family:"minmaj", key:"minMaj7", display:"mMaj7"},
      "7": {symbol:"dom7", family:"dom", key:"dom7", display:"7"},
      "9": {symbol:"dom9", family:"dom", key:"dom9", display:"9"},
      "11": {symbol:"dom11", family:"dom", key:"dom11", display:"11"},
      "13": {symbol:"dom13", family:"dom", key:"dom13", display:"13"},
      "7(b9)": {symbol:"dom7b9", family:"dom", key:"dom7b9", display:"7(b9)"},
      "7(#9)": {symbol:"dom7sharp9", family:"dom", key:"dom7sharp9", display:"7(#9)"},
      "7(b13)": {symbol:"dom7b13", family:"dom", key:"dom7b13", display:"7(b13)"},
      "sus": {symbol:"sus", family:"sus", key:"sus", display:"sus"},
      "7sus": {symbol:"7sus", family:"sus", key:"7sus", display:"7sus"},
      "√∏7": {symbol:"halfdim", family:"hdim", key:"halfdim", display:"√∏7"},
      "dim7": {symbol:"dim7", family:"dim", key:"dim7", display:"dim7"},
    };
    return map[sym] || {symbol:"dom7", family:"dom", key:"dom7", display:"7"};
  }

  function parseIrealChordSymbol(sym){
    const clean = String(sym || "").trim();
    if (!clean) return null;
    const match = clean.match(/^([A-G])([#b]?)([^/]*)(?:\/([A-G])([#b]?))?$/i);
    if (!match) return null;
    const rootName = match[1].toUpperCase() + (match[2] || "");
    const rootPc = NOTE_TO_PC[rootName];
    if (rootPc == null) return null;
    const qualRaw = match[3] || "";
    const slashName = match[4] ? (match[4].toUpperCase() + (match[5] || "")) : null;
    const symMapped = mapIrealQuality(qualRaw);
    const meta = qualityMetaFromSymbol(symMapped);
    const chord = makeChord(rootPc, meta);
    if (slashName && NOTE_TO_PC[slashName] != null) chord.slash = NOTE_TO_PC[slashName];
    return chord;
  }

  function unscrambleIreal(input){
    let s = String(input || "");
    let r = "";

    while (s.length > 50){
      const p = s.substring(0, 50);
      s = s.substring(50);
      if (s.length < 2){
        r += p;
      } else {
        r += obfusc50(p);
      }
    }
    return r + s;
  }

  function obfusc50(s){
    const chars = s.split("");
    for (let i=0;i<5;i++){
      chars[49 - i] = s[i];
      chars[i] = s[49 - i];
    }
    for (let i=10;i<24;i++){
      chars[49 - i] = s[i];
      chars[i] = s[49 - i];
    }
    return chars.join("");
  }

  function parseIrealMeasures(raw){
    let measures = [];
    let originIndices = [];
    let repeatSections = [];
    let baseIndex = 0;
    let startRepeatLocation = null;
    let lastChord = null;
    let endRepeatLocation = null;
    let timeSignature = null;
    let thirdEndingImminent = false;
    let fineLocation = null;
    let dcAlFineImminent = false;
    let dcAlCodaImminent = false;
    let dsAlCodaImminent = false;
    let codaLocation = null;
    let segnoLocation = null;

    function resetVars(){
      measures = [];
      originIndices = [];
      repeatSections = [];
      baseIndex = 0;
      startRepeatLocation = null;
      endRepeatLocation = null;
      lastChord = null;
      codaLocation = null;
      segnoLocation = null;
      timeSignature = null;
      thirdEndingImminent = false;
      dcAlCodaImminent = false;
      dsAlCodaImminent = false;
      fineLocation = null;
      dcAlFineImminent = false;
    }

    function checkForRepeats(match){
      const tag = (match[1] || "").toLowerCase();
      if (tag === "d.c. al 3rd ending") thirdEndingImminent = true;
      if (tag === "d.c. al fine") dcAlFineImminent = true;
      if (tag === "d.c. al coda") dcAlCodaImminent = true;
      if (tag === "d.s. al coda") dsAlCodaImminent = true;
      if (tag === "fine") fineLocation = measures.length;
    }

    function setTimeSignature(match){
      timeSignature = match[1];
    }

    function getMeasure(idx){
      const m = measures[idx];
      return Array.isArray(m) ? m : null;
    }

    function pushNull(){
      if (measures.length === 0) createNewMeasure();
      measures[measures.length - 1].push(null);
    }

    function repeatLastMeasure(){
      const prev = getMeasure(measures.length - 2);
      if (!prev) return;
      measures[measures.length - 1] = prev;
    }

    function repeatLastMeasureAndAddNew(){
      const prev = getMeasure(measures.length - 1);
      if (!prev){
        createNewMeasure();
        return;
      }
      createNewMeasure();
      measures[measures.length - 1] = prev;
    }

    function repeatLastTwoMeasures(){
      const prev1 = getMeasure(measures.length - 2);
      const prev2 = getMeasure(measures.length - 3);
      if (!prev1 || !prev2) return;
      measures[measures.length - 1] = prev2;
      createNewMeasure();
      measures[measures.length - 1] = prev1;
    }

    function setStartRepeatLocation(){
      createNewMeasure();
      startRepeatLocation = measures.length - 1;
      endRepeatLocation = null;
    }

    function setEndRepeatLocation(match){
      const ending = parseInt(match[1], 10);
      if (ending === 1) endRepeatLocation = measures.length - 1;
    }

    function setSegnoLocation(){
      segnoLocation = measures.length - 1;
    }

    function setCodaLocation(){
      codaLocation = measures.length;
    }

    function createNewMeasure(){
      if (measures.length === 0 || measures[measures.length - 1].length !== 0){
        measures.push([]);
        originIndices.push(baseIndex);
        baseIndex += 1;
      }
    }

    function appendRepeatSlice(start, end){
      if (!Number.isFinite(start) || !Number.isFinite(end)) return;
      const s = Math.max(0, Math.min(start, measures.length));
      const e = Math.max(s, Math.min(end, measures.length));
      if (e <= s) return;
      const startIdx = originIndices[s];
      const endIdx = originIndices[e - 1];
      if (startIdx != null && endIdx != null) repeatSections.push({ start: startIdx, end: endIdx });
      for (let i=s; i<e; i++){
        measures.push(measures[i]);
        originIndices.push(originIndices[i]);
      }
    }

    function repeatEverythingToEndRepeatLocation(){
      if (startRepeatLocation == null){
        createNewMeasure();
        return;
      }
      if (endRepeatLocation == null) endRepeatLocation = measures.length;
      appendRepeatSlice(startRepeatLocation, endRepeatLocation);
      createNewMeasure();
    }

    function repeatRemainingEndings(){
      if (thirdEndingImminent){
        repeatEverythingToEndRepeatLocation();
        thirdEndingImminent = false;
      }
      if (dcAlFineImminent && fineLocation != null){
        appendRepeatSlice(0, fineLocation);
        dcAlFineImminent = false;
      }
      if (dcAlCodaImminent && codaLocation != null){
        appendRepeatSlice(0, codaLocation);
        dcAlCodaImminent = false;
      }
      if (dsAlCodaImminent && segnoLocation != null && codaLocation != null){
        appendRepeatSlice(segnoLocation, codaLocation);
        dsAlCodaImminent = false;
      }
      if (!(thirdEndingImminent || dcAlFineImminent || dcAlCodaImminent || dsAlCodaImminent)){
        createNewMeasure();
      }
    }

    function pushChordInMeasures(match){
      if (measures.length === 0) createNewMeasure();
      let chord = match[0];
      if (chord.startsWith("W") && lastChord){
        chord = chord.replace("W", lastChord);
      } else {
        lastChord = chord.split("/")[0];
      }
      measures[measures.length - 1].push(chord);
    }

    function removeEmptyMeasures(list, origins){
      const out = [];
      const outOrigins = [];
      for (let i=0;i<list.length;i++){
        if (!Array.isArray(list[i]) || list[i].length == 0) continue;
        out.push(list[i]);
        if (origins) outOrigins.push(origins[i]);
      }
      return { measures: out, originIndices: outOrigins };
    }

    const rules = [
      { token: "XyQ", description: "Empty space" },
      { token: /\*\w/, description: "Section marker" },
      { token: /<(.*?)>/, description: "Comments inside carets", operation: checkForRepeats },
      { token: /T(\d+)/, description: "Time signature", operation: setTimeSignature },
      { token: "x", description: "Repeat previous measure in current measure", operation: repeatLastMeasure },
      { token: "Kcl", description: "Repeat previous measure and create new measure", operation: repeatLastMeasureAndAddNew },
      { token: /r|XyQ/, description: "Repeat previous two measures", operation: repeatLastTwoMeasures },
      { token: /Y+/, description: "Vertical spacers" },
      { token: "n", description: "No Chord (N.C)", operation: pushNull },
      { token: "p", description: "Pause slash" },
      { token: "U", description: "Ending measure for player" },
      { token: "S", description: "Segno", operation: setSegnoLocation },
      { token: "Q", description: "Coda", operation: setCodaLocation },
      { token: "{", description: "Start repeat marker", operation: setStartRepeatLocation },
      { token: "}", description: "End repeat marker", operation: repeatEverythingToEndRepeatLocation },
      { token: "LZ|", description: "Bar line", operation: createNewMeasure },
      { token: "|", description: "Bar line", operation: createNewMeasure },
      { token: "LZ", description: "Bar line", operation: createNewMeasure },
      { token: "[", description: "Double bar start", operation: createNewMeasure },
      { token: "]", description: "Double bar end", operation: repeatRemainingEndings },
      { token: /N(\d)/, description: "Numbered endings", operation: setEndRepeatLocation },
      { token: "Z", description: "Final bar line", operation: repeatRemainingEndings },
      { token: /[A-GW]{1}[\+\-\^\dhob#suadlt]*(\/[A-G][#b]?)?/, description: "Chord", operation: pushChordInMeasures }
    ];

    function parse(inputString){
      if (!inputString) return;
      for (let i=0;i<rules.length;i++){
        const rule = rules[i];
        if (typeof rule.token === "string"){
          if (inputString.startsWith(rule.token)){
            if (rule.operation) rule.operation();
            parse(inputString.substring(rule.token.length).trim());
            return;
          }
        } else if (rule.token instanceof RegExp){
          const match = inputString.match(rule.token);
          if (match && match.index === 0){
            if (rule.operation) rule.operation(match);
            parse(inputString.substring(match[0].length).trim());
            return;
          }
        }
        if (i === rules.length - 1 && inputString.length > 1){
          parse(inputString.substring(1));
          return;
        }
      }
    }

    resetVars();
    let cleaned = String(raw || "");
    const prefixIndex = cleaned.indexOf(IREAL_MUSIC_PREFIX);
    if (prefixIndex >= 0){
      cleaned = cleaned.slice(prefixIndex + IREAL_MUSIC_PREFIX.length);
    }
    cleaned = unscrambleIreal(cleaned).trim();
    if (cleaned) parse(cleaned);
    const cleanedMeasures = removeEmptyMeasures(measures, originIndices);
    return { measures: cleanedMeasures.measures, originIndices: cleanedMeasures.originIndices, repeatSections, timeSignature, raw: cleaned };
  }

  function mergeSlashChords(bars){
    if (!Array.isArray(bars) || !bars.length) return;

    // In-bar slash hints: treat dom a semitone below as slash bass.
    bars.forEach((bar)=>{
      const chords = bar?.chords || [];
      if (chords.length !== 2) return;
      const a = chords[0];
      const b = chords[1];
      if (!a || !b || a.slash!=null) return;
      if (b.family !== "dom") return;
      if (pc(b.root - a.root) !== 11) return;
      a.slash = b.root;
      bar.chords = [a];
      bar.split = false;
    });

    // Across-bar slash hints (e.g., G-6 | Gb7).
    for (let i=0;i<bars.length-1;i++){
      const cur = bars[i];
      const next = bars[i+1];
      if (!cur?.chords?.length || !next?.chords?.length) continue;
      if (cur.chords.length !== 1 || next.chords.length !== 1) continue;
      const a = cur.chords[0];
      const b = next.chords[0];
      if (!a || !b || a.slash!=null) continue;
      if (b.family !== "dom") continue;
      if (pc(b.root - a.root) !== 11) continue;
      a.slash = b.root;
      cur.chords = [a];
      cur.split = false;
      bars.splice(i+1, 1);
      i -= 1;
    }
  }

  function parseIrealBars(chart){
    const parsed = parseIrealMeasures(chart);
    const measures = parsed?.measures || [];
    const originIndices = parsed?.originIndices || [];
    const repeatSections = parsed?.repeatSections || [];

    const baseMap = new Map();
    for (let i=0;i<measures.length;i++){
      const origin = (originIndices[i] != null) ? originIndices[i] : i;
      if (!baseMap.has(origin)) baseMap.set(origin, measures[i]);
    }

    const repeatStarts = new Set();
    const repeatEnds = new Set();
    repeatSections.forEach(r=>{
      if (r && typeof r.start === "number") repeatStarts.add(r.start);
      if (r && typeof r.end === "number") repeatEnds.add(r.end);
    });

    const bars = [];
    for (const [origin, measure] of baseMap.entries()){
      if (!Array.isArray(measure) || !measure.length) continue;
      const chordObjs = [];
      for (const sym of measure){
        if (!sym) continue;
        const chord = parseIrealChordSymbol(sym);
        if (chord) chordObjs.push(chord);
        if (chordObjs.length >= 2) break;
      }
      if (!chordObjs.length) continue;
      bars.push({
        split: chordObjs.length > 1,
        chords: chordObjs,
        repeatStart: repeatStarts.has(origin),
        repeatEnd: repeatEnds.has(origin),
        origIndex: origin
      });
    }

    mergeSlashChords(bars);

    const indexMap = new Map();
    bars.forEach((bar, idx)=>{
      indexMap.set(bar.origIndex, idx);
    });

    const playbackOrder = originIndices.map(orig => indexMap.get(orig)).filter(v => v != null);

    bars.forEach((bar)=>{ delete bar.origIndex; });

    return { bars, playbackOrder };
  }

  function parseIrealPlaylist(text){
    const urls = String(text).match(/irealb:\/\/[^\s\]]+/g) || [];
    const songs = [];
    const seen = new Set();

    urls.forEach((url)=>{
      let payload = "";
      try{ payload = decodeURIComponent(url.slice("irealb://".length)); }catch{ payload = url.slice("irealb://".length); }
      const chunks = payload.split("===").filter(s=>s.trim().length);
      chunks.forEach((chunk)=>{
        const parts = chunk.split(/=+/).filter(Boolean);
        if (parts.length < 7) return;

        let title, composer, style, key, transpose, music, compStyle, bpm, repeats;
        if (parts.length === 7){
          [title, composer, style, key, music, bpm, repeats] = parts;
        } else if (parts.length === 8 && parts[4].startsWith(IREAL_MUSIC_PREFIX)){
          [title, composer, style, key, music, compStyle, bpm, repeats] = parts;
        } else if (parts.length === 8 && parts[5].startsWith(IREAL_MUSIC_PREFIX)){
          [title, composer, style, key, transpose, music, compStyle, bpm] = parts;
        } else if (parts.length >= 9){
          [title, composer, style, key, transpose, music, compStyle, bpm, repeats] = parts;
        } else {
          [title, composer, style, key, music] = parts;
        }

        title = (title || "").trim();
        composer = (composer || "").trim();
        style = (style || "").trim();
        key = (key || "").trim();
        if (!title || !music) return;
        if (music.includes("=0=0")) music = music.split("=0=0")[0];

        let parsedBars;
        try{
          parsedBars = parseIrealBars(music);
        } catch {
          return;
        }
        const bars = parsedBars?.bars || [];
        if (!bars.length) return;
        const dedupeKey = `${title}||${composer}||${key}`.toLowerCase();
        if (seen.has(dedupeKey)) return;
        seen.add(dedupeKey);
        songs.push({ title, composer, style, key, bars, playbackOrder: parsedBars.playbackOrder || [] });
      });
    });

    return songs;
  }

  /* ---------- BIAB loader ---------- */
  const BIAB_TICKS_PER_BEAT = 120;
  const BIAB_STYLES = [
    [4,4], [12,8], [4,4], [4,4], [4,4], [4,4], [4,4], [3,4],
    [4,4], [4,4], [4,4], [4,4], [4,4], [4,4], [4,4], [4,4],
    [3,4], [4,4], [4,4], [4,4], [4,4], [12,8], [12,8], [4,4]
  ];
  const BIAB_ROOT_PCS = [0,0,1,2,3,4,5,6,7,8,9,10,11,1,3,6,8,10];
  const BIAB_CHORD_NAMES = {
    1: "",
    2: "Maj",
    3: "5b",
    4: "+",
    5: "6",
    6: "Maj7",
    7: "Maj9",
    8: "Maj9#11",
    9: "Maj13#11",
    10: "Maj13",
    11: "Maj9(no 3)",
    12: "+",
    13: "Maj7#5",
    14: "69",
    15: "2",
    16: "m",
    17: "m+",
    18: "mMaj7",
    19: "m7",
    20: "m9",
    21: "m11",
    22: "m13",
    23: "m6",
    24: "m#5",
    25: "m7#5",
    26: "m69",
    27: "Lyd",
    28: "Maj7Lyd",
    29: "Maj7b5",
    32: "m7b5",
    33: "dim",
    34: "m9b5",
    40: "5",
    56: "7+",
    57: "9+",
    58: "13+",
    59: "(blues)",
    60: "7(Blues)",
    64: "7",
    65: "13",
    66: "7b13",
    67: "7#11",
    68: "13#11",
    69: "7#11b13",
    70: "9",
    72: "9b13",
    73: "9#11",
    74: "13#11",
    75: "9#11b13",
    76: "7b9",
    77: "13b9",
    78: "7b9b13",
    79: "7b9#11",
    80: "13b9#11",
    81: "7b9#11b13",
    82: "7#9",
    83: "13#9",
    84: "7#9b13",
    85: "9#11",
    86: "13#9#11",
    87: "7#9#11b13",
    88: "7b5",
    89: "13b5",
    90: "7b5b13",
    91: "9b5",
    92: "9b5b13",
    93: "7b5b9",
    94: "13b5b9",
    95: "7b5b9b13",
    96: "7b5#9",
    97: "13b5#9",
    98: "7b5#9b13",
    99: "7#5",
    100: "13#5",
    101: "7#5#11",
    102: "13#5#11",
    103: "9#5",
    104: "9#5#11",
    105: "7#5b9",
    106: "13#5b9",
    107: "7#5b9#11",
    108: "13#5b9#11",
    109: "7#5#9",
    110: "13#5#9#11",
    111: "7#5#9#11",
    112: "13#5#9#11",
    113: "7alt",
    128: "7sus",
    129: "13sus",
    130: "7susb13",
    131: "7sus#11",
    132: "13sus#11",
    133: "7sus#11b13",
    134: "9sus",
    135: "9susb13",
    136: "9sus#11",
    137: "13sus#11",
    138: "13sus#11",
    139: "9sus#11b13",
    140: "7susb9",
    141: "13susb9",
    142: "7susb9b13",
    143: "7susb9#11",
    144: "13susb9#11",
    145: "7susb9#11b13",
    146: "7sus#9",
    147: "13sus#9",
    148: "7sus#9b13",
    149: "9sus#11",
    150: "13sus#9#11",
    151: "7sus#9#11b13",
    152: "7susb5",
    153: "13susb5",
    154: "7susb5b13",
    155: "9susb5",
    156: "9susb5b13",
    157: "7susb5b9",
    158: "13susb5b9",
    159: "7susb5b9b13",
    160: "7susb5#9",
    161: "13susb5#9",
    162: "7susb5#9b13",
    163: "7sus#5",
    164: "13sus#5",
    165: "7sus#5#11",
    166: "13sus#5#11",
    167: "9sus#5",
    168: "9sus#5#11",
    169: "7sus#5b9",
    170: "13sus#5b9",
    171: "7sus#5b9#11",
    172: "13sus#5b9#11",
    173: "7sus#5#9",
    174: "13sus#5#9#11",
    175: "7sus#5#9#11",
    176: "13sus#5#9#11",
    177: "4",
    184: "sus",
    185: "dim7",
    186: "sus2",
    187: "maddb13",
    188: "add#13",
    189: "add#11#13",
    190: "add#13",
    191: "6add9",
    192: "sus4",
    193: "11",
    194: "Maj11",
    195: "Tristan",
    196: "m7add11",
    197: "Maj7add13",
    198: "madd9",
    199: "m9Maj7",
    200: "5",
    201: "m11b5",
    202: "dim7add#7",
    203: "aug9",
    204: "omit5",
    205: "aug7",
    206: "aug9",
    207: "aug13",
    210: "Maj7#11",
    211: "Maj9#5",
    212: "Maj7#9",
    213: "add2",
    214: "add9",
    215: "susb9",
    216: "Maj7sus",
    217: "Maj9sus",
    220: "m7b9",
    221: "m7b13",
    222: "Phryg",
    223: "madd2",
    230: "7b9#9",
    240: "sus#4",
    241: "Maj7b13",
  };

  function biabChordNameToSymbol(name){
    const raw = String(name || "").trim();
    if (!raw) return "maj";
    const lower = raw.toLowerCase();
    const has = (s)=> lower.includes(s);
    const starts = (s)=> lower.startsWith(s);

    if (has("sus")){
      return (has("7") || has("9") || has("11") || has("13") || has("b9") || has("#9")) ? "7sus" : "sus";
    }

    if (starts("m") && !starts("maj")){
      if (has("maj7") || has("maj9")) return has("9") ? "mMaj9" : "mMaj7";
      if (has("b5")) return "√∏7";
      if (has("11")) return "m11";
      if (has("9")) return "m9";
      if (has("6") && !has("7")) return "m6";
      if (has("7")) return "m7";
      return "m";
    }

    if (has("dim")) return "dim7";
    if (has("tristan")) return "dim7";
    if (has("lyd")) return "maj9sharp11";
    if (has("phryg")) return "m7";

    if (starts("maj") || has("maj")){
      if (has("#11")) return "maj9sharp11";
      if (has("69") || (has("6") && has("9"))) return "6/9";
      if (has("11")) return "maj9";
      if (has("9")) return "maj9";
      if (has("13")) return "maj9";
      if (has("7")) return "maj7";
      if (has("6")) return "6";
      if (has("add") || has("2")) return "add9";
      return "maj";
    }

    if (has("add")){
      if (has("6") && has("9")) return "6/9";
      if (has("9") || has("2")) return "add9";
    }

    if (raw == "4") return "sus";
    if (raw == "5" || raw == "5b" || raw == "5#") return "maj";
    if (has("omit5")) return "maj";

    if (has("alt")) return "7";
    if (has("b9") && has("#9")) return "7(b9)";
    if (has("#9")) return "7(#9)";
    if (has("b9")) return "7(b9)";
    if (has("b13")) return "7(b13)";
    if (has("13")) return "13";
    if (has("11")) return "11";
    if (has("9")) return "9";
    if (has("7")) return "7";
    if (has("6") && !has("7")) return "6";
    return "maj";
  }

  function biabChordSymbolFromId(id){
    if (!Number.isFinite(id)) return "7";
    if (!Object.prototype.hasOwnProperty.call(BIAB_CHORD_NAMES, id)) return "7";
    return biabChordNameToSymbol(BIAB_CHORD_NAMES[id]);
  }


  const BIAB_EXTS = new Set(["mgu","sgu","mg1","sg1","mg2","sg2","mg3","sg3","mg4","sg4","mg5","sg5"]);
  function isBiabFileName(name){
    const ext = String(name || "").split(".").pop().toLowerCase();
    return BIAB_EXTS.has(ext);
  }


  let melodyTimers = [];
  const melodyActive = new Map();

  function setBiabStatus(text){
    if (E.biabStatus) E.biabStatus.textContent = text;
  }

  function setMelodyStatus(text){
    if (E.melodyStatus) E.melodyStatus.textContent = text;
  }

  function clearMelodyTimers(){
    melodyTimers.forEach((id)=> window.clearTimeout(id));
    melodyTimers = [];
    melodyActive.clear();
  }

  function setMelodyActive(midi, on){
    if (!Number.isFinite(midi)) return;
    const key = Math.round(midi);
    const cur = melodyActive.get(key) || 0;
    if (on) melodyActive.set(key, cur + 1);
    else if (cur <= 1) melodyActive.delete(key);
    else melodyActive.set(key, cur - 1);
    renderPianoForActive();
  }

  function getActiveMelodyPcs(){
    const pcs = new Set();
    melodyActive.forEach((count, midi)=>{
      if (count > 0) pcs.add(pc(midi));
    });
    return pcs;
  }

  function clearBiab(){
    state.biabActive = false;
    state.biabMeta = null;
    state.biabMelody = [];
    state.biabMelodyBars = [];
    state.biabDisplayBars = [];
    state.biabMidiBars = [];
    state.biabMidiPrograms = [];
    state.biabMelodyGenerated = false;
    clearMelodyTimers();
    if (E.melodyWrap) E.melodyWrap.classList.remove("on");
    if (E.melodySheet) E.melodySheet.innerHTML = "";
    setMelodyStatus("No BIAB melody loaded.");
    setBiabStatus(" ");
  }

  function readU8(data, idx){
    return data[idx] || 0;
  }

  function readU16(data, idx){
    return (data[idx] || 0) + ((data[idx + 1] || 0) << 8);
  }

  function readU32(data, idx){
    return (readU16(data, idx) + (readU16(data, idx + 2) << 16)) >>> 0;
  }

  function readAscii(data, idx, len){
    let out = "";
    for (let i=0;i<len && idx + i < data.length;i++){
      const v = data[idx + i];
      if (v === 0) break;
      out += String.fromCharCode(v);
    }
    return out;
  }

  function biabSymbolToMeta(sym){
    if (sym === "maj9sharp11") return {symbol:"maj9sharp11", family:"maj", key:"maj9sharp11", display:"maj9(#11)"};
    if (sym === "mMaj9") return {symbol:"minMaj9", family:"minmaj", key:"minMaj9", display:"mMaj9"};
    return qualityMetaFromSymbol(sym);
  }

  function biabChordFromRaw(raw){
    const rootPc = BIAB_ROOT_PCS[raw.root] ?? 0;
    const sym = biabChordSymbolFromId(raw.ext);
    const meta = biabSymbolToMeta(sym);
    const chord = makeChord(rootPc, meta);
    if (raw.bass){
      const bassPc = BIAB_ROOT_PCS[raw.bass];
      if (bassPc != null && pc(bassPc) !== pc(rootPc)) chord.slash = bassPc;
    }
    return chord;
  }

  function biabChordEqual(a,b){
    if (!a || !b) return false;
    const aSlash = (a.slash!=null) ? pc(a.slash) : null;
    const bSlash = (b.slash!=null) ? pc(b.slash) : null;
    return pc(a.root)===pc(b.root) && a.symbol===b.symbol && aSlash===bSlash;
  }

  function biabChordsToBars(rawChords, measures, beatsPerBar){
    const sorted = rawChords.filter(c => Number.isFinite(c.beat) && c.root != null && c.ext != null)
      .sort((a,b)=>a.beat-b.beat);
    if (!sorted.length) return [];
    if (sorted[0].beat > 0){
      sorted.unshift({ ...sorted[0], beat: 0 });
    }
    const lastBeat = sorted[sorted.length - 1].beat || 0;
    const totalBars = Math.max(1, measures || Math.ceil((lastBeat + beatsPerBar) / beatsPerBar));
    const bars = [];
    let idx = 0;
    let current = sorted[0];

    for (let b=0;b<totalBars;b++){
      const barStart = b * beatsPerBar;
      const halfBeat = barStart + beatsPerBar / 2;
      while (idx + 1 < sorted.length && sorted[idx + 1].beat <= barStart){
        idx++;
        current = sorted[idx];
      }
      const first = biabChordFromRaw(current);

      let halfIdx = idx;
      let halfRaw = current;
      while (halfIdx + 1 < sorted.length && sorted[halfIdx + 1].beat <= halfBeat){
        halfIdx++;
        halfRaw = sorted[halfIdx];
      }
      const second = biabChordFromRaw(halfRaw);
      const split = !biabChordEqual(first, second);
      bars.push({ split, chords: split ? [first, second] : [first] });
    }
    return bars;
  }


  function biabChordsToDisplayBars(rawChords, measures, beatsPerBar){
    const sorted = rawChords.filter(c => Number.isFinite(c.beat) && c.root != null && c.ext != null)
      .sort((a,b)=>a.beat-b.beat);
    if (!sorted.length) return [];
    if (sorted[0].beat > 0){
      sorted.unshift({ ...sorted[0], beat: 0 });
    }
    const totalBars = Math.max(1, measures || Math.ceil((sorted[sorted.length - 1].beat + beatsPerBar) / beatsPerBar));
    const bars = [];
    let idx = 0;
    let current = sorted[0];
    for (let b=0;b<totalBars;b++){
      const slots = [];
      for (let beat=0; beat<beatsPerBar; beat++){
        const absBeat = b * beatsPerBar + beat;
        while (idx + 1 < sorted.length && sorted[idx + 1].beat <= absBeat){
          idx++;
          current = sorted[idx];
        }
        slots.push(current ? biabChordFromRaw(current) : null);
      }
      bars.push({ slots });
    }
    return bars;
  }

  function pickMelodyChannel(events){
    const stats = channelStats(events);
    let best = null;
    stats.forEach((stat, ch)=>{
      if (ch === 9) return;
      const polyRatio = stat.onsetCount ? (stat.polyOnsets / stat.onsetCount) : 0;
      const monoScore = (1 - polyRatio) * 2 + (1 / Math.max(1, stat.avgChordSize || 1));
      const pitchScore = (stat.avgPitch / 24) + (stat.pitchSpan > 12 ? 0.2 : 0);
      const densityScore = stat.noteCount / 200;
      const score = monoScore + pitchScore + densityScore;
      if (!best || score > best.score){
        best = { ch, score };
      }
    });
    return best ? best.ch : null;
  }

  function channelStats(events){
    const byChannel = new Map();
    (events || []).forEach((e)=>{
      const ch = Number.isFinite(e.channel) ? e.channel : 0;
      let stat = byChannel.get(ch);
      if (!stat){
        stat = {
          noteCount: 0,
          onsetCounts: new Map(),
          polyOnsets: 0,
          avgChordSize: 0,
          sumPitch: 0,
          minPitch: Number.POSITIVE_INFINITY,
          maxPitch: Number.NEGATIVE_INFINITY
        };
        byChannel.set(ch, stat);
      }
      stat.noteCount += 1;
      if (Number.isFinite(e.midi)){
        stat.sumPitch += e.midi;
        if (e.midi < stat.minPitch) stat.minPitch = e.midi;
        if (e.midi > stat.maxPitch) stat.maxPitch = e.midi;
      }
      const key = Math.round(e.tick || 0);
      stat.onsetCounts.set(key, (stat.onsetCounts.get(key) || 0) + 1);
    });
    byChannel.forEach((stat)=>{
      let onsets = 0;
      let total = 0;
      let poly = 0;
      stat.onsetCounts.forEach((count)=>{
        onsets += 1;
        total += count;
        if (count >= 2) poly += 1;
      });
      stat.onsetCount = onsets;
      stat.polyOnsets = poly;
      stat.avgChordSize = onsets ? (total / onsets) : 0;
      stat.avgPitch = stat.noteCount ? (stat.sumPitch / stat.noteCount) : 0;
      stat.pitchSpan = Number.isFinite(stat.minPitch) && Number.isFinite(stat.maxPitch)
        ? (stat.maxPitch - stat.minPitch)
        : 0;
    });
    return byChannel;
  }

  function pickCompChannel(events, melodyChannel){
    const stats = channelStats(events);
    let best = null;
    stats.forEach((stat, ch)=>{
      if (ch === melodyChannel || ch === 9) return;
      if (stat.avgChordSize < 1.3 && stat.polyOnsets < 1) return;
      const score = stat.polyOnsets * 2 + stat.avgChordSize + (stat.noteCount / 50);
      if (!best || score > best.score){
        best = { ch, score, noteCount: stat.noteCount };
      }
    });
    if (best) return best.ch;
    stats.forEach((stat, ch)=>{
      if (ch === melodyChannel || ch === 9) return;
      if (!best || stat.noteCount > best.noteCount){
        best = { ch, noteCount: stat.noteCount };
      }
    });
    return best ? best.ch : null;
  }

  function notesInWindow(events, start, end){
    const list = [];
    (events || []).forEach((e)=>{
      if (!Number.isFinite(e.tick) || !Number.isFinite(e.dur)) return;
      const eEnd = e.tick + e.dur;
      if (e.tick < end && eEnd > start) list.push(e);
    });
    return list;
  }

  function chordFromNotes(notes){
    const pcs = new Map();
    let bassMidi = null;
    (notes || []).forEach((n)=>{
      if (!Number.isFinite(n.midi)) return;
      const p = pc(n.midi);
      pcs.set(p, (pcs.get(p) || 0) + 1);
      if (bassMidi == null || n.midi < bassMidi) bassMidi = n.midi;
    });
    const pcList = [...pcs.keys()];
    if (pcList.length < 2) return null;
    const symbols = ["maj","maj7","maj6","6/9","add9","m","m7","m6","m9","m11","mMaj7","7","9","13","sus","7sus","√∏7","dim7"];
    let best = null;
    for (let root=0; root<12; root++){
      for (const sym of symbols){
        const meta = qualityMetaFromSymbol(sym);
        const intervals = CHORDS[meta.key] || CHORDS[meta.symbol];
        if (!intervals || !intervals.length) continue;
        const chordPcs = intervals.map(iv => pc(root + iv));
        let match = 0;
        chordPcs.forEach((p)=>{ if (pcs.has(p)) match += 1; });
        const missing = chordPcs.length - match;
        const extras = pcList.length - match;
        let score = match * 2 - missing * 0.7 - extras * 0.35;
        if (pcs.has(root)) score += 1.2;
        score += (pcs.get(root) || 0) * 0.08;
        if (!best || score > best.score || (score === best.score && chordPcs.length < best.size)){
          best = { root, meta, score, size: chordPcs.length, chordPcs };
        }
      }
    }
    if (!best || best.score < 2.5) return null;
    const chord = makeChord(best.root, best.meta);
    const bassPc = (bassMidi != null) ? pc(bassMidi) : null;
    if (bassPc != null && bassPc !== pc(chord.root) && best.chordPcs.includes(bassPc)){
      chord.slash = bassPc;
    }
    return chord;
  }

  function buildMidiChordBars(events, barTicks, barCount, melodyChannel){
    if (!events || !events.length) return [];
    const compChannel = pickCompChannel(events, melodyChannel);
    const stats = channelStats(events);
    let compChannels = [];
    if (compChannel != null){
      compChannels = [compChannel];
      stats.forEach((stat, ch)=>{
        if (ch === melodyChannel || ch === 9 || ch === compChannel) return;
        if (stat.avgChordSize >= 1.6 || stat.polyOnsets >= 2) compChannels.push(ch);
      });
    } else {
      stats.forEach((stat, ch)=>{
        if (ch === melodyChannel || ch === 9) return;
        if (stat.avgChordSize >= 1.3 || stat.polyOnsets > 0) compChannels.push(ch);
      });
    }
    if (!compChannels.length) return [];
    const compEvents = events.filter(e => compChannels.includes((Number.isFinite(e.channel) ? e.channel : 0)));
    if (!compEvents.length) return [];

    const bars = [];
    const halfTicks = barTicks / 2;
    for (let b=0; b<barCount; b++){
      const barStart = b * barTicks;
      const firstNotes = notesInWindow(compEvents, barStart, barStart + halfTicks);
      const secondNotes = notesInWindow(compEvents, barStart + halfTicks, barStart + barTicks);
      const first = chordFromNotes(firstNotes);
      const second = chordFromNotes(secondNotes);
      if (first && second && !biabChordEqual(first, second)){
        bars.push({ split: true, chords: [first, second] });
      } else if (first || second){
        bars.push({ split: false, chords: [first || second] });
      } else {
        bars.push({ split: false, chords: [] });
      }
    }

    let last = null;
    bars.forEach((bar)=>{
      if (!bar.chords.length && last) bar.chords = [last];
      if (bar.chords.length) last = bar.chords[bar.chords.length - 1];
    });
    return bars;
  }

  function buildMelodyBars(events, barTicks, barCount){
    const bars = Array.from({length: barCount}, () => []);
    let noteId = 0;
    (events || []).forEach((note)=>{
      if (!note || !Number.isFinite(note.tick) || !Number.isFinite(note.dur) || !Number.isFinite(note.midi)) return;
      let tick = note.tick;
      let dur = note.dur;
      const channel = Number.isFinite(note.channel) ? note.channel : 0;
      const vel = Number.isFinite(note.vel) ? note.vel : 90;
      const id = noteId++;
      let firstSlice = true;
      while (dur > 0){
        const barIdx = Math.floor(tick / barTicks);
        if (barIdx < 0 || barIdx >= barCount) break;
        if (!bars[barIdx]) bars[barIdx] = [];
        const barStart = barIdx * barTicks;
        const relStart = tick - barStart;
        const remaining = Math.max(0, barTicks - relStart);
        const slice = Math.min(dur, remaining);
        if (slice > 0){
          const tieIn = !firstSlice;
          const tieOut = dur > slice;
          bars[barIdx].push({
            start: relStart,
            dur: slice,
            midi: note.midi,
            vel,
            channel,
            id,
            tieIn,
            tieOut
          });
        }
        tick += slice;
        dur -= slice;
        firstSlice = false;
        if (slice <= 0) break;
      }
    });
    bars.forEach(list => list.sort((a,b)=>a.start-b.start));
    return bars;
  }


  function extractMelodyLine(events){
    const byStart = new Map();
    events.forEach((e)=>{
      if (!Number.isFinite(e.tick) || !Number.isFinite(e.dur)) return;
      if (!Number.isFinite(e.midi)) return;
      const list = byStart.get(e.tick) || [];
      list.push(e);
      byStart.set(e.tick, list);
    });
    const starts = [...byStart.keys()].sort((a,b)=>a-b);
    const out = [];
    for (let i=0;i<starts.length;i++){
      const tick = starts[i];
      const list = byStart.get(tick) || [];
      list.sort((a,b)=> (b.midi - a.midi) || (b.vel - a.vel) || (b.dur - a.dur));
      const picked = list[0];
      if (!picked) continue;
      const nextTick = (i+1 < starts.length) ? starts[i+1] : null;
      let dur = picked.dur;
      if (nextTick != null && picked.tick + dur > nextTick){
        dur = Math.max(1, nextTick - picked.tick);
      }
      out.push({ ...picked, dur });
    }
    return out;
  }

  function generateFallbackMelody(bars, barTicks){
    const events = [];
    const baseMidi = 60;
    bars.forEach((bar, idx)=>{
      const chords = bar?.chords || [];
      if (!chords.length) return;
      const first = chords[0];
      const second = chords[1] || first;
      if (bar.split){
        events.push({ tick: idx * barTicks, dur: barTicks / 2, midi: baseMidi + pc(first.root), vel: 92, channel: 0 });
        events.push({ tick: idx * barTicks + barTicks / 2, dur: barTicks / 2, midi: baseMidi + pc(second.root), vel: 92, channel: 0 });
      } else {
        events.push({ tick: idx * barTicks, dur: barTicks, midi: baseMidi + pc(first.root), vel: 90, channel: 0 });
      }
    });
    return events;
  }

  function parseBiabBuffer(buffer, fileName){
    const data = new Uint8Array(buffer);
    if (!data.length) return null;
    const eventStart = readU16(data, data.length - 4);
    const eventCount = readU16(data, data.length - 2);
    const chordLimit = (eventStart && eventStart > 0 && eventStart < data.length) ? eventStart : data.length;
    let idx = 0;
    const titleLen = readU8(data, idx + 1);
    const title = readAscii(data, idx + 2, titleLen);
    idx += 2 + titleLen;
    idx += 2;

    const style = readU8(data, idx) - 1;
    idx += 1;
    const keyIdx = readU8(data, idx);
    idx += 1;
    const bpm = readU8(data, idx) + (readU8(data, idx + 1) << 8);
    idx += 2;
    idx += 2;

    const sig = BIAB_STYLES[style] || [4,4];
    const beatsPerBar = sig[0] || 4;
    const beatUnit = sig[1] || 4;
    const beatScale = beatsPerBar / beatUnit;

    let bar = readU8(data, idx);
    idx += 1;
    while (bar < 255 && idx < chordLimit){
      const val = readU8(data, idx);
      idx += 1;
      if (val == 0){
        bar += readU8(data, idx);
        idx += 1;
      } else {
        bar += 1;
      }
    }

    const rawChords = [];
    let beat = 0;
    while (beat < (255 * 4) && idx < chordLimit){
      const val = readU8(data, idx);
      idx += 1;
      if (val == 0){
        beat += readU8(data, idx);
        idx += 1;
      } else {
        rawChords.push({ beat, ext: val });
        beat += 1;
      }
    }

    let roots = 0;
    beat = 0;
    while (beat < (255 * 4) && idx < chordLimit){
      const val = readU8(data, idx);
      idx += 1;
      if (val == 0){
        beat += readU8(data, idx);
        idx += 1;
      } else {
        const root = val % 18;
        let bass = (root - 1 + Math.floor(val / 18)) % 18 + 1;
        if (root == bass) bass = 0;
        if (rawChords[roots]){
          rawChords[roots].root = root;
          rawChords[roots].bass = bass;
        }
        roots += 1;
        beat += 1;
      }
    }


    const firstChord = rawChords.find(c => c.root != null && c.ext != null);
    if (firstChord && firstChord.beat > 0 && !rawChords.some(c => c.beat === 0)){
      let seed = null;
      for (const c of rawChords){
        if (c.root == null || c.ext == null) continue;
        const sym = biabChordSymbolFromId(c.ext);
        const meta = biabSymbolToMeta(sym);
        if (meta.family === "maj"){
          seed = c;
          break;
        }
      }
      seed = seed || firstChord;
      rawChords.unshift({ beat: 0, root: seed.root, bass: seed.bass || 0, ext: seed.ext, synthetic: true });
    }

    const oddBeats = rawChords.filter(c => (c.beat % 2) === 1).length;
    const needsHalf = rawChords.length && (oddBeats / rawChords.length) > 0.6;
    rawChords.forEach(c => {
      c.beat = c.beat * beatScale;
    });
    const maxBeat = rawChords.reduce((m,c)=> Math.max(m, Number.isFinite(c.beat) ? c.beat : 0), 0);

    let measures = Math.floor((maxBeat + beatsPerBar - 1) / beatsPerBar) + 1;
    if (readU8(data, idx) === 1) idx += 1;
    const startChorus = readU8(data, idx);
    idx += 1;
    const endChorus = readU8(data, idx);
    idx += 1;
    idx += 1;
    if (endChorus && endChorus > startChorus && endChorus <= 255){
      measures = endChorus;
    }
    const biabBars = biabChordsToBars(rawChords, measures, beatsPerBar);
    const displayBars = biabChordsToDisplayBars(rawChords, measures, beatsPerBar);

    let events = [];
    const barTicks = BIAB_TICKS_PER_BEAT * 4 * (beatsPerBar / beatUnit);
    const endTick = measures * barTicks;
    if (eventCount && eventStart && eventStart + eventCount * 12 <= data.length){
      let eidx = eventStart;
      let lastLen = 0;
      for (let i=0;i<eventCount && eidx + 12 <= data.length - 4;i++){
        const rawTick = readU32(data, eidx);
        const status = readU8(data, eidx + 4);
        const data1 = readU8(data, eidx + 5);
        const data2 = readU8(data, eidx + 6);
        const statusCh = status & 0x0F;
        let channel = readU8(data, eidx + 7);
        if (channel > 15 || (channel === 0 && statusCh !== 0)) channel = statusCh;
        let dur = readU32(data, eidx + 8);
        if (dur === 0) dur = lastLen;
        if (dur > 0) lastLen = dur;
        if ((status & 0xF0) === 0x90 && data2 > 0){
          let tick = rawTick - (BIAB_TICKS_PER_BEAT * 4);
          if (tick < 0) tick = 0;
          if (tick < endTick){
            events.push({ tick, dur, midi: data1, vel: data2, channel });
          }
        }
        eidx += 12;
      }
    }

    const allEvents = events.slice();
    const melodyChannel = pickMelodyChannel(allEvents);

    const midiChordBars = buildMidiChordBars(allEvents, barTicks, biabBars.length, melodyChannel);
    const bars = midiChordBars.length ? midiChordBars : biabBars;

    const midiPrograms = [];
    if (eventCount && eventStart && eventStart + eventCount * 12 <= data.length){
      const bankMsb = new Array(16).fill(0);
      const bankLsb = new Array(16).fill(0);
      const programs = new Array(16).fill(null);
      let eidx = eventStart;
      for (let i=0;i<eventCount && eidx + 12 <= data.length - 4;i++){
        const status = readU8(data, eidx + 4);
        const data1 = readU8(data, eidx + 5);
        const data2 = readU8(data, eidx + 6);
        const statusCh = status & 0x0F;
        let channel = readU8(data, eidx + 7);
        if (channel > 15 || (channel === 0 && statusCh !== 0)) channel = statusCh;
        const type = status & 0xF0;
        if (type === 0xB0){
          if (data1 === 0) bankMsb[channel] = data2;
          if (data1 === 32) bankLsb[channel] = data2;
        } else if (type === 0xC0){
          programs[channel] = data1;
        }
        eidx += 12;
      }
      for (let ch=0; ch<16; ch++){
        if (programs[ch] == null) continue;
        const bank = bankMsb[ch] * 128 + bankLsb[ch];
        midiPrograms.push({ channel: ch, program: programs[ch], bank });
      }
    }

    let melodyEvents = events;
    if (melodyChannel != null){
      melodyEvents = melodyEvents.filter(e => e.channel === melodyChannel);
    }
    melodyEvents = extractMelodyLine(melodyEvents);

    let melodyGenerated = false;
    if (!melodyEvents.length){
      melodyEvents = generateFallbackMelody(bars, barTicks);
      melodyGenerated = true;
    }
    let melodyBars = buildMelodyBars(melodyEvents, barTicks, bars.length);
    const firstMelodyBar = melodyBars.findIndex(bar => bar && bar.length);
    if (firstMelodyBar > 0 && bars?.[0]?.chords?.length){
      // BIAB often includes a lead-in bar; only pull one bar to avoid erasing real intros.
      const shiftBars = Math.min(1, firstMelodyBar);
      const shiftTicks = shiftBars * barTicks;
      if (shiftTicks > 0){
        melodyEvents = melodyEvents.map(e => ({ ...e, tick: Math.max(0, e.tick - shiftTicks) }));
        melodyBars = buildMelodyBars(melodyEvents, barTicks, bars.length);
      }
    }
    const midiBars = (allEvents.length
      ? buildMelodyBars(allEvents, barTicks, bars.length)
      : buildMelodyBars(melodyEvents, barTicks, bars.length));

    return {
      title: title || fileName || "Untitled",
      tempo: bpm || 120,
      bars,
      displayBars,
      melodyEvents: melodyEvents,
      melodyBars,
      midiBars,
      midiPrograms,
      barTicks,
      ticksPerBeat: BIAB_TICKS_PER_BEAT,
      timeSig: { num: beatsPerBar, den: beatUnit },
      melodyGenerated
    };
  }

  async function loadBiabFromFile(file){
    if (!file) return;
    setBiabStatus(`Loading ${file.name}...`);
    try{
      const buffer = await file.arrayBuffer();
      const parsed = parseBiabBuffer(buffer, file.name);
      if (!parsed || !parsed.bars || !parsed.bars.length){
        setBiabStatus("Could not parse BIAB file.");
        return;
      }
      clearBiab();

      state.biabActive = true;
      state.biabMeta = { title: parsed.title, tempo: parsed.tempo, fileName: file.name };
      state.biabMelody = parsed.melodyEvents || [];
      state.biabMelodyBars = parsed.melodyBars || [];
      state.biabDisplayBars = parsed.displayBars || [];
      state.biabMidiBars = parsed.midiBars || [];
      state.biabMidiPrograms = parsed.midiPrograms || [];
      state.biabTicksPerBeat = parsed.ticksPerBeat;
      state.biabBarTicks = parsed.barTicks;
      state.biabTimeSig = parsed.timeSig || { num: 4, den: 4 };
      state.biabMelodyGenerated = parsed.melodyGenerated;

      state.chartBars = parsed.bars;
      state.playbackOrder = parsed.bars.map((_, i)=>i);
      state.bars = parsed.bars.length;
      state.halfEnabled = parsed.bars.some(b => b.split);
      state.activeBar = 0;
      state.activeHalf = 0;
      state.currentSongTitle = parsed.title || file.name || "";
      state.tempo = clamp(parsed.tempo || 120, 30, 320);

      if (state.chartBars[0]?.chords?.[0]){
        state.keyRoot = state.chartBars[0].chords[0].root;
      }

      assignChordModesWithLimit(state.chartBars);
      syncUIFromState();
      renderAll();
      applyBiabPrograms();
      saveAll();

      setSongStatus(`Loaded BIAB: ${state.currentSongTitle}`);
      setBiabStatus(state.biabMelodyGenerated ? "Loaded BIAB (melody generated)." : "Loaded BIAB with melody.");
      setMelodyStatus(state.biabMelodyGenerated ? "Melody auto-generated from chords." : "Melody loaded from BIAB.");
    } catch (err){
      setBiabStatus("Could not read BIAB file.");
    }
  }

    function applyBiabPrograms(){
    if (!state.biabActive) return;
    if (!AudioKit || !AudioKit.soundFontActive || !AudioKit.soundFontActive()) return;

    if (state.biabMidiPrograms?.length){
      state.biabMidiPrograms.forEach((p)=>{
        if (!p || !Number.isFinite(p.channel) || !Number.isFinite(p.program)) return;
        AudioKit.setMidiProgram(p.channel, p.program, p.bank);
      });
      return;
    }

    if (!state.biabMidiBars?.length) return;
    const flat = [];
    const barTicks = state.biabBarTicks || (BIAB_TICKS_PER_BEAT * 4);
    state.biabMidiBars.forEach((bar, idx)=>{
      (bar || []).forEach((note)=>{
        flat.push({ ...note, tick: (note.start || 0) + idx * barTicks });
      });
    });
    if (!flat.length) return;

    const stats = channelStats(flat);
    const prog = soundFontProgramsForState();
    stats.forEach((stat, ch)=>{
      if (ch === 9){
        AudioKit.setMidiProgram(ch, prog.drums, null);
        return;
      }
      const low = stat.avgPitch < 52 && stat.avgChordSize < 1.4;
      const program = low ? prog.bass : prog.keys;
      AudioKit.setMidiProgram(ch, program, 0);
    });
  }

  function scheduleBiabMelody(barIdx, atHalf, t0, opts = {}){
    if (!state.biabActive || !state.biabMelodyBars?.length) return;
    const barNotes = state.biabMelodyBars[barIdx] || [];
    if (!barNotes.length) return;

    const playAudio = opts.playAudio !== false;
    const highlight = opts.highlight !== false;

    const bar = state.chartBars[barIdx];
    const barTicks = state.biabBarTicks || (BIAB_TICKS_PER_BEAT * 4);
    const isSplit = !!bar?.split;
    const stepStart = (isSplit && atHalf===1) ? barTicks / 2 : 0;
    const stepTicks = isSplit ? (barTicks / 2) : barTicks;
    const stepEnd = stepStart + stepTicks;
    const tickSeconds = (60 / clamp(state.tempo || 120, 30, 320)) / (state.biabTicksPerBeat || BIAB_TICKS_PER_BEAT);

    barNotes.forEach((note)=>{
      if (note.start < stepStart || note.start >= stepEnd) return;
      const offset = (note.start - stepStart) * tickSeconds;
      const durSec = Math.max(0.04, note.dur * tickSeconds);
      const midi = note.midi;
      const vel = clamp((note.vel || 90) / 127, 0.2, 0.9);
      if (playAudio){
        AudioKit.playNote(midi, state.keysPreset, t0 + offset, durSec, vel);
      }
      if (highlight){
        const startDelay = Math.max(0, (t0 + offset - AudioKit.now()) * 1000);
        const endDelay = Math.max(0, (t0 + offset + durSec - AudioKit.now()) * 1000);
        melodyTimers.push(window.setTimeout(()=> setMelodyActive(midi, true), startDelay));
        melodyTimers.push(window.setTimeout(()=> setMelodyActive(midi, false), endDelay));
      }
    });
  }

  function scheduleBiabMidi(barIdx, atHalf, t0){
    if (!state.biabActive || !state.biabMidiBars?.length) return;
    const barNotes = state.biabMidiBars[barIdx] || [];
    if (!barNotes.length) return;

    const bar = state.chartBars[barIdx];
    const barTicks = state.biabBarTicks || (BIAB_TICKS_PER_BEAT * 4);
    const isSplit = !!bar?.split;
    const stepStart = (isSplit && atHalf===1) ? barTicks / 2 : 0;
    const stepTicks = isSplit ? (barTicks / 2) : barTicks;
    const stepEnd = stepStart + stepTicks;
    const tickSeconds = (60 / clamp(state.tempo || 120, 30, 320)) / (state.biabTicksPerBeat || BIAB_TICKS_PER_BEAT);

    barNotes.forEach((note)=>{
      if (note.start < stepStart || note.start >= stepEnd) return;
      const offset = (note.start - stepStart) * tickSeconds;
      const durSec = Math.max(0.04, note.dur * tickSeconds);
      const midi = note.midi;
      const vel = clamp((note.vel || 90) / 127, 0.2, 1);
      const channel = Number.isFinite(note.channel) ? note.channel : 0;
      AudioKit.playMidiNote(midi, channel, t0 + offset, durSec, vel);
    });
  }

  function filteredSongs(){
    let list = songLibrary.slice();
    if (songQuery){
      const q = songQuery.toLowerCase();
      list = list.filter(s =>
        (s.title || "").toLowerCase().includes(q) ||
        (s.composer || "").toLowerCase().includes(q)
      );
    }
    if (songSort === "style"){
      list.sort((a,b)=>{
        const sa = (a.style || "").toLowerCase();
        const sb = (b.style || "").toLowerCase();
        if (sa && sb && sa !== sb) return sa.localeCompare(sb, undefined, {sensitivity:"base"});
        return (a.title||"").localeCompare(b.title||"", undefined, {sensitivity:"base"});
      });
    } else if (songSort === "az"){
      list.sort((a,b)=> (a.title||"").localeCompare(b.title||"", undefined, {sensitivity:"base"}));
    }
    return list;
  }

  function setSongStatus(text){
    if (E.songStatus) E.songStatus.textContent = text;
  }

  function setSoundFontStatus(text){
    if (E.sfStatus) E.sfStatus.textContent = text;
  }

  function renderSongList(){
    if (!E.songList || !E.songStatus) return;
    E.songList.innerHTML = "";
    if (!songLibrary.length){
      setSongStatus("No songs loaded yet.");
      return;
    }
    const list = filteredSongs();
    setSongStatus(`Loaded ${songLibrary.length} song${songLibrary.length===1?"":"s"} ¬∑ Showing ${list.length}`);
    list.forEach((song)=>{
      const row = document.createElement("div");
      row.className = "songRow";

      const meta = document.createElement("div");
      meta.className = "songMeta";
      const title = document.createElement("div");
      title.className = "songTitle";
      title.textContent = song.title || "Untitled";
      const sub = document.createElement("div");
      sub.className = "songSub";
      const parts = [];
      if (song.composer) parts.push(song.composer);
      if (song.style) parts.push(song.style);
      if (song.key) parts.push(song.key);
      sub.textContent = parts.join(" ¬∑ ");
      meta.appendChild(title);
      meta.appendChild(sub);

      const btn = document.createElement("button");
      btn.className = "btn small";
      btn.type = "button";
      btn.textContent = "Load";
      btn.addEventListener("click", ()=> loadSongToChart(song));

      row.appendChild(meta);
      row.appendChild(btn);
      E.songList.appendChild(row);
    });
  }

  async function loadPlaylistFromUrl(url){
    const normalized = normalizePlaylistUrl(url);
    if (!normalized){
      setSongStatus("No playlist configured.");
      return;
    }
    setSongStatus(`Loading ${normalized}...`);
    try{
      const res = await fetch(normalized, { cache: "no-store" });
      if (!res.ok) throw new Error("bad response");
      const text = await res.text();
      let parsed = [];
      try{
        parsed = parseIrealPlaylist(text);
      } catch {
        setSongStatus("Playlist parse error. Try manual upload.");
        if (E.songList) E.songList.innerHTML = "";
        return;
      }
      songLibrary = parsed;
      if (!songLibrary.length){
        setSongStatus("No songs found in playlist.");
        if (E.songList) E.songList.innerHTML = "";
        return;
      }
      renderSongList();
    } catch {
      setSongStatus("Could not load playlist. Check your connection.");
      if (E.songList) E.songList.innerHTML = "";
    }
  }

  async function loadSoundFontFromUrl(url){
    const normalized = normalizeSoundFontUrl(url);
    if (!normalized){
      setSoundFontStatus("SoundFont URL is empty.");
      return false;
    }
    setSoundFontStatus(`Loading ${normalized}...`);
    try{
      await AudioKit.resume();
      await AudioKit.loadSoundFontUrl(normalized);
      state.soundFontUrl = normalized;
      setSoundFontStatus(`Loaded SoundFont: ${normalized.split("/").slice(-1)[0]}`);
      AudioKit.updateSoundFontPrograms();
      applyBiabPrograms();
      saveAll();
      return true;
    } catch (err){
      setSoundFontStatus("SoundFont load failed.");
      return false;
    }
  }

  async function loadSoundFontFromFile(file){
    if (!file) return false;
    setSoundFontStatus(`Loading ${file.name}...`);
    try{
      await AudioKit.resume();
      const buf = await file.arrayBuffer();
      await AudioKit.loadSoundFontBuffer(buf, file.name);
      setSoundFontStatus(`Loaded SoundFont: ${file.name}`);
      AudioKit.updateSoundFontPrograms();
      applyBiabPrograms();
      saveAll();
      return true;
    } catch {
      setSoundFontStatus("SoundFont load failed.");
      return false;
    }
  }

  function loadSongToChart(song){
    if (!song || !Array.isArray(song.bars) || !song.bars.length) return;
    pushHistory();
    state.chartBars = structuredClone(song.bars);
    state.playbackOrder = Array.isArray(song.playbackOrder) && song.playbackOrder.length
      ? song.playbackOrder.slice()
      : state.chartBars.map((_, i)=>i);
    state.currentSongTitle = song.title || "";
    state.bars = state.chartBars.length;
    state.halfEnabled = state.chartBars.some(b=>b.split);
    state.activeBar = 0;
    state.activeHalf = 0;

    const keyInfo = parseSongKey(song.key);
    if (keyInfo){
      state.keyRoot = keyInfo.rootPc;
      state.keyMode = keyInfo.mode;
    }

    assignChordModesWithLimit(state.chartBars);
    renderAll();
    saveAll();
    if (E.msg){
      E.msg.textContent = `Loaded: ${song.title}`;
      setTimeout(()=>{ E.msg.textContent = " "; }, 1500);
    }
  }
  /* ---------- Rendering ---------- */
  function flatChartSlots(){
    const slots = [];
    for (let b=0;b<state.chartBars.length;b++){
      const bar = state.chartBars[b];
      const chords = bar?.chords || [];
      for (let h=0;h<chords.length;h++){
        slots.push({ barIndex:b, halfIndex:h, chord: chords[h] });
      }
    }
    return slots;
  }

  function activeChord(){
    const bar = state.chartBars[state.activeBar];
    if (!bar) return null;
    const idx = clamp(state.activeHalf, 0, (bar.chords?.length||1)-1);
    return bar.chords[idx] || null;
  }

  function fitChordText(el, minPx = 8){
    if (!el) return;
    el.style.fontSize = "";
    const baseSize = parseFloat(getComputedStyle(el).fontSize) || 16;
    const maxWidth = el.clientWidth;
    if (!maxWidth) return;
    const width = el.scrollWidth;
    if (width <= maxWidth) return;
    let size = Math.max(minPx, Math.floor(baseSize * (maxWidth / width) * 10) / 10);
    el.style.fontSize = `${size}px`;
    for (let i=0;i<6 && el.scrollWidth > maxWidth && size > minPx;i++){
      size = Math.max(minPx, size - 0.5);
      el.style.fontSize = `${size}px`;
    }
  }

  function renderLeadSheet(){
    E.sheet.innerHTML = "";
    for (let b=0;b<state.chartBars.length;b++){
      const bar = state.chartBars[b];
      const el = document.createElement("div");
      el.className = "bar";
      el.dataset.bar = String(b);

      const num = document.createElement("div");
      num.className = "num";
      if (bar?.repeatEnd){
        const re = document.createElement("span");
        re.className = "repeatGlyph end";
        re.textContent = "ùÑá";
        num.appendChild(re);
      }
      const numText = document.createElement("span");
      numText.textContent = String(b+1);
      num.appendChild(numText);
      if (bar?.repeatStart){
        const rs = document.createElement("span");
        rs.className = "repeatGlyph start";
        rs.textContent = "ùÑÜ";
        num.appendChild(rs);
      }

      const c1 = bar?.chords?.[0] || null;
      const c2 = bar?.chords?.[1] || null;

      const sym = document.createElement("div");
      sym.className = "sym";
      sym.textContent = c1 ? chordName(c1) : "‚Äî";

      el.appendChild(num);
      el.appendChild(sym);

      let sym2 = null;
      if (bar?.split && c2){
        sym2 = document.createElement("div");
        sym2.className = "sym sym2";
        sym2.textContent = chordName(c2);
        el.appendChild(sym2);

        const hh = document.createElement("div");
        hh.className = "halfHit";
        const top = document.createElement("button");
        const bot = document.createElement("button");
        top.type="button"; bot.type="button";

        top.addEventListener("click",(ev)=>{ ev.stopPropagation(); onBarTap(b,0,true); });
        bot.addEventListener("click",(ev)=>{ ev.stopPropagation(); onBarTap(b,1,true); });

        hh.appendChild(top); hh.appendChild(bot);
        el.appendChild(hh);
      }

      el.addEventListener("click", ()=> onBarTap(b,0,true));
      E.sheet.appendChild(el);
      fitChordText(sym);
      if (sym2) fitChordText(sym2);
    }
    highlightActiveBar();
    applyEditVisuals();
  }

  function midiToVexKey(midi, preferFlats = false){
    const sharpNames = ["c","c#","d","d#","e","f","f#","g","g#","a","a#","b"];
    const flatNames = ["c","db","d","eb","e","f","gb","g","ab","a","bb","b"];
    const p = pc(midi);
    const oct = Math.floor(midi / 12) - 1;
    const name = (preferFlats ? flatNames[p] : sharpNames[p]) || "c";
    const accidental = name.includes("b") ? "b" : (name.includes("#") ? "#" : null);
    return { key: `${name}/${oct}`, accidental };
  }

  function quantizeDuration(ticks, ticksPerBeat){
    const choices = [
      {ticks: ticksPerBeat * 4, dur: "w"},
      {ticks: ticksPerBeat * 2, dur: "h"},
      {ticks: ticksPerBeat, dur: "q"},
      {ticks: ticksPerBeat / 2, dur: "8"},
      {ticks: ticksPerBeat / 4, dur: "16"},
      {ticks: ticksPerBeat / 8, dur: "32"}
    ];
    let best = choices[0];
    let bestDiff = Math.abs(ticks - best.ticks);
    for (let i=1;i<choices.length;i++){
      const diff = Math.abs(ticks - choices[i].ticks);
      if (diff < bestDiff){
        bestDiff = diff;
        best = choices[i];
      }
    }
    return best.dur;
  }


  function durationChoices(ticksPerBeat, opts = {}){
    const base = [
      {ticks: ticksPerBeat * 4, dur: "w"},
      {ticks: ticksPerBeat * 2, dur: "h"},
      {ticks: ticksPerBeat, dur: "q"},
      {ticks: ticksPerBeat / 2, dur: "8"},
      {ticks: ticksPerBeat / 4, dur: "16"},
      {ticks: ticksPerBeat / 8, dur: "32"}
    ];
    const out = [];
    base.forEach((v)=>{
      out.push({ ticks: v.ticks, dur: v.dur, dots: 0, triplet: false });
      out.push({ ticks: v.ticks * 1.5, dur: v.dur, dots: 1, triplet: false });
    });
    if (opts.triplet){
      const trip = [
        { ticks: ticksPerBeat * 2 / 3, dur: "q" },
        { ticks: ticksPerBeat / 3, dur: "8" },
        { ticks: ticksPerBeat / 6, dur: "16" }
      ];
      trip.forEach((v)=>{
        out.push({ ticks: v.ticks, dur: v.dur, dots: 0, triplet: true });
      });
    }
    return out.sort((a,b)=> b.ticks - a.ticks);
  }

  function pickSingleDuration(ticks, ticksPerBeat, opts = {}){
    const choices = durationChoices(ticksPerBeat, opts);
    let best = null;
    let bestDiff = Number.POSITIVE_INFINITY;
    choices.forEach((c)=>{
      const diff = Math.abs(ticks - c.ticks);
      if (diff < bestDiff){
        bestDiff = diff;
        best = c;
      }
    });
    const tolBase = opts.triplet ? ticksPerBeat / 6 : ticksPerBeat / 4;
    const tol = (opts.grid && Number.isFinite(opts.grid))
      ? Math.max(tolBase, opts.grid * 0.45)
      : tolBase;
    if (best && bestDiff <= tol) return best;
    return null;
  }

  function splitTicksToDurations(ticks, ticksPerBeat, opts = {}){
    const choices = durationChoices(ticksPerBeat, opts);
    const out = [];
    let remain = ticks;
    const minTicks = opts.triplet ? ticksPerBeat / 6 : ticksPerBeat / 8;
    let safety = 0;
    while (remain >= minTicks * 0.9 && safety < 64){
      safety++;
      let picked = null;
      for (const c of choices){
        if (remain >= c.ticks - 0.001){
          picked = c;
          break;
        }
      }
      if (!picked){
        out.push({ dur: "32", dots: 0, ticks: ticksPerBeat / 8, triplet: false });
        break;
      }
      out.push({ dur: picked.dur, dots: picked.dots, ticks: picked.ticks, triplet: picked.triplet });
      remain -= picked.ticks;
    }
    if (!out.length) out.push({ dur: "32", dots: 0, ticks: ticksPerBeat / 8, triplet: false });
    return out;
  }

  function applyDots(note, dots){
    if (!note || !dots) return;
    if (typeof note.addDotToAll === "function"){
      for (let i=0;i<dots;i++) note.addDotToAll();
      return;
    }
    const VF = window.Vex && window.Vex.Flow;
    if (VF && VF.Dot && typeof VF.Dot.buildAndAttach === "function"){
      for (let i=0;i<dots;i++) VF.Dot.buildAndAttach([note], { all: true });
    }
  }

  function pickQuantizationGrid(barNotes, ticksPerBeat){
    const notes = barNotes || [];
    const candidates = [
      ticksPerBeat / 2,
      ticksPerBeat / 3,
      ticksPerBeat / 4,
      ticksPerBeat / 6,
      ticksPerBeat / 8,
      ticksPerBeat / 12,
      ticksPerBeat / 16
    ].filter(v => Number.isFinite(v) && v > 0);
    if (!notes.length || !candidates.length) return ticksPerBeat / 2;

    const calcError = (grid)=>{
      let total = 0;
      let count = 0;
      notes.forEach(n=>{
        if (Number.isFinite(n.start)){
          total += Math.abs(n.start - Math.round(n.start / grid) * grid);
          count += 1;
        }
        if (Number.isFinite(n.dur)){
          total += Math.abs(n.dur - Math.round(n.dur / grid) * grid);
          count += 1;
        }
      });
      if (!count) return Number.POSITIVE_INFINITY;
      return total / (count * grid);
    };

    const scored = candidates.map(grid => ({ grid, error: calcError(grid) }));
    scored.sort((a,b)=> a.error - b.error || a.grid - b.grid);
    const bestError = scored[0]?.error ?? 0;
    const close = scored.filter(s => s.error <= Math.max(0.12, bestError + 0.04));
    if (close.length){
      return close.reduce((min, s)=> s.grid < min ? s.grid : min, close[0].grid);
    }
    return scored[0]?.grid ?? ticksPerBeat / 2;
  }

  function shouldPreferFlats(){
    if (!Number.isFinite(state.keyRoot)) return false;
    const keyName = noteName(state.keyRoot);
    return keyName.includes("b");
  }

  function buildBarTickables(barNotes, ticksPerBeat, beatsPerBar, beatValue=4){
    const barTicks = ticksPerBeat * 4 * (beatsPerBar / beatValue);
    const notes = (barNotes || []).slice().sort((a,b)=>a.start-b.start);
    const VF = window.Vex && window.Vex.Flow;
    const grid = pickQuantizationGrid(notes, ticksPerBeat);
    const tripletGrid = ticksPerBeat / 3;
    const useTripletGrid = Math.abs(grid - tripletGrid) < 0.01
      || Math.abs(grid - ticksPerBeat / 6) < 0.01
      || Math.abs(grid - ticksPerBeat / 12) < 0.01;
    const preferFlats = shouldPreferFlats();

    const tickables = [];
    const ties = [];
    const tuplets = [];
    const tieIns = new Map();
    const tieOuts = new Map();
    let cursor = 0;

    const pushRest = (ticks)=>{
      if (ticks <= 0) return;
      const durations = splitTicksToDurations(ticks, ticksPerBeat, { triplet: useTripletGrid });
      durations.forEach(part=>{
        const n = new Vex.Flow.StaveNote({ keys:["b/4"], duration: part.dur + "r" });
        applyDots(n, part.dots);
        tickables.push(n);
      });
    };

    const addNote = (noteTicks, midi, startTicks, noteMeta)=>{
    const addNote = (noteTicks, midi, startTicks)=>{
      const { key, accidental } = midiToVexKey(midi, preferFlats);
      const direction = (VF && VF.Stem && Number.isFinite(midi))
        ? (midi >= 71 ? VF.Stem.DOWN : VF.Stem.UP)
        : null;
      const makeNote = (part, partStart)=>{
        const n = new Vex.Flow.StaveNote({ keys:[key], duration: part.dur });
        if (accidental) n.addAccidental(0, new Vex.Flow.Accidental(accidental));
        if (direction != null && typeof n.setStemDirection === "function") n.setStemDirection(direction);
        applyDots(n, part.dots);
        if (part.triplet && useTripletGrid && (part.dur === "8" || part.dur === "16") && Number.isFinite(partStart)){
          const beatIndex = Math.floor(partStart / ticksPerBeat);
          const within = partStart - beatIndex * ticksPerBeat;
          const slot = Math.round(within / grid);
          const group = Math.floor(slot / 3);
          const slotInGroup = slot - group * 3;
          if (slotInGroup >= 0 && slotInGroup <= 2){
            n._tripletSlot = { beatIndex, group, slot: slotInGroup };
          }
        }
        return n;
      };

      const single = pickSingleDuration(noteTicks, ticksPerBeat, { triplet: useTripletGrid, grid });
      if (single){
        const n = makeNote(single, startTicks);
        tickables.push(n);
        if (noteMeta?.tieIn) tieIns.set(noteMeta.id, n);
        if (noteMeta?.tieOut) tieOuts.set(noteMeta.id, n);
        return;
      }

      const durations = splitTicksToDurations(noteTicks, ticksPerBeat, { triplet: useTripletGrid });
      let offset = 0;
      const parts = durations.map(part=>{
        const n = makeNote(part, startTicks + offset);
        offset += part.ticks || 0;
        return n;
      });
      parts.forEach(p=>tickables.push(p));
      if (noteMeta?.tieIn) tieIns.set(noteMeta.id, parts[0]);
      if (noteMeta?.tieOut) tieOuts.set(noteMeta.id, parts[parts.length - 1]);
      if (parts.length > 1){
        for (let i=0;i<parts.length-1;i++){
          const tie = new Vex.Flow.StaveTie({ first_note: parts[i], last_note: parts[i+1] });
          if (direction != null){
            if (typeof tie.setDirection === "function") tie.setDirection(direction);
            else tie.direction = direction;
          }
          ties.push(tie);
        }
      }
    };

    notes.forEach((note)=>{
      if (!Number.isFinite(note.start) || !Number.isFinite(note.dur)) return;
      let start = Math.round(note.start / grid) * grid;
      let dur = Math.max(grid, Math.round(note.dur / grid) * grid);
      if (start < 0) start = 0;
      if (start >= barTicks) return;
      const gap = start - cursor;
      const snapTol = grid * 0.4;
      if (Math.abs(gap) > 0 && Math.abs(gap) < snapTol){
        start = cursor;
      }
      if (start < cursor - grid * 0.5) return;
      if (start > cursor){
        pushRest(start - cursor);
      }
      dur = Math.min(dur, barTicks - start);
      addNote(dur, note.midi, start, note);
      cursor = start + dur;
    });

    if (cursor < barTicks){
      pushRest(barTicks - cursor);
    }

    if (useTripletGrid && VF && typeof VF.Tuplet === "function"){
      let group = null;
      let prevSlot = null;
      tickables.forEach((n)=>{
        if (!n || typeof n.isRest !== "function") return;
        const info = n._tripletSlot;
        if (!info){
          group = null;
          prevSlot = null;
          return;
        }
        const groupKey = `${info.beatIndex}-${info.group || 0}`;
        if (!group || group.key !== groupKey || info.slot !== prevSlot + 1){
          group = { key: groupKey, notes: [] };
        }
        group.notes.push(n);
        prevSlot = info.slot;
        if (group.notes.length === 3){
          tuplets.push(new VF.Tuplet(group.notes, { num_notes: 3, notes_occupied: 2 }));
          group = null;
          prevSlot = null;
        }
      });
    }
    return { tickables, ties, tuplets, tieIns, tieOuts };
  }

  function renderMelodySheet(){
    if (!E.melodyWrap || !E.melodySheet) return;
    const show = !!state.biabActive;
    E.melodyWrap.classList.toggle("on", show);
    E.melodySheet.classList.toggle("biabSheet", show);
    if (!show){
      E.melodySheet.innerHTML = "";
      return;
    }
    const VF = window.Vex && window.Vex.Flow;
    if (!VF){
      setMelodyStatus("VexFlow not available.");
      E.melodySheet.innerHTML = "";
      return;
    }
    const bars = state.biabMelodyBars || [];
    if (!bars.length){
      setMelodyStatus("No melody to display.");
      E.melodySheet.innerHTML = '<div class="melodyEmpty">No melody to display.</div>';
      return;
    }

    const chordBars = state.chartBars || [];
    const ticksPerBeat = state.biabTicksPerBeat || BIAB_TICKS_PER_BEAT;
    const beatsPerBar = (state.biabTimeSig && state.biabTimeSig.num) ? state.biabTimeSig.num : 4;
    const beatValue = (state.biabTimeSig && state.biabTimeSig.den) ? state.biabTimeSig.den : 4;
    const sheetWidth = Math.max(320, Math.floor(E.melodySheet.clientWidth || 900));
    const isCompact = sheetWidth < 520;
    const minBarWidth = isCompact ? 140 : 180;
    const maxBarsPerRow = isCompact ? 7 : 6;
    let barsPerRow = Math.floor(sheetWidth / minBarWidth);
    if (!Number.isFinite(barsPerRow) || barsPerRow < 2) barsPerRow = 4;
    barsPerRow = clamp(barsPerRow, 2, maxBarsPerRow);
    const barWidth = Math.max(minBarWidth, Math.floor(sheetWidth / barsPerRow));
    const staveHeight = isCompact ? 100 : 120;

    E.melodySheet.innerHTML = "";
    const totalBars = bars.length;
    const rowCount = Math.ceil(totalBars / barsPerRow);
    let pendingTieOuts = null;
    for (let r=0;r<rowCount;r++){
      const rowWrap = document.createElement("div");
      rowWrap.className = "biabRow";
      const rowBars = Math.min(barsPerRow, totalBars - r * barsPerRow);
      const rowWidth = barWidth * rowBars;
      rowWrap.style.width = `${rowWidth}px`;

      const chordRow = document.createElement("div");
      chordRow.className = "biabChords";
      chordRow.style.gridTemplateColumns = `repeat(${rowBars}, minmax(0, 1fr))`;
      chordRow.style.width = `${rowWidth}px`;
      for (let i=0;i<rowBars;i++){
        const barIndex = r * barsPerRow + i;
        const bar = chordBars[barIndex] || {};
        const chords = Array.isArray(bar.chords) ? bar.chords : [];
        const first = chords[0] || null;
        const second = (bar.split && chords[1]) ? chords[1] : null;
        const showSplit = !!(second && !biabChordEqual(first, second));
        const slotCount = showSplit ? 2 : 1;

        const cell = document.createElement("div");
        cell.className = "biabChordCell";
        cell.style.gridTemplateColumns = `repeat(${slotCount}, minmax(0, 1fr))`;

        const slots = showSplit ? [first, second] : [first];
        slots.forEach((ch)=>{
          const span = document.createElement("span");
          span.className = "biabChordSlot";
          if (ch){
            span.textContent = chordName(ch);
          } else {
            span.textContent = "";
            span.classList.add("empty");
          }
          cell.appendChild(span);
        });
        chordRow.appendChild(cell);
      }
      rowWrap.appendChild(chordRow);

      const svgWrap = document.createElement("div");
      svgWrap.className = "biabSvg";
      svgWrap.style.width = `${rowWidth}px`;
      const renderer = new VF.Renderer(svgWrap, VF.Renderer.Backends.SVG);
      renderer.resize(rowWidth, staveHeight);
      const ctx = renderer.getContext();

      const rowTieIns = [];
      const rowTieOuts = [];
      for (let i=0;i<rowBars;i++){
        const barIndex = r * barsPerRow + i;
        const x = i * barWidth;
        const stave = new VF.Stave(x, 10, barWidth);
        stave.setNumLines(5);
        if (barIndex == 0){
          stave.addClef("treble").addTimeSignature(`${beatsPerBar}/${beatValue}`);
        }
        stave.setContext(ctx).draw();

        const barNotes = bars[barIndex] || [];
        const built = buildBarTickables(barNotes, ticksPerBeat, beatsPerBar, beatValue);
        const tickables = built.tickables.length
          ? built.tickables
          : [new VF.StaveNote({ keys:["b/4"], duration:"wr" })];
        rowTieIns[i] = built.tieIns;
        rowTieOuts[i] = built.tieOuts;

        const voice = new VF.Voice({ num_beats: beatsPerBar, beat_value: beatValue });
        voice.setMode(VF.Voice.Mode.SOFT);
        voice.addTickables(tickables);
        const beamables = tickables.filter(n => n && typeof n.isRest === "function" && !n.isRest());
        const groups = (VF.Beam && typeof VF.Beam.getDefaultBeamGroups === "function")
          ? VF.Beam.getDefaultBeamGroups(`${beatsPerBar}/${beatValue}`)
          : ((VF.Fraction) ? [new VF.Fraction(1, beatValue)] : undefined);
        const groups = (VF.Fraction) ? [new VF.Fraction(1, beatValue)] : undefined;
        const beams = VF.Beam.generateBeams(beamables, {
          groups,
          beam_rests: false,
          maintain_stem_directions: true
        });
        new VF.Formatter().joinVoices([voice]).format([voice], barWidth - 12);
        voice.draw(ctx, stave);
        built.ties.forEach(t => t.setContext(ctx).draw());
        if (built.tuplets && built.tuplets.length){
          built.tuplets.forEach(t => t.setContext(ctx).draw());
        }
        beams.forEach(b => b.setContext(ctx).draw());
      }
      for (let i=0;i<rowBars-1;i++){
        const outs = rowTieOuts[i];
        const ins = rowTieIns[i+1];
        if (!outs || !ins) continue;
        outs.forEach((noteObj, id)=>{
          const target = ins.get(id);
          if (!target) return;
          const tie = new VF.StaveTie({ first_note: noteObj, last_note: target });
          tie.setContext(ctx).draw();
        });
      }
      rowWrap.appendChild(svgWrap);
      E.melodySheet.appendChild(rowWrap);
    }
  }


  function applyEditVisuals(){
    const nodes = E.sheet.querySelectorAll(".bar");
    nodes.forEach(n=>{
      n.classList.toggle("editing", !!state.editMode);
    });
    E.editHint.style.display = state.editMode ? "block" : "none";
    E.btnEdit.classList.toggle("primary", !!state.editMode);
  }

  function highlightActiveBar(){
    const bars = E.sheet.querySelectorAll(".bar");
    bars.forEach(node=>{
      const b = Number(node.dataset.bar||0);
      node.classList.toggle("active", b===state.activeBar);
    });
  }

  function renderHeaderPills(){
    const totalBars = state.chartBars.length || 0;
    const slots = flatChartSlots();
    E.pillLine.textContent = `${totalBars} bars ¬∑ ${Math.max(1, slots.length)} chords`;
    const ch = activeChord();
    E.focusLine.textContent = ch ? chordName(ch) : "‚Äî";
  }

  function renderKeyLine(){
    if (!state.showKey){
      E.leadKey.textContent = "‚Äî";
      return;
    }
    const title = state.currentSongTitle ? ` ¬∑ ${state.currentSongTitle}` : "";
    E.leadKey.textContent = `Center: ${noteName(state.keyRoot)} ${state.keyMode}${title}`;
  }

  function renderSongRandomLabel(){
    if (!E.songRandomLabel) return;
    const title = (state.currentSongTitle || "").trim();
    if (title){
      E.songRandomLabel.textContent = `Loaded: ${title}`;
      E.songRandomLabel.classList.add("loaded");
    } else {
      E.songRandomLabel.textContent = "No song loaded";
      E.songRandomLabel.classList.remove("loaded");
    }
  }

  function placeMarker(svg, cx, cy, kind){
    const style = state.markerStyle || "dots";
    const fillVar = (kind==="root") ? "var(--good)" : "var(--chord)";
    const rootStroke = "rgba(255,255,255,.82)";
    const chordStroke = "rgba(0,0,0,.55)";

    if (style==="dots"){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", String(cx));
      c.setAttribute("cy", String(cy));
      c.setAttribute("r", "10");
      c.setAttribute("fill", fillVar);
      c.setAttribute("stroke", kind==="root" ? rootStroke : chordStroke);
      c.setAttribute("stroke-width", kind==="root" ? "2.2" : "1.4");
      svg.appendChild(c);
      return;
    }
    if (style==="rings"){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", String(cx));
      c.setAttribute("cy", String(cy));
      c.setAttribute("r", "12");
      c.setAttribute("fill", kind==="root" ? fillVar : "transparent");
      c.setAttribute("stroke", kind==="root" ? rootStroke : fillVar);
      c.setAttribute("stroke-width", kind==="root" ? "3.2" : "2.4");
      svg.appendChild(c);
      return;
    }
    if (style==="squares"){
      const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
      r.setAttribute("x", String(cx-10));
      r.setAttribute("y", String(cy-10));
      r.setAttribute("width", "20");
      r.setAttribute("height", "20");
      r.setAttribute("rx", "5");
      r.setAttribute("fill", fillVar);
      r.setAttribute("stroke", kind==="root" ? rootStroke : chordStroke);
      r.setAttribute("stroke-width", kind==="root" ? "2.2" : "1.4");
      svg.appendChild(r);
      return;
    }
    const tri = document.createElementNS("http://www.w3.org/2000/svg","path");
    tri.setAttribute("d", `M ${cx} ${cy-12} L ${cx-12} ${cy+10} L ${cx+12} ${cy+10} Z`);
    tri.setAttribute("fill", fillVar);
    tri.setAttribute("stroke", kind==="root" ? rootStroke : chordStroke);
    tri.setAttribute("stroke-width", kind==="root" ? "2.2" : "1.4");
    svg.appendChild(tri);
  }

  function placeScaleMarker(svg, cx, cy){
    const style = state.markerStyle || "dots";
    const fillVar = "var(--accent)";
    const stroke = "rgba(0,0,0,.55)";

    if (style==="dots"){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", String(cx));
      c.setAttribute("cy", String(cy));
      c.setAttribute("r", "7");
      c.setAttribute("fill", fillVar);
      c.setAttribute("stroke", stroke);
      c.setAttribute("stroke-width", "1.2");
      svg.appendChild(c);
      return;
    }
    if (style==="rings"){
      const c = document.createElementNS("http://www.w3.org/2000/svg","circle");
      c.setAttribute("cx", String(cx));
      c.setAttribute("cy", String(cy));
      c.setAttribute("r", "8");
      c.setAttribute("fill", fillVar);
      c.setAttribute("stroke", "rgba(255,255,255,.7)");
      c.setAttribute("stroke-width", "2");
      svg.appendChild(c);
      return;
    }
    if (style==="squares"){
      const r = document.createElementNS("http://www.w3.org/2000/svg","rect");
      r.setAttribute("x", String(cx-7));
      r.setAttribute("y", String(cy-7));
      r.setAttribute("width", "14");
      r.setAttribute("height", "14");
      r.setAttribute("rx", "4");
      r.setAttribute("fill", fillVar);
      r.setAttribute("stroke", stroke);
      r.setAttribute("stroke-width", "1.2");
      svg.appendChild(r);
      return;
    }
    const tri = document.createElementNS("http://www.w3.org/2000/svg","path");
    tri.setAttribute("d", `M ${cx} ${cy-8} L ${cx-8} ${cy+7} L ${cx+8} ${cy+7} Z`);
    tri.setAttribute("fill", fillVar);
    tri.setAttribute("stroke", stroke);
    tri.setAttribute("stroke-width", "1.2");
    svg.appendChild(tri);
  }

  function placeMelodyMarker(svg, cx, cy, isBlack){
    const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
    dot.setAttribute("cx", String(cx));
    dot.setAttribute("cy", String(cy));
    dot.setAttribute("r", isBlack ? "7" : "8.5");
    dot.setAttribute("fill", "var(--melody)");
    dot.setAttribute("stroke", "rgba(0,0,0,.6)");
    dot.setAttribute("stroke-width", "1.4");
    svg.appendChild(dot);
  }


  function renderFretboardForActive(){
    const ch = activeChord();
    if (!ch){
      E.fretSvg.innerHTML = "";
      E.pianoTop.textContent = "‚Äî";
      E.pianoHint.textContent = "‚Äî";
      return;
    }

    const prev = (state.activeBar>0) ? (state.chartBars[state.activeBar-1]?.chords?.slice(-1)[0] || null) : null;
    const next = (state.activeBar<state.chartBars.length-1) ? (state.chartBars[state.activeBar+1]?.chords?.[0] || null) : null;

    const {pcs: scalePCs, mode} = scalePCsForChordLocal(ch, prev, next);
    const scaleSet = new Set(scalePCs);
    const chordSet = new Set(chordTonesPCs(ch));
    const melodyPcs = getActiveMelodyPcs();
    const scaleRoot = (ch && typeof ch.scaleRoot==="number") ? ch.scaleRoot : ch.root;

    E.pianoTop.textContent = chordName(ch);
    E.pianoHint.textContent = `Fretboard: EADGBE ¬∑ ${noteName(scaleRoot)} ${mode}`;

    const svg = E.fretSvg;
    svg.innerHTML = "";

    const W = 1000;
    const H = 240;
    const frets = 12;
    const space = W / frets;
    const marginY = 22;
    const stringGap = (H - marginY*2) / 5;
    const nutWidth = Math.max(8, space * 0.22);
    const openX = nutWidth * 0.5;

    const bg = document.createElementNS("http://www.w3.org/2000/svg","rect");
    bg.setAttribute("x", "0");
    bg.setAttribute("y", "0");
    bg.setAttribute("width", String(W));
    bg.setAttribute("height", String(H));
    bg.setAttribute("fill", "var(--fretWood)");
    svg.appendChild(bg);

    for (let i=0;i<=frets;i++){
      const x = i * space;
      const line = document.createElementNS("http://www.w3.org/2000/svg","line");
      line.setAttribute("x1", String(x));
      line.setAttribute("x2", String(x));
      line.setAttribute("y1", "0");
      line.setAttribute("y2", String(H));
      line.setAttribute("stroke", i===0 ? "var(--fretLineStrong)" : "var(--fretLine)");
      line.setAttribute("stroke-width", i===0 ? "4" : "2");
      svg.appendChild(line);
    }

    const nut = document.createElementNS("http://www.w3.org/2000/svg","rect");
    nut.setAttribute("x", "0");
    nut.setAttribute("y", "0");
    nut.setAttribute("width", String(nutWidth));
    nut.setAttribute("height", String(H));
    nut.setAttribute("fill", "var(--fretLineStrong)");
    nut.setAttribute("stroke", "rgba(0,0,0,.55)");
    nut.setAttribute("stroke-width", "2");
    nut.setAttribute("opacity", "0.85");
    svg.appendChild(nut);

    const inlays = [3,5,7,9,12];
    for (const f of inlays){
      const x = (f - 0.5) * space;
      if (f === 12){
        const y1 = H*0.35;
        const y2 = H*0.65;
        for (const y of [y1, y2]){
          const d = document.createElementNS("http://www.w3.org/2000/svg","circle");
          d.setAttribute("cx", String(x));
          d.setAttribute("cy", String(y));
          d.setAttribute("r", "6");
          d.setAttribute("fill", "var(--fretInlay)");
          d.setAttribute("opacity", "0.7");
          svg.appendChild(d);
        }
      } else {
        const d = document.createElementNS("http://www.w3.org/2000/svg","circle");
        d.setAttribute("cx", String(x));
        d.setAttribute("cy", String(H/2));
        d.setAttribute("r", "6");
        d.setAttribute("fill", "var(--fretInlay)");
        d.setAttribute("opacity", "0.7");
        svg.appendChild(d);
      }
    }

    if (state.fretNumbers){
      for (let f=1; f<=frets; f++){
        const x = (f - 0.5) * space;
        const tTop = document.createElementNS("http://www.w3.org/2000/svg","text");
        tTop.setAttribute("x", String(x));
        tTop.setAttribute("y", "14");
        tTop.setAttribute("fill", "var(--fretInlay)");
        tTop.setAttribute("font-size", "12");
        tTop.setAttribute("font-weight", "700");
        tTop.setAttribute("text-anchor", "middle");
        tTop.setAttribute("dominant-baseline", "middle");
        tTop.setAttribute("opacity", "0.8");
        tTop.textContent = String(f);
        svg.appendChild(tTop);

        const tBot = document.createElementNS("http://www.w3.org/2000/svg","text");
        tBot.setAttribute("x", String(x));
        tBot.setAttribute("y", String(H - 10));
        tBot.setAttribute("fill", "var(--fretInlay)");
        tBot.setAttribute("font-size", "12");
        tBot.setAttribute("font-weight", "700");
        tBot.setAttribute("text-anchor", "middle");
        tBot.setAttribute("dominant-baseline", "middle");
        tBot.setAttribute("opacity", "0.8");
        tBot.textContent = String(f);
        svg.appendChild(tBot);
      }
    }

    for (let s=0;s<6;s++){
      const y = marginY + s*stringGap;
      const stringLine = document.createElementNS("http://www.w3.org/2000/svg","line");
      stringLine.setAttribute("x1", "0");
      stringLine.setAttribute("x2", String(W));
      stringLine.setAttribute("y1", String(y));
      stringLine.setAttribute("y2", String(y));
      stringLine.setAttribute("stroke", "var(--stringColor)");
      const gauge = state.fretLefty ? (1.2 + (5 - s)*0.2) : (1.2 + s*0.2);
      stringLine.setAttribute("stroke-width", String(gauge));
      stringLine.setAttribute("opacity", "0.85");
      svg.appendChild(stringLine);

      const openMark = document.createElementNS("http://www.w3.org/2000/svg","circle");
      openMark.setAttribute("cx", String(openX));
      openMark.setAttribute("cy", String(y));
      openMark.setAttribute("r", "4.5");
      openMark.setAttribute("fill", "none");
      openMark.setAttribute("stroke", "var(--fretInlay)");
      openMark.setAttribute("stroke-width", "1.2");
      openMark.setAttribute("opacity", "0.6");
      svg.appendChild(openMark);
    }

    const baseOpenPcs = [4,11,7,2,9,4];
    const openPcs = state.fretLefty ? [...baseOpenPcs].reverse() : baseOpenPcs;
    for (let s=0;s<6;s++){
      const y = marginY + s*stringGap;
      for (let f=0; f<=frets; f++){
        const note = (openPcs[s] + f) % 12;
        if (!scaleSet.has(note)) continue;
        const x = (f===0) ? openX : ((f - 0.5) * space);
        placeScaleMarker(svg, x, y);
      }
    }

    for (let s=0;s<6;s++){
      const y = marginY + s*stringGap;
      for (let f=0; f<=frets; f++){
        const note = (openPcs[s] + f) % 12;
        if (!chordSet.has(note)) continue;
        const x = (f===0) ? openX : ((f - 0.5) * space);
        const isRoot = note === ((ch.root%12)+12)%12;
        const dot = document.createElementNS("http://www.w3.org/2000/svg","circle");
        dot.setAttribute("cx", String(x));
        dot.setAttribute("cy", String(y));
        dot.setAttribute("r", isRoot ? "12" : "10");
        dot.setAttribute("fill", isRoot ? "var(--good)" : "var(--chord)");
        dot.setAttribute("stroke", isRoot ? "rgba(255,255,255,.85)" : "rgba(0,0,0,.55)");
        dot.setAttribute("stroke-width", isRoot ? "2.4" : "1.6");
        svg.appendChild(dot);
      }
    }

    if (melodyPcs.size){
      for (let s=0;s<6;s++){
        const y = marginY + s*stringGap;
        for (let f=0; f<=frets; f++){
          const note = (openPcs[s] + f) % 12;
          if (!melodyPcs.has(note)) continue;
          const x = (f===0) ? openX : ((f - 0.5) * space);
          placeMelodyMarker(svg, x, y, false);
        }
      }
    }
  }

  function renderPianoForActive(){
    const showFret = state.viewMode === "fretboard";
    if (E.fretBox) E.fretBox.style.display = showFret ? "block" : "none";
    if (E.pianoBox) E.pianoBox.style.display = showFret ? "none" : "block";
    if (E.btnFretToggle){
      E.btnFretToggle.classList.toggle("on", showFret);
      E.btnFretToggle.setAttribute("aria-pressed", showFret ? "true" : "false");
    }
    if (E.btnPianoToggle){
      E.btnPianoToggle.classList.toggle("on", !showFret);
      E.btnPianoToggle.setAttribute("aria-pressed", showFret ? "false" : "true");
    }
    if (showFret){
      renderFretboardForActive();
      return;
    }

    const ch = activeChord();
    const melodyPcs = getActiveMelodyPcs();
    let scalePCs = [];
    let chordPCs = [];
    let scaleRoot = null;
    let mode = state.keyMode || "ionian";
    let chordRoot = null;
    let needWide = false;

    if (ch){
      const prev = (state.activeBar>0) ? (state.chartBars[state.activeBar-1]?.chords?.slice(-1)[0] || null) : null;
      const next = (state.activeBar<state.chartBars.length-1) ? (state.chartBars[state.activeBar+1]?.chords?.[0] || null) : null;
      const scaleInfo = scalePCsForChordLocal(ch, prev, next);
      scalePCs = scaleInfo.pcs || [];
      mode = scaleInfo.mode || mode;
      chordPCs = chordTonesPCs(ch);
      scaleRoot = (typeof ch.scaleRoot==="number") ? ch.scaleRoot : ch.root;
      chordRoot = ch.root;
      needWide = (ch.intervals?.length||0) >= 5;
      E.pianoTop.textContent = chordName(ch);
      E.pianoHint.textContent = `Scale: ${noteName(scaleRoot)} ${mode} ¬∑ Keyboard: ${state.kbOct} oct.`;
    } else {
      const keyMode = SCALES[state.keyMode] ? state.keyMode : "ionian";
      mode = keyMode;
      scaleRoot = Number.isFinite(state.keyRoot) ? state.keyRoot : 0;
      scalePCs = (SCALES[keyMode] || []).map(i=>pc(scaleRoot + i));
      chordPCs = [];
      chordRoot = null;
      needWide = false;
      E.pianoTop.textContent = `Key: ${noteName(scaleRoot)} ${mode}`;
      E.pianoHint.textContent = `Keyboard: ${state.kbOct} oct.`;
    }

    const svg = E.pianoSvg;
    svg.innerHTML = "";

    const W = 1000, H = 240;
    const baseOct = clamp(Number(state.kbOct)||2, 1, 4);
    const oct = clamp(needWide ? Math.max(baseOct, 3) : baseOct, 1, 4);
    const whiteKeyCount = 7 * oct;
    const whiteW = W / whiteKeyCount;
    const whiteH = 230;

    const whiteOrder = [0,2,4,5,7,9,11];

    const keyPos = [];
    let x = 0;
    for (let o=0;o<oct;o++){
      for (let i=0;i<7;i++){
        const p = whiteOrder[i];
        keyPos.push({pc:p+12*o, x, white:true});
        x += whiteW;
      }
    }

    for (let i=0;i<keyPos.length;i++){
      const k = keyPos[i];
      const p = pc(k.pc);
      const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
      rect.setAttribute("x", String(k.x));
      rect.setAttribute("y", "0");
      rect.setAttribute("width", String(whiteW));
      rect.setAttribute("height", String(whiteH));

      const inScale = scalePCs.includes(p);
      rect.setAttribute("fill", inScale ? "var(--accent)" : "var(--keyWhite)");
      rect.setAttribute("stroke", inScale ? `rgba(0,0,0,var(--scaleStrokeAlpha))` : "var(--keyBorderStrong)");
      rect.setAttribute("stroke-width", inScale ? "var(--scaleStrokeWidth)" : "1.6");
      svg.appendChild(rect);

      const isChord = chordPCs.includes(p);
      const isRoot = chordRoot != null && p === pc(chordRoot);
      if (isChord){
        placeMarker(svg, k.x + whiteW*0.5, 175, isRoot ? "root" : "chord");
      }
      if (melodyPcs.has(p)){
        placeMelodyMarker(svg, k.x + whiteW*0.5, 130, false);
      }
    }

    const blackW = whiteW*0.62;
    const blackH = 140;
    const blackOffsets = {1:0.70, 3:1.72, 6:3.70, 8:4.72, 10:5.74};
    for (let o=0;o<oct;o++){
      for (const pRel of [1,3,6,8,10]){
        const baseWhiteIndex = blackOffsets[pRel];
        const x0 = (o*7 + baseWhiteIndex) * whiteW - blackW/2;
        const p = pc(pRel + 12*o);
        const rect = document.createElementNS("http://www.w3.org/2000/svg","rect");
        rect.setAttribute("x", String(x0));
        rect.setAttribute("y", "0");
        rect.setAttribute("rx", "6");
        rect.setAttribute("ry", "6");
        rect.setAttribute("width", String(blackW));
        rect.setAttribute("height", String(blackH));

        const inScale = scalePCs.includes(p);
        rect.setAttribute("fill", inScale ? "var(--accent)" : "var(--keyBlack)");
        rect.setAttribute("stroke", inScale ? `rgba(0,0,0,var(--scaleStrokeAlpha))` : "var(--keyBlackBorder)");
        rect.setAttribute("stroke-width", inScale ? "var(--scaleStrokeWidth)" : "1.6");
        svg.appendChild(rect);

        const isChord = chordPCs.includes(p);
        const isRoot = chordRoot != null && p === pc(chordRoot);
        if (isChord){
          placeMarker(svg, x0 + blackW*0.5, 95, isRoot ? "root" : "chord");
        }
        if (melodyPcs.has(p)){
          placeMelodyMarker(svg, x0 + blackW*0.5, 70, true);
        }
      }
    }
  }

  function renderAll(){
    renderHeaderPills();
    renderKeyLine();
    renderSongRandomLabel();
    renderLeadSheet();
    renderPianoForActive();
    try{
      renderMelodySheet();
    } catch (err){
      console.warn("Melody render failed", err);
      if (E.melodySheet) E.melodySheet.innerHTML = "";
      setMelodyStatus("Melody render failed.");
    }
  }

  /* ---------- SoundFont mappings ---------- */
  const SF_KEYS = {
    ep: 4,
    piano: 0,
    organ: 16,
    harpsichord: 6,
    accordion: 21,
    strings: 48,
    pad: 88,
    choirPad: 52,
    noisePad: 96,
    fm: 5,
    chip: 80,
    bell: 112,
    glass: 98,
    celesta: 8,
    vibes: 11,
    marimba: 12,
    harp: 46,
    pluck2: 45,
    guitarish: 25,
    clavBright: 7,
  };

  const SF_BASS = {
    upright: 32,
    contra: 33,
    fretless: 35,
    pizz: 33,
    round: 33,
    sub: 38,
    pluck: 36,
    pickBass: 34,
    muted: 39,
    fmBass: 38,
    rubber: 37,
    acid: 38,
    reese: 39,
    squareBass: 38,
    wobble: 39,
    mono: 38,
  };

  const SF_DRUMS = {
    jazz: 32,
    swing: 32,
    shuffle: 0,
    brushes: 40,
    tight: 8,
    rock: 16,
    room: 8,
    disco: 0,
    lofi: 0,
    minimal: 0,
    ambient: 48,
    electro: 24,
    analog: 24,
    house: 24,
    trap: 24,
    breaks: 0,
    dnb: 24,
    techno: 24,
    boomBap: 0,
    perc: 0,
    latinKit: 0,
    orchestral: 48,
    free: 32,
  };

  const SF_DRUM_NOTES = {
    kick: 36,
    snare: 38,
    hat: 42,
    ride: 51,
  };

  function soundFontProgramsForState(){
    return {
      keys: SF_KEYS[state.keysPreset] ?? 4,
      bass: SF_BASS[state.bassPreset] ?? 32,
      drums: SF_DRUMS[state.drumsPreset] ?? 0,
    };
  }

  /* ---------- Audio ---------- */
  const AudioKit = (() => {
    let ctx = null;
    let master = null;
    let comp = null;
    let limiter = null;

    const sf = {
      synth: null,
      node: null,
      sfontId: null,
      ready: false,
      loading: false,
      lastUrl: "",
      loadError: "",
      timers: new Set()
    };
    const SF_CHANNELS = { keys: 0, bass: 1, drums: 9 };

    function ensure(){
      if (ctx) return ctx;
      const AC = window.AudioContext || window.webkitAudioContext;
      ctx = new AC({ latencyHint: "interactive" });

      master = ctx.createGain();
      master.gain.value = 0.85;

      comp = ctx.createDynamicsCompressor();
      comp.threshold.value = -18;
      comp.knee.value = 22;
      comp.ratio.value = 3.5;
      comp.attack.value = 0.004;
      comp.release.value = 0.16;

      limiter = ctx.createDynamicsCompressor();
      limiter.threshold.value = -6;
      limiter.knee.value = 0;
      limiter.ratio.value = 20;
      limiter.attack.value = 0.002;
      limiter.release.value = 0.12;

      comp.connect(limiter);
      limiter.connect(master);
      master.connect(ctx.destination);
      return ctx;
    }

    function now(){ return ensure().currentTime; }
    function midiToHz(m){ return 440 * Math.pow(2, (m-69)/12); }

    function soundFontActive(){
      return !!(state.soundFontEnabled && sf.ready && sf.synth);
    }

    async function ensureSoundFont(){
      ensure();
      if (sf.synth || sf.loading) return;
      sf.loading = true;
      sf.loadError = "";
      try{
        if (!window.JSSynth) throw new Error("SoundFont engine unavailable.");
        await window.JSSynth.waitForReady();
        const synth = new window.JSSynth.Synthesizer();
        synth.init(ctx.sampleRate, { initialGain: 0.7, midiChannelCount: 16 });
        const node = synth.createAudioNode(ctx, 4096);
        node.connect(comp);
        sf.synth = synth;
        sf.node = node;
      } catch (err){
        sf.loadError = err && err.message ? err.message : "SoundFont init failed.";
        throw err;
      } finally {
        sf.loading = false;
      }
    }

    async function loadSoundFontBuffer(buffer, urlLabel=""){
      await ensureSoundFont();
      if (sf.sfontId != null){
        try{ sf.synth.unloadSFont(sf.sfontId); }catch{}
      }
      const id = await sf.synth.loadSFont(buffer);
      sf.sfontId = id;
      sf.ready = true;
      sf.loadError = "";
      if (urlLabel) sf.lastUrl = urlLabel;
      updateSoundFontPrograms();
      return id;
    }

    async function loadSoundFontUrl(url){
      const normalized = normalizeSoundFontUrl(url);
      if (!normalized) throw new Error("Missing SoundFont URL.");
      const res = await fetch(normalized, { cache: "no-store" });
      if (!res.ok) throw new Error("SoundFont fetch failed.");
      const buf = await res.arrayBuffer();
      await loadSoundFontBuffer(buf, normalized);
    }

    function resolveDrumProgram(requested){
      const prog = Number.isFinite(requested) ? requested : 0;
      const getter = sf.synth && sf.synth.getSFontPreset;
      if (typeof getter !== "function") return { bank: 128, prog };
      const hasPreset = (bank, program)=>{
        try{
          const preset = (getter.length >= 3)
            ? getter.call(sf.synth, sf.sfontId, bank, program)
            : getter.call(sf.synth, bank, program);
          return !!preset;
        }catch{
          return false;
        }
      };

      if (hasPreset(128, prog)) return { bank: 128, prog };
      if (hasPreset(0, prog)) return { bank: 0, prog };
      if (hasPreset(128, 0)) return { bank: 128, prog: 0 };
      return { bank: 0, prog: 0 };
    }

    function updateSoundFontPrograms(){
      if (!soundFontActive()) return;
      if (sf.sfontId == null) return;
      const prog = soundFontProgramsForState();
      const drum = resolveDrumProgram(prog.drums);
      for (let ch=0; ch<16; ch++){
        if (ch === SF_CHANNELS.drums) continue;
        const p = (ch === SF_CHANNELS.bass) ? prog.bass : prog.keys;
        sf.synth.midiProgramSelect(ch, sf.sfontId, 0, p);
      }
      sf.synth.midiProgramSelect(SF_CHANNELS.drums, sf.sfontId, drum.bank, drum.prog);
      if (typeof sf.synth.midiControlChange === "function"){
        sf.synth.midiControlChange(SF_CHANNELS.drums, 7, 127);
      }
    }

    function setMidiProgram(channel, program, bank){
      if (!soundFontActive()) return;
      if (sf.sfontId == null) return;
      const ch = clamp(Math.round(Number(channel) || 0), 0, 15);
      let prog = Number.isFinite(program) ? Math.round(program) : 0;
      let b = Number.isFinite(bank) ? Math.round(bank) : 0;
      if (ch === SF_CHANNELS.drums && !Number.isFinite(bank)){
        const drum = resolveDrumProgram(prog);
        b = drum.bank;
        prog = drum.prog;
      }
      sf.synth.midiProgramSelect(ch, sf.sfontId, b, prog);
    }

    function sfScheduleNote(channel, midi, vel, t0, dur){
      if (!soundFontActive()) return;
      const v = Math.max(1, Math.min(127, Math.round(vel * 127)));
      const tNow = now();
      const onMs = Math.max(0, (t0 - tNow) * 1000);
      const offMs = Math.max(0, (t0 + dur - tNow) * 1000);
      const onId = setTimeout(()=>{
        sf.timers.delete(onId);
        sf.synth.midiNoteOn(channel, midi, v);
      }, onMs);
      const offId = setTimeout(()=>{
        sf.timers.delete(offId);
        sf.synth.midiNoteOff(channel, midi);
      }, offMs);
      sf.timers.add(onId);
      sf.timers.add(offId);
    }

    function soundFontAllNotesOff(){
      if (!soundFontActive()) return;
      sf.timers.forEach(id=> clearTimeout(id));
      sf.timers.clear();
      for (let ch=0; ch<16; ch++){
        try{ sf.synth.midiAllNotesOff(ch); }catch{}
      }
    }

    function env(gainNode, t0, a, d, s, r, peak=0.8){
      const t1 = t0 + a;
      const t2 = t1 + d;
      gainNode.gain.cancelScheduledValues(t0);
      gainNode.gain.setValueAtTime(0.0001, t0);
      gainNode.gain.linearRampToValueAtTime(peak, t1);
      gainNode.gain.linearRampToValueAtTime(Math.max(0.0001, peak*s), t2);
      return (tOff)=>{
        gainNode.gain.cancelScheduledValues(tOff);
        const v = Math.max(0.0001, gainNode.gain.value || 0.0001);
        gainNode.gain.setValueAtTime(v, tOff);
        gainNode.gain.exponentialRampToValueAtTime(0.0001, tOff + r);
      };
    }

    function osc(type="sine"){
      const c = ensure();
      const o = c.createOscillator();
      o.type = type;
      return o;
    }

    function noise(){
      const c = ensure();
      const buffer = c.createBuffer(1, c.sampleRate * 0.25, c.sampleRate);
      const data = buffer.getChannelData(0);
      for (let i=0;i<data.length;i++) data[i] = (Math.random()*2-1) * (1 - i/data.length);
      const src = c.createBufferSource();
      src.buffer = buffer;
      return src;
    }

    function createVoiceChain(){
      const c = ensure();
      const g = c.createGain();
      g.gain.value = 1.0;
      g.connect(comp);
      return { ctx:c, out:g };
    }
    const KEY_PRESETS = {
      ep:{type:"triangle", a:0.008, d:0.08, s:0.32, r:0.18, peak:0.38},
      piano:{type:"sine", a:0.006, d:0.08, s:0.22, r:0.22, peak:0.34, filter:{type:"highpass", freq:180}},
      organ:{type:"square", a:0.004, d:0.06, s:0.55, r:0.12, peak:0.32, filter:{type:"lowpass", freq:1800}},
      harpsichord:{type:"square", a:0.002, d:0.05, s:0.10, r:0.12, peak:0.30, filter:{type:"highpass", freq:900}},
      accordion:{type:"square", a:0.006, d:0.08, s:0.45, r:0.20, peak:0.30, detune:3, filter:{type:"lowpass", freq:1500}},
      strings:{type:"sawtooth", a:0.06, d:0.10, s:0.72, r:0.60, peak:0.26, detune:8, vStyle:"open", tail:0.45, filter:{type:"lowpass", freq:900}},
      pad:{type:"sine", a:0.04, d:0.10, s:0.70, r:0.60, peak:0.28, detune:6, vStyle:"open", tail:0.45, filter:{type:"lowpass", freq:900}},
      choirPad:{type:"sine", a:0.05, d:0.10, s:0.68, r:0.70, peak:0.26, detune:5, vStyle:"open", tail:0.45, filter:{type:"lowpass", freq:1200}},
      noisePad:{type:"sine", a:0.04, d:0.12, s:0.60, r:0.60, peak:0.22, detune:4, vStyle:"open", tail:0.45, filter:{type:"bandpass", freq:1200, q:0.7}},
      fm:{type:"sine", a:0.006, d:0.07, s:0.28, r:0.18, peak:0.34, detune:2},
      chip:{type:"square", a:0.004, d:0.06, s:0.18, r:0.10, peak:0.30, filter:{type:"highpass", freq:500}},
      bell:{type:"sine", a:0.002, d:0.08, s:0.12, r:0.26, peak:0.32, detune:4, filter:{type:"highpass", freq:700}},
      glass:{type:"sine", a:0.002, d:0.08, s:0.10, r:0.28, peak:0.30, detune:6, filter:{type:"highpass", freq:900}},
      celesta:{type:"triangle", a:0.002, d:0.08, s:0.10, r:0.26, peak:0.28, detune:5, filter:{type:"highpass", freq:1200}},
      vibes:{type:"sine", a:0.003, d:0.10, s:0.18, r:0.30, peak:0.32, detune:4},
      marimba:{type:"triangle", a:0.003, d:0.06, s:0.12, r:0.16, peak:0.30, filter:{type:"bandpass", freq:700, q:1.2}},
      harp:{type:"triangle", a:0.004, d:0.08, s:0.18, r:0.20, peak:0.30, detune:6, filter:{type:"lowpass", freq:2200}},
      pluck2:{type:"triangle", a:0.004, d:0.07, s:0.18, r:0.18, peak:0.32, filter:{type:"lowpass", freq:1800}},
      guitarish:{type:"triangle", a:0.003, d:0.06, s:0.20, r:0.18, peak:0.30, filter:{type:"lowpass", freq:1400}},
      clavBright:{type:"square", a:0.003, d:0.05, s:0.12, r:0.14, peak:0.30, filter:{type:"highpass", freq:1200}},
    };

    const BASS_PRESETS = {
      upright:{type:"triangle", a:0.004, d:0.06, s:0.35, r:0.16, peak:0.40, slide:true, filter:{type:"lowpass", freq:700}},
      contra:{type:"sine", a:0.008, d:0.08, s:0.40, r:0.26, peak:0.40, filter:{type:"lowpass", freq:420}},
      fretless:{type:"sine", a:0.006, d:0.07, s:0.38, r:0.22, peak:0.34, detune:2, filter:{type:"lowpass", freq:600}},
      pizz:{type:"triangle", a:0.002, d:0.05, s:0.18, r:0.12, peak:0.32, slide:true, filter:{type:"lowpass", freq:1100}},
      round:{type:"sine", a:0.004, d:0.07, s:0.38, r:0.18, peak:0.38, filter:{type:"lowpass", freq:600}},
      sub:{type:"sine", a:0.006, d:0.08, s:0.40, r:0.22, peak:0.42, filter:{type:"lowpass", freq:420}},
      pluck:{type:"triangle", a:0.003, d:0.05, s:0.25, r:0.14, peak:0.36, slide:true, filter:{type:"lowpass", freq:900}},
      pickBass:{type:"triangle", a:0.003, d:0.05, s:0.24, r:0.14, peak:0.34, slide:true, filter:{type:"lowpass", freq:1200}},
      muted:{type:"triangle", a:0.003, d:0.04, s:0.20, r:0.12, peak:0.30, filter:{type:"lowpass", freq:800}},
      fmBass:{type:"sine", a:0.004, d:0.06, s:0.30, r:0.16, peak:0.36, detune:2, filter:{type:"lowpass", freq:900}},
      rubber:{type:"triangle", a:0.004, d:0.06, s:0.30, r:0.16, peak:0.36, filter:{type:"lowpass", freq:1000}},
      acid:{type:"sawtooth", a:0.003, d:0.06, s:0.28, r:0.12, peak:0.32, filter:{type:"lowpass", freq:1000, q:0.9}},
      reese:{type:"sawtooth", a:0.004, d:0.07, s:0.30, r:0.16, peak:0.34, detune:8, dual:true, filter:{type:"lowpass", freq:800}},
      squareBass:{type:"square", a:0.003, d:0.05, s:0.25, r:0.12, peak:0.32, filter:{type:"lowpass", freq:1000}},
      wobble:{type:"square", a:0.004, d:0.06, s:0.30, r:0.16, peak:0.34, filter:{type:"lowpass", freq:700}},
      mono:{type:"square", a:0.004, d:0.06, s:0.30, r:0.16, peak:0.34, filter:{type:"lowpass", freq:900}},
    };

    const DRUM_DEFAULTS = {
      kick:{
        toneStart:110, toneEnd:55, toneSlide:0.08, toneDur:0.20,
        toneA:0.001, toneD:0.05, toneS:0.05, toneR:0.12, tonePeak:0.70, toneRel:0.7,
        noiseFreq:140, noiseQ:0.8, noiseDur:0.11,
        noiseD:0.03, noiseS:0.02, noiseR:0.10, noisePeak:0.25, noiseRel:0.6
      },
      snare:{
        noiseFreq:1800, noiseQ:1.2, noiseDur:0.20,
        noiseD:0.06, noiseS:0.05, noiseR:0.14, noisePeak:0.55, noiseRel:0.55
      },
      hat:{
        noiseFreq:9500, noiseQ:0.9, noiseDur:0.11,
        noiseD:0.02, noiseS:0.04, noiseR:0.09, noisePeak:0.42, noiseRel:0.55
      },
      ride:{
        noiseFreq:7800, noiseQ:0.7, noiseDur:0.38,
        noiseD:0.06, noiseS:0.20, noiseR:0.20, noisePeak:0.36, noiseRel:0.58
      },
    };

    const DRUM_KITS = {
      jazz:{},
      swing:{ ride:{noiseDur:0.42, noisePeak:0.40} },
      shuffle:{ snare:{noiseDur:0.24, noisePeak:0.58}, hat:{noiseDur:0.12, noiseFreq:9000} },
      brushes:{
        kick:{toneStart:100, toneEnd:50, noisePeak:0.18, noiseDur:0.14},
        snare:{noiseFreq:1400, noiseDur:0.26, noisePeak:0.40},
        hat:{noiseFreq:7600, noiseDur:0.14, noisePeak:0.32},
        ride:{noiseFreq:6500, noiseDur:0.48, noisePeak:0.30}
      },
      tight:{
        kick:{toneStart:120, toneEnd:60, noiseDur:0.08, noisePeak:0.22},
        snare:{noiseFreq:2000, noiseDur:0.14, noisePeak:0.50},
        hat:{noiseFreq:10000, noiseDur:0.07, noisePeak:0.45},
        ride:{noiseFreq:8500, noiseDur:0.22, noisePeak:0.30}
      },
      rock:{
        kick:{toneStart:120, toneEnd:48, noiseDur:0.12, noisePeak:0.30},
        snare:{noiseFreq:1900, noiseDur:0.24, noisePeak:0.65},
        hat:{noiseFreq:9000, noiseDur:0.12, noisePeak:0.50},
        ride:{noiseFreq:7600, noiseDur:0.40, noisePeak:0.50}
      },
      room:{
        kick:{toneStart:115, toneEnd:50, noiseDur:0.16, noisePeak:0.32},
        snare:{noiseFreq:1900, noiseDur:0.28, noisePeak:0.60},
        hat:{noiseFreq:9000, noiseDur:0.12, noisePeak:0.42},
        ride:{noiseFreq:7600, noiseDur:0.44, noisePeak:0.40}
      },
      disco:{
        kick:{toneStart:130, toneEnd:65, noiseDur:0.10, noisePeak:0.28},
        snare:{noiseFreq:2100, noiseDur:0.20, noisePeak:0.60},
        hat:{noiseFreq:10500, noiseDur:0.09, noisePeak:0.55},
        ride:{noiseFreq:9000, noiseDur:0.28, noisePeak:0.38}
      },
      lofi:{
        kick:{toneStart:100, toneEnd:45, noiseDur:0.15, noisePeak:0.20},
        snare:{noiseFreq:1200, noiseDur:0.25, noisePeak:0.45},
        hat:{noiseFreq:6500, noiseDur:0.10, noisePeak:0.32},
        ride:{noiseFreq:5200, noiseDur:0.30, noisePeak:0.32}
      },
      minimal:{
        kick:{toneStart:90, toneEnd:45, noiseDur:0.07, noisePeak:0.14},
        snare:{noiseFreq:1600, noiseDur:0.12, noisePeak:0.26},
        hat:{noiseFreq:9000, noiseDur:0.06, noisePeak:0.25},
        ride:{noiseFreq:7000, noiseDur:0.16, noisePeak:0.20}
      },
      ambient:{
        kick:{toneStart:90, toneEnd:45, noiseDur:0.12, noisePeak:0.18},
        snare:{noiseFreq:1200, noiseDur:0.32, noisePeak:0.28},
        hat:{noiseFreq:7000, noiseDur:0.20, noisePeak:0.22},
        ride:{noiseFreq:5200, noiseDur:0.60, noisePeak:0.26}
      },
      electro:{
        kick:{toneStart:140, toneEnd:60, noiseDur:0.09, noisePeak:0.26},
        snare:{noiseFreq:2400, noiseDur:0.16, noisePeak:0.55},
        hat:{noiseFreq:11000, noiseDur:0.07, noisePeak:0.45},
        ride:{noiseFreq:9000, noiseDur:0.25, noisePeak:0.35}
      },
      analog:{
        kick:{toneStart:120, toneEnd:50, noiseDur:0.10, noisePeak:0.28},
        snare:{noiseFreq:2000, noiseDur:0.18, noisePeak:0.48},
        hat:{noiseFreq:12000, noiseDur:0.06, noisePeak:0.45},
        ride:{noiseFreq:9800, noiseDur:0.18, noisePeak:0.32}
      },
      house:{
        kick:{toneStart:120, toneEnd:55, noiseDur:0.11, noisePeak:0.30},
        snare:{noiseFreq:2200, noiseDur:0.18, noisePeak:0.50},
        hat:{noiseFreq:10500, noiseDur:0.08, noisePeak:0.48},
        ride:{noiseFreq:8800, noiseDur:0.28, noisePeak:0.38}
      },
      trap:{
        kick:{toneStart:120, toneEnd:50, noiseDur:0.08, noisePeak:0.26},
        snare:{noiseFreq:2500, noiseDur:0.15, noisePeak:0.50},
        hat:{noiseFreq:11500, noiseDur:0.05, noisePeak:0.55},
        ride:{noiseFreq:9800, noiseDur:0.18, noisePeak:0.32}
      },
      breaks:{
        kick:{toneStart:130, toneEnd:55, noiseDur:0.10, noisePeak:0.28},
        snare:{noiseFreq:2300, noiseDur:0.18, noisePeak:0.58},
        hat:{noiseFreq:9800, noiseDur:0.08, noisePeak:0.45},
        ride:{noiseFreq:8200, noiseDur:0.30, noisePeak:0.34}
      },
      dnb:{
        kick:{toneStart:130, toneEnd:55, noiseDur:0.10, noisePeak:0.30},
        snare:{noiseFreq:2300, noiseDur:0.16, noisePeak:0.55},
        hat:{noiseFreq:10500, noiseDur:0.07, noisePeak:0.48},
        ride:{noiseFreq:9000, noiseDur:0.24, noisePeak:0.34}
      },
      techno:{
        kick:{toneStart:130, toneEnd:60, noiseDur:0.10, noisePeak:0.32},
        snare:{noiseFreq:2100, noiseDur:0.16, noisePeak:0.52},
        hat:{noiseFreq:11000, noiseDur:0.07, noisePeak:0.50},
        ride:{noiseFreq:9200, noiseDur:0.22, noisePeak:0.36}
      },
      boomBap:{
        kick:{toneStart:100, toneEnd:45, noiseDur:0.16, noisePeak:0.28},
        snare:{noiseFreq:1500, noiseDur:0.26, noisePeak:0.52},
        hat:{noiseFreq:7000, noiseDur:0.10, noisePeak:0.35},
        ride:{noiseFreq:6000, noiseDur:0.28, noisePeak:0.30}
      },
      perc:{
        kick:{toneStart:110, toneEnd:55, noiseDur:0.10, noisePeak:0.26},
        snare:{noiseFreq:2200, noiseDur:0.18, noisePeak:0.55},
        hat:{noiseFreq:10000, noiseDur:0.08, noisePeak:0.40},
        ride:{noiseFreq:8600, noiseDur:0.30, noisePeak:0.36}
      },
      latinKit:{
        kick:{toneStart:105, toneEnd:55, noiseDur:0.10, noisePeak:0.24},
        snare:{noiseFreq:2000, noiseDur:0.20, noisePeak:0.50},
        hat:{noiseFreq:9800, noiseDur:0.09, noisePeak:0.40},
        ride:{noiseFreq:8800, noiseDur:0.34, noisePeak:0.34}
      },
      orchestral:{
        kick:{toneStart:90, toneEnd:45, noiseDur:0.14, noisePeak:0.28},
        snare:{noiseFreq:1600, noiseDur:0.26, noisePeak:0.48},
        hat:{noiseFreq:6500, noiseDur:0.18, noisePeak:0.30},
        ride:{noiseFreq:5200, noiseDur:0.50, noisePeak:0.30}
      },
      free:{
        kick:{toneStart:100, toneEnd:45, noiseDur:0.16, noisePeak:0.22},
        snare:{noiseFreq:1500, noiseDur:0.30, noisePeak:0.42},
        hat:{noiseFreq:7200, noiseDur:0.18, noisePeak:0.30},
        ride:{noiseFreq:6000, noiseDur:0.60, noisePeak:0.30}
      },
    };

  function chordVoicingMidi(ch, style="closed"){
    const root = ch.root;
    const tones = chordTonesPCs(ch).slice();
    const base = 52 + (pc(root) - 0); // lower register to reduce brightness
    const mids = tones.map(p=>{
      let m = base + (pc(p - pc(root)));
      while (m < 46) m += 12;
      while (m > 74) m -= 12;
      return m;
    });
    mids.sort((a,b)=>a-b);
    if ((style==="open" || mids.length>=5) && mids.length>=4){
      mids[0] -= 12;
      mids[2] += 12;
      mids.sort((a,b)=>a-b);
    }

    // enforce minimum spacing (>=3 semitones) by nudging upward
    for (let i=1;i<mids.length;i++){
      if (mids[i] - mids[i-1] < 3) mids[i] = mids[i-1] + 3;
    }

    return mids;
  }
    function playChord(ch, preset, t0, dur, vel=0.7){
      if (soundFontActive()){
        const cfg = KEY_PRESETS[preset] || KEY_PRESETS.ep;
        const vStyle = cfg.vStyle || "closed";
        const mids = chordVoicingMidi(ch, vStyle);
        mids.forEach(m=> sfScheduleNote(SF_CHANNELS.keys, m, vel, t0, dur));
        return;
      }
      const c = ensure();
      const {out} = createVoiceChain();

      const cfg = KEY_PRESETS[preset] || KEY_PRESETS.ep;
      const vStyle = cfg.vStyle || "closed";
      const mids = chordVoicingMidi(ch, vStyle);

      const gain = c.createGain();
      gain.gain.value = 0.0001;
      gain.connect(out);

      let input = gain;
      if (cfg.filter){
        const f = c.createBiquadFilter();
        f.type = cfg.filter.type;
        f.frequency.value = cfg.filter.freq;
        f.Q.value = (cfg.filter.q==null) ? 0.8 : cfg.filter.q;
        f.connect(gain);
        input = f;
      }

      const release = env(gain, t0, cfg.a, cfg.d, cfg.s, cfg.r, (cfg.peak||0.34)*vel);
      const tail = (cfg.tail==null) ? 0.25 : cfg.tail;

      for (let i=0;i<mids.length;i++){
        const o = osc(cfg.type);
        o.frequency.setValueAtTime(midiToHz(mids[i]), t0);
        if (cfg.detune){
          const center = (mids.length-1)/2;
          o.detune.setValueAtTime((i-center)*cfg.detune, t0);
        }
        o.connect(input);
        o.start(t0);
        o.stop(t0 + dur + tail);
      }
      release(t0 + dur);
    }
    function playNote(midi, preset, t0, dur, vel=0.7){
      if (!Number.isFinite(midi)) return;
      if (soundFontActive()){
        sfScheduleNote(SF_CHANNELS.keys, midi, vel, t0, dur);
        return;
      }
      const c = ensure();
      const {out} = createVoiceChain();
      const cfg = KEY_PRESETS[preset] || KEY_PRESETS.ep;

      const gain = c.createGain();
      gain.gain.value = 0.0001;
      gain.connect(out);

      let input = gain;
      if (cfg.filter){
        const f = c.createBiquadFilter();
        f.type = cfg.filter.type;
        f.frequency.value = cfg.filter.freq;
        f.Q.value = (cfg.filter.q==null) ? 0.8 : cfg.filter.q;
        f.connect(gain);
        input = f;
      }

      const release = env(gain, t0, cfg.a, cfg.d, cfg.s, cfg.r, (cfg.peak||0.34)*vel);
      const tail = (cfg.tail==null) ? 0.25 : cfg.tail;

      const o = osc(cfg.type);
      o.frequency.setValueAtTime(midiToHz(midi), t0);
      o.connect(input);
      o.start(t0);
      o.stop(t0 + dur + tail);
      release(t0 + dur);
    }
    function playMidiNote(midi, channel, t0, dur, vel=0.7){
      if (!Number.isFinite(midi)) return;
      const raw = Number.isFinite(channel) ? channel : SF_CHANNELS.keys;
      const ch = clamp(Math.round(raw), 0, 15);
      if (soundFontActive()){
        sfScheduleNote(ch, midi, vel, t0, dur);
        return;
      }
      playNote(midi, state.keysPreset, t0, dur, vel);
    }



    function playBass(rootPc, preset, t0, dur, vel=0.8){
      if (soundFontActive()){
        let m = 40 + pc(rootPc);
        while (m < 36) m += 12;
        while (m > 52) m -= 12;
        sfScheduleNote(SF_CHANNELS.bass, m, vel, t0, dur);
        return;
      }
      const c = ensure();
      const {out} = createVoiceChain();

      const cfg = BASS_PRESETS[preset] || BASS_PRESETS.upright;

      const gain = c.createGain();
      gain.gain.value = 0.0001;
      gain.connect(out);

      let input = gain;
      if (cfg.filter){
        const f = c.createBiquadFilter();
        f.type = cfg.filter.type;
        f.frequency.value = cfg.filter.freq;
        f.Q.value = (cfg.filter.q==null) ? 0.7 : cfg.filter.q;
        f.connect(gain);
        input = f;
      }

      const rel = env(gain, t0, cfg.a, cfg.d, cfg.s, cfg.r, cfg.peak*vel);

      let m = 40 + pc(rootPc);
      while (m < 36) m += 12;
      while (m > 52) m -= 12;

      const detunes = cfg.detune ? (cfg.dual ? [cfg.detune, -cfg.detune] : [cfg.detune]) : [0];
      const tail = (cfg.tail==null) ? 0.18 : cfg.tail;

      for (const det of detunes){
        const o = osc(cfg.type);
        o.frequency.setValueAtTime(midiToHz(m), t0);
        if (det) o.detune.setValueAtTime(det, t0);
        if (cfg.slide){
          o.frequency.setValueAtTime(midiToHz(m)*1.02, t0);
          o.frequency.exponentialRampToValueAtTime(midiToHz(m), t0+0.05);
        }
        o.connect(input);
        o.start(t0);
        o.stop(t0 + dur + tail);
      }
      rel(t0 + dur);
    }
    function playDrumHit(kind, preset, t0, vel=0.8){
      if (soundFontActive()){
        const note = SF_DRUM_NOTES[kind] || 36;
        const len = (kind==="ride") ? 0.45 : (kind==="hat" ? 0.12 : 0.20);
        const v = Math.min(1, vel * 1.25);
        sfScheduleNote(SF_CHANNELS.drums, note, v, t0, len);
        return;
      }
      const c = ensure();
      const {out} = createVoiceChain();
      const g = c.createGain();
      g.gain.value = 0.0001;
      g.connect(out);

      const kit = DRUM_KITS[preset] || DRUM_KITS.jazz;
      const base = DRUM_DEFAULTS[kind] || DRUM_DEFAULTS.snare;
      const cfg = {...base, ...(kit[kind] || {})};

      const n = noise();
      const f = c.createBiquadFilter();
      f.type = "bandpass";
      f.frequency.value = cfg.noiseFreq;
      f.Q.value = cfg.noiseQ;

      n.connect(f);
      f.connect(g);

      if (kind==="kick"){
        const o = osc("sine");
        const og = c.createGain();
        og.gain.value = 0.0001;
        og.connect(out);
        const rel1 = env(og, t0, cfg.toneA, cfg.toneD, cfg.toneS, cfg.toneR, cfg.tonePeak*vel);
        o.frequency.setValueAtTime(cfg.toneStart, t0);
        o.frequency.exponentialRampToValueAtTime(cfg.toneEnd, t0 + cfg.toneSlide);
        o.connect(og);
        o.start(t0);
        o.stop(t0 + cfg.toneDur);
        rel1(t0 + cfg.toneDur * (cfg.toneRel ?? 0.7));

        const relN = env(g, t0, 0.001, cfg.noiseD, cfg.noiseS, cfg.noiseR, cfg.noisePeak*vel);
        const nStop = t0 + cfg.noiseDur;
        n.start(t0); n.stop(nStop); relN(t0 + cfg.noiseDur * (cfg.noiseRel ?? 0.6));
        return;
      }

      const relN = env(g, t0, 0.001, cfg.noiseD, cfg.noiseS, cfg.noiseR, cfg.noisePeak*vel);
      const nStop = t0 + cfg.noiseDur;
      n.start(t0); n.stop(nStop); relN(t0 + cfg.noiseDur * (cfg.noiseRel ?? 0.55));
    }

    async function resume(){
      ensure();
      if (!ctx) return;
      if (ctx.state === "suspended"){
        try{ await ctx.resume(); }catch(e){}
      }
    }

    function hardStop(){ soundFontAllNotesOff(); }

    return {
      ensure, now, resume, playChord, playNote, playMidiNote, playBass, playDrumHit, hardStop,
      loadSoundFontUrl, loadSoundFontBuffer, updateSoundFontPrograms, setMidiProgram,
      soundFontActive, soundFontAllNotesOff
    };
  })();

  window.addEventListener("pointerdown", () => { AudioKit.resume(); }, { once:true, passive:true });

  /* ---------- Player (Transport) ---------- */
  const player = (() => {
    let isPlaying = false;
    let timer = null;
    let tempo = DEFAULTS.tempo;
    let swing = DEFAULTS.swing;
    let chart = [];
    let order = [];
    let atStep = 0;
    let atHalf = 0;

    function setTempo(t, sw){
      tempo = clamp(Number(t)||120, 30, 320);
      swing = clamp(Number(sw)||58, 50, 80);
    }
    function setChart(bars, playbackOrder){
      chart = Array.isArray(bars) ? bars : [];
      if (Array.isArray(playbackOrder) && playbackOrder.length){
        order = playbackOrder.filter(i => Number.isFinite(i) && i >= 0 && i < chart.length);
        if (!order.length) order = chart.map((_, i)=>i);
      } else {
        order = chart.map((_, i)=>i);
      }
    }
    function jumpTo(b,h){
      if (!order.length){
        atStep = 0;
        atHalf = 0;
        return;
      }
      const idx = order.indexOf(b);
      atStep = (idx >= 0) ? idx : clamp(b,0,Math.max(0, order.length-1));
      const barIdx = order[atStep] ?? b;
      const bar = chart[barIdx];
      atHalf = clamp(h,0,Math.max(0,(bar?.chords?.length||1)-1));
    }

    function barSeconds(){
      if (state.biabActive && state.biabTimeSig){
        const num = state.biabTimeSig.num || 4;
        const den = state.biabTimeSig.den || 4;
        return (60 / tempo) * num * (4 / den);
      }
      return 240 / tempo;
    } // 4/4 bar length
    function halfSeconds(){ return barSeconds()/2; }

    function currentChord(){
      const barIdx = order[atStep] ?? atStep;
      const bar = chart[barIdx];
      if (!bar) return null;
      const idx = clamp(atHalf,0,Math.max(0,(bar.chords?.length||1)-1));
      let ch = bar.chords?.[idx] || null;
      if (!ch){
        for (let i=barIdx-1;i>=0;i--){
          const prev = chart[i];
          if (prev?.chords?.length){
            ch = prev.chords[prev.chords.length - 1] || null;
            break;
          }
        }
      }
      return ch;
    }

    function nextStep(){
      const barIdx = order[atStep] ?? atStep;
      const bar = chart[barIdx];
      if (!bar) return;

      const halves = bar.split ? 2 : 1;
      if (halves===2){
        if (atHalf===0){ atHalf=1; return; }
        atHalf=0; atStep++;
      }else{
        atHalf=0; atStep++;
      }
      if (atStep >= order.length){
        atStep = 0;
        atHalf = 0;
      }
    }

    function scheduleStep(){
      if (!isPlaying) return;
      const t0 = AudioKit.now() + 0.02;

      const barIdx = order[atStep] ?? atStep;
      const bar = chart[barIdx];
      if (!bar) return;

      // Update UI focus to stay perfectly in sync with audio ‚Äúnow‚Äù
      state.activeBar = barIdx;
      state.activeHalf = atHalf;
      highlightActiveBar();
      renderHeaderPills();
      renderPianoForActive();

      // Length
      const dur = (bar.split ? halfSeconds() : barSeconds());
      if (state.biabActive){
        scheduleBiabMidi(barIdx, atHalf, t0);
        scheduleBiabMelody(barIdx, atHalf, t0, { playAudio: false, highlight: true });
        nextStep();
        return;
      }

      const ch = currentChord();
      if (!ch) return;

      scheduleBiabMelody(barIdx, atHalf, t0);
      const isSplit = !!bar.split;
      const isSecondHalf = isSplit && atHalf===1;
      const splitScale = isSplit ? 0.65 : 1;
      const halfScale = isSecondHalf ? 0.85 : 1;
      const density = splitScale * halfScale;

      // --- Keys comp ---
      // Style maps to pattern density
      const comp = state.compStyle;
      const kBusy = clamp(state.keysComplex/100,0,1);
      const kFill = clamp(state.keysFill/100,0,1) * density;

      let stabCount = (() => {
        if (comp==="twoStabs") return 2;
        if (comp==="fourComp") return 4;
        if (comp==="charleston") return 2;
        if (comp==="anticipations") return 3;
        if (comp==="pushPull") return 3;
        if (comp==="sparse") return 1;
        if (comp==="arpeggio") return 3;
        if (comp==="sustain") return 1;
        if (comp==="montuno") return 4;
        if (comp==="clav") return 4;
        if (comp==="rockChugs") return 4;
        if (comp==="discoChop") return 4;
        if (comp==="neoSoulPush") return 3;
        if (comp==="edmStab") return 2;
        return 2;
      })();
      if (isSplit) stabCount = Math.max(1, Math.round(stabCount * 0.6));
      if (isSecondHalf) stabCount = Math.max(1, Math.round(stabCount * 0.85));

      const offsets = [];
      if (stabCount===1){
        offsets.push(0);
      } else if (comp==="charleston"){
        offsets.push(0);
        offsets.push(dur*0.375);
      } else if (comp==="anticipations"){
        offsets.push(0);
        offsets.push(dur*0.25);
        offsets.push(dur*0.75);
      } else if (comp==="pushPull"){
        offsets.push(0);
        offsets.push(dur*0.50);
        offsets.push(dur*0.875);
      } else {
        for (let i=0;i<stabCount;i++) offsets.push((dur*(i/stabCount)));
      }
      if (isSplit && offsets.length > 1){
        const keep = Math.max(1, Math.round(offsets.length * 0.6));
        offsets.length = keep;
      }

      // add a tiny randomized humanization
      const human = (amt)=> (Math.random()*2-1)*amt;

      // sustain style: long pad
      if (comp==="sustain"){
        AudioKit.playChord(ch, state.keysPreset, t0, dur*0.95, 0.65);
      } else {
        offsets.forEach((off, i)=>{
          const v = 0.55 + 0.25*kBusy + 0.08*Math.sin(i*1.3);
          const len = dur * (comp==="rockChugs"||comp==="discoChop"||comp==="clav" ? 0.18 : 0.22);
          AudioKit.playChord(ch, state.keysPreset, t0 + off + human(0.008), Math.min(len, dur-off), v);
        });

        // fills: extra little stab near end
        if (chance(kFill*0.55)){
          const off = dur*(0.82 + 0.12*Math.random());
          const len = dur*0.14;
          AudioKit.playChord(ch, state.keysPreset, t0 + off + human(0.010), Math.min(len, dur-off), 0.55);
        }
      }

      // --- Bass ---
      const bBusy = clamp(state.bassComplex/100,0,1) * density;
      const bFill = clamp(state.bassFill/100,0,1) * density;
      const bassNotes = [];

      // basic walking: 1, 5, approach tones
      bassNotes.push({t:0, pc: pc(ch.root), len: dur*0.48, v: 0.75});
      const addFifth = !isSplit || !isSecondHalf;
      if (addFifth){
        if (dur > halfSeconds()*0.99){ // full bar
          bassNotes.push({t:dur*0.50, pc: pc(ch.root+7), len: dur*0.32, v: 0.72});
        } else {
          bassNotes.push({t:dur*0.50, pc: pc(ch.root+7), len: dur*0.24, v: 0.70});
        }
      }
      if (chance(bBusy*0.55)){
        bassNotes.push({t:dur*0.25, pc: pc(ch.root+12), len: dur*0.20, v: 0.60});
      }
      if (chance(bFill*0.50)){
        bassNotes.push({t:dur*0.86, pc: pc(ch.root + (chance(0.5)? 1 : -1)), len: dur*0.12, v: 0.55});
      }

      bassNotes.forEach(n=>{
        AudioKit.playBass(n.pc, state.bassPreset, t0 + n.t + human(0.006), n.len, n.v);
      });

      // --- Drums ---
      const dLvl = clamp(state.drumsLevel/100 * 1.7, 0, 1);
      const dBusy = clamp(state.drumsComplex/100,0,1) * density;
      const dFill = clamp(state.drumsFill/100,0,1) * density;

      const groove = state.grooveStyle;
      const beatCount = isSplit ? 2 : 4;
      const step = dur / (beatCount*4); // 16th-ish
      const beat = step * 4;
      const mid = beat * Math.max(1, Math.floor(beatCount/2));
      const beat2 = beat;
      const beat3 = mid;
      const beat4 = mid + beat;
      const hasFourBeats = beatCount >= 4;
      const late = dur - step*2;
      const late2 = dur - step*6;
      const swingAmt = (clamp(state.swing,50,75)-50)/25; // 0..1
      const swingDelay = step*0.45*swingAmt;
      let drumHitCount = 0;
      const isBarEnd = !isSplit || isSecondHalf;
      const phraseEnd = isBarEnd && ((atStep + 1) % 4 === 0 || atStep === order.length - 1);
      const fillChance = clamp(0.12 + dFill*0.6 + (phraseEnd ? 0.25 : 0), 0, 0.95);

      const inDur = (t)=> t < (dur - 0.002);
      function hit(kind, when, vel){
        if (dLvl<=0.01) return;
        drumHitCount++;
        AudioKit.playDrumHit(kind, state.drumsPreset, t0 + when, clamp(vel*dLvl,0,1));
      }
      const hitAt = (kind, when, vel)=>{
        if (!inDur(when)) return;
        hit(kind, when, vel);
      };
      const hitAtHuman = (kind, when, vel, amt=0.003)=>{
        hitAt(kind, when + human(amt), vel);
      };

      // ride pattern (jazzy)
      if (groove==="swing" || groove==="free"){
        const rideBase = [];
        for (let i=0;i<beatCount;i++) rideBase.push(i*beat);
        rideBase.forEach((q, idx)=>{
          hitAtHuman("ride", q, 0.52 + 0.18*(idx===0));
          hitAtHuman("ride", q + step*3 + swingDelay, 0.38 + 0.22*dBusy);
          if (chance(0.28 + 0.32*dBusy)) hitAtHuman("hat", q + step*2, 0.24);
        });
        if (chance(0.30 + 0.45*dBusy)) hitAtHuman("hat", mid, 0.38);
        // light comping snare
        if (chance(0.28 + 0.55*dBusy)) hitAtHuman("snare", step*6, 0.26);
        if (chance(0.24 + 0.50*dBusy)) hitAtHuman("snare", late, 0.24);
        if (hasFourBeats){
          if (chance(0.35 + 0.35*dBusy)) hitAtHuman("snare", beat2, 0.24);
          if (chance(0.40 + 0.35*dBusy)) hitAtHuman("snare", beat4, 0.28);
        }
        // occasional kick
        if (chance(0.20 + 0.38*dBusy)) hitAtHuman("kick", 0, 0.32);
        if (chance(0.20 + 0.38*dBusy)) hitAtHuman("kick", beat3, 0.30);
      }
      else if (groove==="brushBallad"){
        // gentle hats + snare swish
        hitAtHuman("hat", 0, 0.30);
        if (hasFourBeats) hitAtHuman("hat", beat2, 0.28);
        hitAtHuman("hat", mid, 0.30);
        if (hasFourBeats) hitAtHuman("hat", beat4, 0.28);
        if (chance(0.35 + 0.35*dBusy)) hitAtHuman("snare", late2, 0.23);
        if (chance(0.20 + 0.30*dBusy)) hitAtHuman("kick", 0, 0.20);
      }
      else if (groove==="bossa" || groove==="samba" || groove==="afroCuban"){
        // simple clave-ish
        hitAtHuman("hat", 0, 0.32);
        hitAtHuman("hat", step*4, 0.28);
        hitAtHuman("hat", mid, 0.32);
        hitAtHuman("hat", mid + beat, 0.28);
        hitAtHuman("kick", 0, 0.33);
        hitAtHuman("kick", mid, 0.28);
        if (chance(0.35 + 0.35*dBusy)) hitAtHuman("snare", step*6, 0.22);
        if (chance(0.35 + 0.35*dBusy)) hitAtHuman("snare", late, 0.22);
        if (chance(0.30 + 0.35*dBusy)) hitAtHuman("hat", step*2 + swingDelay, 0.22);
      }
      else if (groove==="funk" || groove==="hiphop"){
        for (let i=0;i<beatCount*4;i+=2){
          const swing = (i%4===2) ? swingDelay : 0;
          hitAtHuman("hat", i*step + swing, 0.24 + 0.10*dBusy + (i%8===0?0.05:0));
          if (chance(0.25 + 0.35*dBusy) && i%4===1){
            hitAtHuman("hat", (i+1)*step + swingDelay*0.6, 0.18 + 0.10*dBusy);
          }
        }
        hitAtHuman("kick", 0, 0.42);
        if (chance(0.45 + 0.4*dBusy)) hitAtHuman("kick", step*3, 0.34);
        if (chance(0.45 + 0.4*dBusy)) hitAtHuman("kick", late2, 0.35);
        if (hasFourBeats){
          hitAtHuman("snare", beat2, 0.34);
          hitAtHuman("snare", beat4, 0.38);
        } else {
          hitAtHuman("snare", mid, 0.36);
        }
        if (chance(0.35 + 0.35*dBusy)) hitAtHuman("snare", mid + step, 0.18);
      }
      else if (groove==="house" || groove==="techno" || groove==="disco"){
        hitAtHuman("kick", 0, 0.55);
        hitAtHuman("kick", step*4, 0.55);
        hitAtHuman("kick", mid, 0.55);
        hitAtHuman("kick", mid + beat, 0.55);
        hitAtHuman("hat", step*2, 0.26);
        hitAtHuman("hat", step*6, 0.26);
        hitAtHuman("hat", late2, 0.26);
        hitAtHuman("hat", late, 0.26);
        if (hasFourBeats && chance(0.55 + 0.25*dBusy)) hitAtHuman("snare", beat2, 0.30);
        if (hasFourBeats && chance(0.55 + 0.25*dBusy)) hitAtHuman("snare", beat4, 0.33);
        if (groove==="disco") hitAtHuman("snare", mid, 0.34);
      }
      else if (groove==="dnb" || groove==="breaks"){
        hitAtHuman("kick", 0, 0.55);
        if (hasFourBeats) hitAtHuman("snare", beat2, 0.40);
        hitAtHuman("snare", mid, 0.45);
        if (chance(0.5 + 0.4*dBusy)) hitAtHuman("kick", step*6, 0.40);
        if (chance(0.5 + 0.4*dBusy)) hitAtHuman("snare", late, 0.34);
        hitAtHuman("hat", step*2, 0.28);
        hitAtHuman("hat", step*4, 0.26);
        hitAtHuman("hat", step*6, 0.28);
        hitAtHuman("hat", late2, 0.26);
        hitAtHuman("hat", mid + beat, 0.28);
        if (chance(0.35 + 0.35*dBusy)) hitAtHuman("kick", beat3 + step*2, 0.32);
      }
      else if (groove==="rock" || groove==="shuffle"){
        hitAtHuman("kick", 0, 0.55);
        if (hasFourBeats){
          hitAtHuman("snare", beat2, 0.46);
          hitAtHuman("snare", beat4, 0.50);
        } else {
          hitAtHuman("snare", mid, 0.50);
        }
        if (chance(0.45 + 0.35*dBusy)) hitAtHuman("kick", late2, 0.40);
        hitAtHuman("hat", step*2 + swingDelay*0.5, 0.30);
        hitAtHuman("hat", step*6 + swingDelay*0.5, 0.28);
        hitAtHuman("hat", late2 + swingDelay*0.5, 0.30);
        hitAtHuman("hat", late + swingDelay*0.5, 0.28);
        if (chance(0.30 + 0.35*dBusy)) hitAtHuman("kick", beat3 + step, 0.32);
      }
      else if (groove==="boomBap"){
        for (let i=0;i<beatCount*4;i+=2){
          const swing = (i%4===2) ? swingDelay : 0;
          hitAtHuman("hat", i*step + swing, 0.22 + 0.08*dBusy + (i%8===0?0.05:0));
          if (chance(0.22 + 0.35*dBusy) && i%8===4){
            hitAtHuman("hat", (i+1)*step + swingDelay*0.4, 0.16 + 0.08*dBusy);
          }
        }
        hitAtHuman("kick", 0, 0.45);
        if (chance(0.45 + 0.35*dBusy)) hitAtHuman("kick", step*5, 0.32);
        if (hasFourBeats){
          hitAtHuman("snare", beat2, 0.40);
          hitAtHuman("snare", beat4, 0.44);
        } else {
          hitAtHuman("snare", mid, 0.42);
        }
        if (chance(0.30 + 0.35*dBusy)) hitAtHuman("snare", mid + step*2, 0.18);
      }
      else if (groove==="trap"){
        for (let i=0;i<beatCount*4;i++){
          const swing = (i%2===1) ? swingDelay*0.6 : 0;
          hitAtHuman("hat", i*step + swing, 0.20 + 0.12*dBusy + (i%4===0?0.06:0));
          if (chance(0.20 + 0.35*dBusy) && i%4===2){
            hitAtHuman("hat", (i+0.5)*step + swingDelay*0.4, 0.14 + 0.10*dBusy);
          }
        }
        hitAtHuman("kick", 0, 0.50);
        if (chance(0.55 + 0.35*dBusy)) hitAtHuman("kick", step*3, 0.38);
        if (chance(0.45 + 0.35*dBusy)) hitAtHuman("kick", late2, 0.36);
        hitAtHuman("snare", mid, 0.42);
      }
      else if (groove==="reggae"){
        for (let i=0;i<beatCount*4;i+=2){
          hitAtHuman("hat", i*step, 0.20 + 0.08*dBusy + (i%4===2?0.06:0));
        }
        hitAtHuman("kick", beat3, 0.38);
        if (hasFourBeats){
          hitAtHuman("snare", beat2 + step*2, 0.24);
          hitAtHuman("snare", beat4 + step*2, 0.28);
        } else {
          hitAtHuman("snare", mid + step*2, 0.26);
        }
      }
      else if (groove==="afrobeat"){
        hitAtHuman("kick", 0, 0.42);
        if (chance(0.45 + 0.35*dBusy)) hitAtHuman("kick", step*5, 0.34);
        if (chance(0.45 + 0.35*dBusy)) hitAtHuman("kick", mid + step*2, 0.34);
        for (let i=0;i<beatCount*4;i+=2){
          hitAtHuman("hat", i*step + (i%4===2 ? swingDelay*0.5 : 0), 0.22 + 0.10*dBusy);
        }
        if (hasFourBeats){
          hitAtHuman("snare", beat2, 0.34);
          hitAtHuman("snare", beat4, 0.38);
        } else {
          hitAtHuman("snare", mid, 0.36);
        }
        if (chance(0.30 + 0.35*dBusy)) hitAtHuman("snare", late2, 0.20);
      }
      else if (groove==="halfTime"){
        for (let i=0;i<beatCount*4;i+=2){
          hitAtHuman("hat", i*step, 0.22 + 0.10*dBusy + (i%8===0?0.05:0));
        }
        hitAtHuman("kick", 0, 0.50);
        if (chance(0.45 + 0.35*dBusy)) hitAtHuman("kick", beat3 + step*2, 0.36);
        hitAtHuman("snare", mid, 0.46);
      }
      else if (groove==="ambient"){
        if (chance(0.25 + 0.55*dBusy)) hitAt("hat", step*2, 0.18);
        if (chance(0.25 + 0.55*dBusy)) hitAt("ride", mid + step, 0.18);
      }

      // drum fill near end
      if (isBarEnd && chance(fillChance)){
        const fillSlots = [
          dur*0.74, dur*0.80, dur*0.86, dur*0.92
        ];
        const fillType = Math.random();
        if (fillType < 0.33){
          hitAtHuman("hat", fillSlots[0], 0.18 + 0.16*dBusy);
          hitAtHuman("snare", fillSlots[1], 0.22 + 0.22*dBusy);
          hitAtHuman("snare", fillSlots[2], 0.26 + 0.24*dBusy);
          hitAtHuman("kick", fillSlots[3], 0.28 + 0.22*dBusy);
        } else if (fillType < 0.66){
          hitAtHuman("snare", fillSlots[0], 0.22 + 0.20*dBusy);
          hitAtHuman("snare", fillSlots[1], 0.24 + 0.22*dBusy);
          hitAtHuman("snare", fillSlots[2], 0.28 + 0.26*dBusy);
          hitAtHuman("hat", fillSlots[3], 0.20 + 0.18*dBusy);
        } else {
          hitAtHuman("kick", fillSlots[0], 0.28 + 0.20*dBusy);
          hitAtHuman("kick", fillSlots[1], 0.26 + 0.20*dBusy);
          hitAtHuman("snare", fillSlots[2], 0.30 + 0.26*dBusy);
          hitAtHuman("hat", fillSlots[3], 0.22 + 0.20*dBusy);
        }
      }
      if (drumHitCount===0 && dLvl>0.01){
        hitAt("kick", 0, 0.45);
        hitAt("hat", mid, 0.25);
      }

      // advance
      nextStep();
    }

    function start(){
      if (isPlaying) return;
      isPlaying = true;
      E.btnPlay.textContent = "‚è∏Ô∏è";
      E.btnPlay.classList.add("primary");

      setTempo(state.tempo, state.swing);
      setChart(state.chartBars, state.playbackOrder);
      jumpTo(state.activeBar, state.activeHalf);

      // schedule loop at the length of the current step
      const tick = () => {
        if (!isPlaying) return;
        const barIdx = order[atStep] ?? atStep;
        const bar = chart[barIdx];
        const dur = (bar?.split ? halfSeconds() : barSeconds());
        scheduleStep();
        timer = window.setTimeout(tick, Math.max(40, dur*1000 - 8));
      };
      tick();
    }

    function stop(){
      if (!isPlaying) return;
      isPlaying = false;
      if (timer) window.clearTimeout(timer);
      timer = null;
      AudioKit.hardStop();
      E.btnPlay.textContent = "‚ñ∂Ô∏è";
      E.btnPlay.classList.remove("primary");
      // keep UI + chord preview working after pause (bug fix)
      renderHeaderPills();
      renderPianoForActive();
    }

    function toggle(){
      if (isPlaying) stop(); else start();
    }

    function isOn(){ return isPlaying; }

    return { start, stop, toggle, isOn, jumpTo, setTempo, setChart };
  })();

  /* ---------- Undo / Redo (last 5) ---------- */
  const history = {
    undo: [],
    redo: [],
    max: 5
  };

  function snapshot(){
    // keep it small but complete for expected edits
    return {
      chartBars: structuredClone(state.chartBars),
      activeBar: state.activeBar,
      activeHalf: state.activeHalf,
      // settings we want undoable
      bars: state.bars,
      halfEnabled: state.halfEnabled,
      halfDensity: state.halfDensity,
      tempo: state.tempo,
      swing: state.swing,
      chaos: state.chaos,
      complexity: state.complexity,
      rootMode: state.rootMode,
      progressionLogic: state.progressionLogic,
      genrePreset: state.genrePreset,
      grooveStyle: state.grooveStyle,
      compStyle: state.compStyle,
      bassPreset: state.bassPreset,
      keysPreset: state.keysPreset,
      drumsPreset: state.drumsPreset,
      drumsLevel: state.drumsLevel,
      keysComplex: state.keysComplex,
      keysFill: state.keysFill,
      bassComplex: state.bassComplex,
      bassFill: state.bassFill,
      drumsComplex: state.drumsComplex,
      drumsFill: state.drumsFill,
      scalesUsed: state.scalesUsed,
      scaleLimitEnabled: state.scaleLimitEnabled,
      limiter: structuredClone(state.limiter),
      pageTheme: state.pageTheme,
      pianoTheme: state.pianoTheme,
      markerStyle: state.markerStyle,
      viewMode: state.viewMode,
      fretTheme: state.fretTheme,
      fretLefty: state.fretLefty,
      fretNumbers: state.fretNumbers,
      morphBg: state.morphBg,
      kbOct: state.kbOct,
      playbackOrder: structuredClone(state.playbackOrder),
      currentSongTitle: state.currentSongTitle
    };
  }

  function restoreSnap(s){
    if (!s) return;
    state.chartBars = structuredClone(s.chartBars||[]);
    state.activeBar = s.activeBar||0;
    state.activeHalf = s.activeHalf||0;

    Object.assign(state, {
      bars: s.bars, halfEnabled:s.halfEnabled, halfDensity:s.halfDensity,
      tempo:s.tempo, swing:s.swing, chaos:s.chaos, complexity: s.complexity ?? state.complexity,
      rootMode:s.rootMode, progressionLogic:s.progressionLogic, genrePreset:s.genrePreset,
      grooveStyle:s.grooveStyle, compStyle:s.compStyle,
      bassPreset:s.bassPreset, keysPreset:s.keysPreset, drumsPreset:s.drumsPreset,
      drumsLevel:s.drumsLevel,
      keysComplex:s.keysComplex, keysFill:s.keysFill,
      bassComplex:s.bassComplex, bassFill:s.bassFill,
      drumsComplex:s.drumsComplex, drumsFill:s.drumsFill,
      scalesUsed:s.scalesUsed,
      scaleLimitEnabled: s.scaleLimitEnabled ?? state.scaleLimitEnabled,
      limiter: structuredClone(s.limiter||state.limiter),
      pageTheme:s.pageTheme, pianoTheme:s.pianoTheme,
      markerStyle:s.markerStyle, viewMode:s.viewMode, fretTheme:s.fretTheme, fretLefty:s.fretLefty, fretNumbers:s.fretNumbers, morphBg:s.morphBg, kbOct:s.kbOct,
      playbackOrder: structuredClone(s.playbackOrder||[]),
      currentSongTitle: s.currentSongTitle || ""
    });

    // push to UI
    syncUIFromState();
    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);
    applyFretTheme(state.fretTheme);
    E.markerStyle.value = state.markerStyle;
    applyMorphBg(state.morphBg);
    renderAll();
    saveAll();
  }

  function pushHistory(){
    history.undo.push(snapshot());
    if (history.undo.length > history.max) history.undo.shift();
    history.redo.length = 0;
    updateUndoRedoButtons();
  }

  function doUndo(){
    if (!history.undo.length) return;
    history.redo.push(snapshot());
    const s = history.undo.pop();
    restoreSnap(s);
    updateUndoRedoButtons();
  }

  function doRedo(){
    if (!history.redo.length) return;
    history.undo.push(snapshot());
    const s = history.redo.pop();
    restoreSnap(s);
    updateUndoRedoButtons();
  }

  function updateUndoRedoButtons(){
    E.btnUndo.disabled = history.undo.length===0;
    E.btnRedo.disabled = history.redo.length===0;
  }

  /* ---------- Generation (improved but still lightweight) ---------- */
  function chooseKeyCenter(){
    // "scalesUsed" caps distinct scales when limiter is on and still guides center drift
    // while keeping a visible ‚ÄúCenter‚Äù line for reference (not strict)
    state.keyRoot = rint(0,11);
    state.keyMode = pick(["ionian","dorian","mixolydian","aeolian","lydian"]);
  }

  function stepRoot(prevRoot, weights, ctx={}){
    // functional + key-aware root motion with short memory
    const f = clamp(weights.functional,0,100)/100;
    const rc = clamp(weights.rootChaos,0,100)/100;
    const ks = clamp(weights.keyStability,0,100)/100;
    const mem = clamp(weights.memoryKill,0,100)/100;

    const allowedSet = (ctx && ctx.allowedSet instanceof Set) ? ctx.allowedSet : null;
    const prevRoots = Array.isArray(ctx.prevRoots) ? ctx.prevRoots : [];

    const opts = new Map();
    const add = (root, w)=>{
      if (!Number.isFinite(w) || w<=0) return;
      const r = pc(root);
      opts.set(r, (opts.get(r)||0) + w);
    };

    add(prevRoot + 7, 18*f + 2);
    add(prevRoot - 5, 18*f + 2);
    add(prevRoot + 2, 7*f + 3);
    add(prevRoot - 2, 7*f + 3);
    add(prevRoot + 1, 2 + 10*rc);
    add(prevRoot - 1, 2 + 10*rc);

    const chaosFill = 0.5 + 8*rc;
    for (let r=0;r<12;r++) add(r, chaosFill/12);

    const keyMode = ctx?.keyMode;
    const keyRoot = (ctx && typeof ctx.keyRoot === "number") ? pc(ctx.keyRoot) : null;
    const keyScale = keyMode && SCALES[keyMode] ? SCALES[keyMode] : null;
    const keySet = (keyScale && keyRoot!=null) ? new Set(keyScale.map(i=>pc(keyRoot+i))) : null;

    if (keySet && keyRoot!=null){
      const modePull = ({keyed:1, drifting:0.6, orbiting:0.8, freefall:0.15}[ctx?.rootMode] ?? 0.7);
      const keyBias = ks * modePull;

      for (const r of keySet) add(r, 1 + 7*keyBias);
      add(keyRoot, 1.5 + 10*keyBias);
      add(pc(keyRoot+7), 1 + 8*keyBias);

      if (ctx?.rootMode === "orbiting"){
        for (const r of keySet){
          const d = pcDistance(r, keyRoot);
          add(r, (6 - d) * 0.6 * keyBias);
        }
      }

      const hasLeadingTone = modeHasLeadingTone(keyMode);
      const prevDeg = degreeIndexForRoot(prevRoot, keyRoot, keyMode);
      const prevFunc = functionGroupForDegree(prevDeg, hasLeadingTone);
      if (prevFunc !== "other"){
        const targets = (prevFunc === "tonic")
          ? [{group:"predom", w:1.2}, {group:"dominant", w:0.8}]
          : (prevFunc === "predom")
            ? [{group:"dominant", w:1.6}, {group:"tonic", w:0.5}]
            : [{group:"tonic", w:2.0}, {group:"predom", w:0.5}];
        const funcBias = 10 * f * modePull;
        for (const r of keySet){
          const deg = degreeIndexForRoot(r, keyRoot, keyMode);
          const func = functionGroupForDegree(deg, hasLeadingTone);
          for (const t of targets){
            if (func === t.group) add(r, funcBias * t.w);
          }
        }
      }
    }

    if (typeof ctx?.cadenceRoot === "number"){
      const weight = Number(ctx.cadenceWeight ?? 0.35);
      add(ctx.cadenceRoot, 6*weight + 10*f*weight);
    }

    let list = [...opts.entries()].map(([v,w])=>({v, w}));

    if (allowedSet){
      const filtered = list.filter(o=>allowedSet.has(pc(o.v)));
      if (filtered.length){
        list = filtered;
      } else if (allowedSet.size){
        list = [...allowedSet].map(r=>({v:r, w:1}));
      }
    }

    if (prevRoots.length){
      list = list.map(o=>{
        let mult = 1;
        prevRoots.forEach((r, idx)=>{
          if (pc(r) === pc(o.v)) mult *= (1 - mem * (0.55/(idx+1)));
        });
        return {v:o.v, w: Math.max(0.05, o.w * mult)};
      });
    }

    return weightedPick(list.length ? list : [{v:pc(prevRoot), w:1}]);
  }

  function chooseQuality(limit, weights, scaleSet=null, chordRoot=null, preferSet=null){
    const base = buildQualityOptions(limit);
    const qc = clamp(weights.qualityChaos,0,100)/100;
    const t  = clamp(weights.tension,0,100)/100;
    const ks = clamp(weights.keyStability,0,100)/100;
    const rootPc = chordRoot!=null ? pc(chordRoot) : null;
    // tilt toward more colorful when chaos/tension higher
    const filtered = base.filter(o=>{
      if (!scaleSet || rootPc==null) return true;
      const tones = (CHORDS[o.v.symbol] || []).map(iv=>pc(rootPc + iv));
      return tones.every(p=>scaleSet.has(p));
    });
    const pool = filtered.length ? filtered : base;
    return weightedPick(pool.map(o=>{
      let w = o.w;
      if (o.v.family==="dom" && (o.v.symbol.includes("b9")||o.v.symbol.includes("sharp9"))) w *= (1 + 1.2*t);
      if (o.v.symbol.includes("9") || o.v.symbol.includes("11") || o.v.symbol.includes("13")) w *= (1 + 0.6*qc);
      if (o.v.family==="dim"||o.v.family==="hdim") w *= (1 + 0.4*qc);
      if (preferSet && rootPc!=null){
        const tones = (CHORDS[o.v.symbol] || []).map(iv=>pc(rootPc + iv));
        const inPrefer = tones.every(p=>preferSet.has(p));
        const bias = 0.35 + 0.9*ks;
        w *= inPrefer ? (1 + bias) : (1 - bias*0.6);
      }
      return {v:o.v, w: Math.max(0.05, w)};
    }));
  }

  function maybeSlash(ch, limit, weights){
    if (!limit.tSlash) return ch;
    const t = clamp(weights.tension,0,100)/100;
    if (!chance(0.10 + 0.25*t)) return ch;

    // choose slash from chord tones or step below root
    const pcs = chordTonesPCs(ch);
    const opt = chance(0.7) ? pick(pcs) : pc(ch.root + (chance(0.5)? -1 : 1));
    return {...ch, slash: opt};
  }

  function maybeAlt(ch, limit, weights){
    if (ch.family!=="dom") return ch;
    if (!limit.tAlt) return ch;
    const t = clamp(weights.tension,0,100)/100;
    if (!chance(0.10 + 0.35*t)) return ch;
    // represent ‚Äúalt‚Äù by choosing altered-ish tensions (we approximate by b9/#9)
    if (limit.tB9 && chance(0.55)) return {...ch, symbol:"dom7b9", intervals:CHORDS.dom7b9};
    if (limit.tSharp9 && chance(0.55)) return {...ch, symbol:"dom7sharp9", intervals:CHORDS.dom7sharp9};
    return ch;
  }

  function makeChord(root, q){
    return {
      root: pc(root),
      symbol: ({
        maj:"", min:"m",
        maj7:"maj7", maj9:"maj9", maj6:"6", "6/9":"6/9", add9:"add9", maj9sharp11:"maj9(#11)",
        min7:"m7", min9:"m9", min6:"m6", min11:"m11",
        minMaj7:"mMaj7", minMaj9:"mMaj9",
        dom7:"7", dom9:"9", dom11:"11", dom13:"13", dom7b9:"7(b9)", dom7sharp9:"7(#9)", dom7b13:"7(b13)",
        sus:"sus", "7sus":"7sus",
        halfdim:"√∏7", dim7:"dim7"
      }[q.symbol] || q.display || q.symbol),
      family: q.family,
      key: q.key,
      intervals: CHORDS[q.symbol] || CHORDS.dom7,
      scaleRoot: pc(root)
    };
  }

  function generateChart(){
    if (state.lockProg) return;

    pushHistory();

    chooseKeyCenter();

    const scaleLimiterOn = state.scaleLimitEnabled ?? true;
    const singleScale = (scaleLimiterOn && state.scalesUsed===1 && SCALES[state.keyMode])
      ? new Set(SCALES[state.keyMode].map(i=>pc(state.keyRoot+i)))
      : null;
    const keyScaleSet = SCALES[state.keyMode]
      ? new Set(SCALES[state.keyMode].map(i=>pc(state.keyRoot+i)))
      : null;
    const preferSet = (state.rootMode === "freefall") ? null : (singleScale || keyScaleSet);
    const ensureInScale = (r)=>{
      if (!singleScale) return pc(r);
      const rp = pc(r);
      if (singleScale.has(rp)) return rp;
      const arr=[...singleScale];
      return arr.length ? arr[0] : rp;
    };

    // weights influenced by chaos + progressionLogic
    let w = macroToWeights(state.chaos);
    const logic = PROGRESSION_LOGICS[state.progressionLogic] || PROGRESSION_LOGICS.jazzFunctional;
    w = logic.apply(w, state.chaos);
    state.weights = w;

    const barsTarget = clamp(Number(state.bars)||8, 2, 32);

    const limit = state.limiter;
    const cadencePlan = buildCadencePlan(barsTarget, state.keyRoot, state.keyMode, w);

    const bars = [];
    let root = ensureInScale(state.keyRoot);
    const recentRoots = [];

    // controlled ‚Äúcenter drift‚Äù: allow only N center changes, spread across bars
    const driftBudget = clamp(Number(state.scalesUsed)||8, 1, 32);
    let driftLeft = driftBudget;
    let lastDriftAt = -999;

    for (let b=0;b<barsTarget;b++){
      const split = state.halfEnabled && chance(clamp(state.halfDensity,0,100)/100);

      const chordCount = split ? 2 : 1;
      const chordArr = [];

      for (let h=0;h<chordCount;h++){
        // occasional drift
        const driftChance = clamp(w.rootChaos,0,100)/100 * 0.30 + (b>0 && (b-lastDriftAt)>3 ? 0.07 : 0);
        const cadence = cadencePlan.get(b);
        const cadenceRoot = (cadence && h===chordCount-1) ? cadence.root : null;
        const cadenceWeight = cadence ? cadence.weight : 0;
        if (driftLeft>0 && chance(driftChance)){
          root = ensureInScale(rint(0,11));
          driftLeft--;
          lastDriftAt = b;
        } else {
          root = ensureInScale(stepRoot(root, w, {
            allowedSet: singleScale,
            keyRoot: state.keyRoot,
            keyMode: state.keyMode,
            rootMode: state.rootMode,
            prevRoots: recentRoots,
            cadenceRoot,
            cadenceWeight
          }));
        }

        // pick quality (tied to limiters)
        const q = chooseQuality(limit, w, singleScale, root, preferSet);
        let ch = makeChord(root, q);

        // more ‚Äújazz‚Äù feeling: nudge dom chords toward ii-V-ish by biasing a ii before V
        if (logic===PROGRESSION_LOGICS.jazzFunctional && ch.family==="dom" && chance(0.35)){
          // if this is first half, try set this chord as ii and next as V
          if (split && h===0){
            const iiRoot = pc(root - 5); // ii is a 5th below V
            const qii = limit.qMin7 ? {symbol:"min7",family:"min",key:"min7",display:"m7"} : q;
            ch = makeChord(iiRoot, qii);
          }
        }

        ch = maybeAlt(ch, limit, w);
        ch = maybeSlash(ch, limit, w);

        // chromatic option: side-slip roots (only if limiter allows chromatic)
        if (limit.tChrom && chance(clamp(w.rootChaos,0,100)/100 * 0.18)){
          ch.root = pc(ch.root + (chance(0.5)? 1 : -1));
          ch.scaleRoot = ch.root;
        }

        chordArr.push(ch);
        recentRoots.unshift(root);
        if (recentRoots.length > 4) recentRoots.pop();
      }

      bars.push({ split, chords: chordArr });
    }

    assignChordModesWithLimit(bars);

    state.chartBars = bars;
    state.playbackOrder = state.chartBars.map((_, i)=>i);
    state.currentSongTitle = "";
    state.activeBar = 0;
    state.activeHalf = 0;

    renderAll();
    saveAll();
  }

  /* ---------- Tap behavior (focus + preview) ---------- */
  function onBarTap(b, h, preview){
    state.activeBar = clamp(b,0,Math.max(0,state.chartBars.length-1));
    const bar = state.chartBars[state.activeBar];
    const hh = clamp(h,0,Math.max(0,(bar?.chords?.length||1)-1));
    state.activeHalf = hh;

    highlightActiveBar();
    renderHeaderPills();
    renderPianoForActive();

    // If edit mode, open editor instead of preview
    if (state.editMode){
      openEditFor(b, h);
      return;
    }

    if (preview){
      const ch = activeChord();
      if (ch){
        AudioKit.resume();
        // short preview chord
        AudioKit.playChord(ch, state.keysPreset, AudioKit.now()+0.01, bar?.split ? 0.38 : 0.55, 0.75);
        AudioKit.playBass(pc(ch.root), state.bassPreset, AudioKit.now()+0.01, 0.25, 0.65);
      }
    }
  }

  /* ---------- Edit modal ---------- */
  let editTarget = { bar:0, half:0 };

  function initEditDropdowns(){
    // roots
    E.editRoot.innerHTML = "";
    NOTE_NAMES.forEach((n,i)=>{
      const o=document.createElement("option");
      o.value=String(i);
      o.textContent=n;
      E.editRoot.appendChild(o);
    });

    // qualities (show current limiter-safe set, but allow common items anyway)
    const qualList = [
      {id:"maj7", name:"maj7"},
      {id:"maj9", name:"maj9"},
      {id:"6/9", name:"6/9"},
      {id:"add9", name:"add9"},
      {id:"m7", name:"m7"},
      {id:"m9", name:"m9"},
      {id:"m11", name:"m11"},
      {id:"mMaj7", name:"mMaj7"},
      {id:"7", name:"7"},
      {id:"9", name:"9"},
      {id:"13", name:"13"},
      {id:"7(b9)", name:"7(b9)"},
      {id:"7(#9)", name:"7(#9)"},
      {id:"sus", name:"sus"},
      {id:"7sus", name:"7sus"},
      {id:"√∏7", name:"√∏7"},
      {id:"dim7", name:"dim7"},
    ];
    E.editQual.innerHTML = "";
    qualList.forEach(q=>{
      const o=document.createElement("option");
      o.value=q.id; o.textContent=q.name;
      E.editQual.appendChild(o);
    });

    // slash
    E.editSlash.innerHTML = "";
    const none = document.createElement("option");
    none.value = "none";
    none.textContent = "(none)";
    E.editSlash.appendChild(none);
    NOTE_NAMES.forEach((n,i)=>{
      const o=document.createElement("option");
      o.value=String(i);
      o.textContent=n;
      E.editSlash.appendChild(o);
    });
  }

  function openEditFor(barIndex, halfIndex){
    editTarget = { bar:barIndex, half:halfIndex };
    const bar = state.chartBars[barIndex];
    const ch = bar?.chords?.[halfIndex] || bar?.chords?.[0] || null;

    E.editTitle.textContent = `Edit bar ${barIndex+1}${bar?.split ? (halfIndex===0?" (top)":" (bottom)") : ""}`;

    if (ch){
      E.editRoot.value = String(pc(ch.root));
      // map symbol back to dropdown-ish
      const sym = ch.symbol;
      const mapBack = {
        "m7":"m7","m9":"m9","m11":"m11","mMaj7":"mMaj7",
        "maj7":"maj7","maj9":"maj9","6/9":"6/9","add9":"add9","6":"6/9",
        "7":"7","9":"9","11":"11","13":"13","7(b9)":"7(b9)","7(#9)":"7(#9)",
        "sus":"sus","7sus":"7sus","√∏7":"√∏7","dim7":"dim7"
      };
      E.editQual.value = mapBack[sym] || "7";
      E.editSlash.value = (ch.slash==null) ? "none" : String(pc(ch.slash));
    } else {
      E.editRoot.value = "0";
      E.editQual.value = "7";
      E.editSlash.value = "none";
    }

    // placement default based on current bar split + tap half
    if (bar?.split){
      E.editPlace.value = (halfIndex===0) ? "half1" : "half2";
    } else {
      E.editPlace.value = "whole";
    }

    E.editBack.style.display = "flex";
  }

  function closeEdit(){
    E.editBack.style.display = "none";
  }

  function qualToChordMeta(val){
    // convert dropdown value to internal
    const v = String(val);
    if (v==="maj7") return {symbol:"maj7", family:"maj", key:"maj7", intervals:CHORDS.maj7};
    if (v==="maj9") return {symbol:"maj9", family:"maj", key:"maj9", intervals:CHORDS.maj9};
    if (v==="6/9") return {symbol:"6/9", family:"maj", key:"6/9", intervals:CHORDS["6/9"]};
    if (v==="add9") return {symbol:"add9", family:"maj", key:"add9", intervals:CHORDS.add9};

    if (v==="m7") return {symbol:"min7", family:"min", key:"min7", intervals:CHORDS.min7};
    if (v==="m9") return {symbol:"min9", family:"min", key:"min9", intervals:CHORDS.min9};
    if (v==="m11") return {symbol:"min11", family:"min", key:"min11", intervals:CHORDS.min11};
    if (v==="mMaj7") return {symbol:"minMaj7", family:"minmaj", key:"minMaj7", intervals:CHORDS.minMaj7};

    if (v==="7") return {symbol:"dom7", family:"dom", key:"dom7", intervals:CHORDS.dom7};
    if (v==="9") return {symbol:"dom9", family:"dom", key:"dom9", intervals:CHORDS.dom9};
    if (v==="13") return {symbol:"dom13", family:"dom", key:"dom13", intervals:CHORDS.dom13};
    if (v==="7(b9)") return {symbol:"dom7b9", family:"dom", key:"dom7b9", intervals:CHORDS.dom7b9};
    if (v==="7(#9)") return {symbol:"dom7sharp9", family:"dom", key:"dom7sharp9", intervals:CHORDS.dom7sharp9};

    if (v==="sus") return {symbol:"sus", family:"sus", key:"sus", intervals:CHORDS.sus};
    if (v==="7sus") return {symbol:"7sus", family:"sus", key:"7sus", intervals:CHORDS["7sus"]};

    if (v==="√∏7") return {symbol:"halfdim", family:"hdim", key:"halfdim", intervals:CHORDS.halfdim};
    if (v==="dim7") return {symbol:"dim7", family:"dim", key:"dim7", intervals:CHORDS.dim7};

    return {symbol:"dom7", family:"dom", key:"dom7", intervals:CHORDS.dom7};
  }

  function applyEdit(){
    pushHistory();

    const b = editTarget.bar;
    const h = editTarget.half;

    const root = pc(Number(E.editRoot.value)||0);
    const meta = qualToChordMeta(E.editQual.value);
    const slashVal = E.editSlash.value;
    const slash = (slashVal==="none") ? null : pc(Number(slashVal)||0);

    const newChord = {
      root,
      symbol: ({
        maj7:"maj7", maj9:"maj9", "6/9":"6/9", add9:"add9",
        min7:"m7", min9:"m9", min11:"m11", minMaj7:"mMaj7",
        dom7:"7", dom9:"9", dom13:"13", dom7b9:"7(b9)", dom7sharp9:"7(#9)",
        sus:"sus", "7sus":"7sus",
        halfdim:"√∏7", dim7:"dim7"
      }[meta.symbol] || "7"),
      family: meta.family,
      key: meta.key,
      intervals: meta.intervals,
      slash,
      scaleRoot: root
    };

    const place = E.editPlace.value;

    // ensure bar exists
    if (!state.chartBars[b]) state.chartBars[b] = { split:false, chords:[newChord] };
    const bar = state.chartBars[b];

    if (place==="whole"){
      bar.split = false;
      bar.chords = [newChord];
      state.activeBar = b;
      state.activeHalf = 0;
    } else {
      bar.split = true;
      if (!Array.isArray(bar.chords) || bar.chords.length<2){
        const existing = bar.chords?.[0] || newChord;
        bar.chords = [existing, existing];
      }
      if (place==="half1"){
        bar.chords[0] = newChord;
        state.activeBar = b;
        state.activeHalf = 0;
      } else {
        bar.chords[1] = newChord;
        state.activeBar = b;
        state.activeHalf = 1;
      }
    }

    assignChordModesWithLimit(state.chartBars);
    renderAll();
    saveAll();
    closeEdit();
  }

  function clearEdit(){
    pushHistory();
    const b = editTarget.bar;
    const place = E.editPlace.value;

    if (!state.chartBars[b]) return;
    const bar = state.chartBars[b];

    if (place==="whole"){
      bar.split = false;
      bar.chords = [];
    } else {
      bar.split = true;
      if (!Array.isArray(bar.chords) || bar.chords.length<2) bar.chords = [null,null];
      if (place==="half1") bar.chords[0] = null;
      if (place==="half2") bar.chords[1] = null;

      // if both halves empty, simplify
      if (!bar.chords[0] && !bar.chords[1]){
        bar.split = false;
        bar.chords = [];
      }
    }

    // if chart chord missing, regenerate a safe chord so playback won't break
    const fallback = makeChord(state.keyRoot, {symbol:"maj7",family:"maj",key:"maj7",display:"maj7"});
    if (!bar.chords?.length){
      bar.split = false;
      bar.chords = [fallback];
    } else {
      bar.chords = bar.chords.map(x=>x||fallback);
    }

    assignChordModesWithLimit(state.chartBars);
    renderAll();
    saveAll();
    closeEdit();
  }

  /* ---------- Randomization (respect locks) ---------- */
  function randBetween(a,b){ return rint(a,b); }

  function applyGenrePreset(id){
    const g = GENRE_PRESETS[id] || GENRE_PRESETS.modernJazz;
    state.genrePreset = id;

    // Do not change progression here
    if (!state.lockTime){
      state.tempo = randBetween(g.tempo[0], g.tempo[1]);
      state.swing = randBetween(g.swing[0], g.swing[1]);
      state.halfEnabled = !!g.halfOn;
      state.halfDensity = randBetween(g.halfDen[0], g.halfDen[1]);
    }

    if (!state.lockStyle){
      state.grooveStyle = g.groove;
      state.compStyle = g.comp;
      state.progressionLogic = g.logic;
    }

    if (!state.lockSounds){
      state.bassPreset = g.bass;
      state.keysPreset = g.keys;
      state.drumsPreset = g.drums;
      state.drumsLevel = clamp(g.dC,0,100); // use dC as a base for level-ish
    }

    // complexity/fill (feel-ish, consider under style lock)
    if (!state.lockStyle){
      state.keysComplex = clamp(g.kC,0,100);
      state.keysFill = clamp(g.kF,0,100);
      state.bassComplex = clamp(g.bC,0,100);
      state.bassFill = clamp(g.bF,0,100);
      state.drumsComplex = clamp(g.dC,0,100);
      state.drumsFill = clamp(g.dF,0,100);
    }

    AudioKit.updateSoundFontPrograms();
  }

  function randomizeGeneratorOnly(){
    if (state.lockProg) return;
    pushHistory();
    // choose logic & chaos a bit
    state.chaos = randBetween(10, 70);
    state.progressionLogic = pick(Object.keys(PROGRESSION_LOGICS));
    state.scalesUsed = randBetween(1, 32);

    generateChart();
    syncUIFromState();
    saveAll();
  }

  function randomizeTimeOnly(){
    if (state.lockTime) return;
    pushHistory();
    state.bars = randBetween(2, 32);
    state.tempo = randBetween(60, 220);
    state.swing = randBetween(50, 70);
    state.halfEnabled = chance(0.6);
    state.halfDensity = randBetween(10, 55);

    syncUIFromState();
    saveAll();
  }

  function randomizeFeelOnly(){
    if (state.lockStyle) return;
    pushHistory();
    state.chaos = randBetween(0, 100);
    state.rootMode = pick(["keyed","drifting","orbiting","freefall"]);
    state.grooveStyle = pick(GROOVES).id;
    state.compStyle = pick(COMP_STYLES).id;

    // some realism: match logic to groove loosely
    if (state.grooveStyle==="bossa" || state.grooveStyle==="afroCuban") state.progressionLogic = "latinTurns";
    if (state.grooveStyle==="rock") state.progressionLogic = "rockLogic";
    if (state.grooveStyle==="halfTime") state.progressionLogic = "rockLogic";
    if (state.grooveStyle==="disco") state.progressionLogic = "discoLogic";
    if (state.grooveStyle==="house" || state.grooveStyle==="techno" || state.grooveStyle==="trap") state.progressionLogic = "edmLogic";
    if (state.grooveStyle==="boomBap" || state.grooveStyle==="afrobeat") state.progressionLogic = "grooveFunk";
    if (state.grooveStyle==="reggae") state.progressionLogic = "dubReggae";
    if (state.grooveStyle==="swing") state.progressionLogic = "jazzFunctional";

    syncUIFromState();
    saveAll();
  }

  function randomizeSoundsOnly(){
    if (state.lockSounds) return;
    pushHistory();
    state.bassPreset = pick(["upright","contra","fretless","pizz","round","sub","pluck","pickBass","muted","fmBass","rubber","acid","reese","squareBass","wobble","mono"]);
    state.keysPreset = pick(["ep","piano","organ","harpsichord","accordion","strings","pad","choirPad","noisePad","fm","chip","bell","glass","celesta","vibes","marimba","harp","pluck2","guitarish","clavBright"]);
    state.drumsPreset = pick(["jazz","swing","shuffle","brushes","tight","rock","room","disco","lofi","minimal","ambient","electro","analog","house","trap","breaks","dnb","techno","boomBap","perc","latinKit","orchestral","free"]);
    state.drumsLevel = randBetween(35, 75);

    // fill/complexity often lives with ‚Äúsounds/playing‚Äù too
    state.keysComplex = randBetween(20, 90);
    state.keysFill = randBetween(0, 75);
    state.bassComplex = randBetween(20, 90);
    state.bassFill = randBetween(0, 65);
    state.drumsComplex = randBetween(20, 95);
    state.drumsFill = randBetween(0, 85);

    syncUIFromState();
    saveAll();
  }

  function randomizeLimitersOnly(){
    if (state.lockLimiters) return;
    pushHistory();

    const lim = {...state.limiter};

    // core families: keep at least one of maj/min/dom
    lim.qMaj7 = chance(0.85);
    lim.qMin7 = chance(0.85);
    lim.qDom7 = chance(0.85);
    lim.qDim7 = chance(0.20);
    lim.qHalfDim = chance(0.65);
    lim.qSus = chance(0.25);
    lim.qMinMaj = chance(0.20);

    if (!lim.qMaj7 && !lim.qMin7 && !lim.qDom7){
      lim.qDom7 = true;
      lim.qMaj7 = true;
    }

    // extensions
    lim.x9 = chance(0.70);
    lim.x11 = chance(0.45);
    lim.x13 = chance(0.50);
    lim.x6 = chance(0.45);
    lim.xAdd9 = chance(0.30);
    lim.xSharp11 = chance(0.28);
    lim.xMin11 = chance(0.28);

    // tension
    lim.tAlt = chance(0.45);
    lim.tSlash = chance(0.40);
    lim.tChrom = chance(0.35);
    lim.tB9 = chance(0.35);
    lim.tSharp9 = chance(0.35);

    state.limiter = lim;
    setChordLimiterState(lim);
    saveAll();
  }

  function randomizeAll(){
    pushHistory();

    // Style random should keep progression by default; but "Random All" can change it unless locked
    if (!state.lockTheme){
      const themeId = pick(Object.keys(PAGE_THEMES));
      applyPageTheme(themeId);
      const pTheme = pick(Object.keys(PIANO_THEMES));
      applyPianoTheme(pTheme);
      const fTheme = pick(Object.keys(FRET_THEMES));
      applyFretTheme(fTheme);
      state.markerStyle = pick(["dots","rings","triangles","squares"]);
      E.markerStyle.value = state.markerStyle;
      if (E.fretTheme) E.fretTheme.value = state.fretTheme;
      state.fretLefty = chance(0.15);
      if (E.fretLefty) E.fretLefty.checked = state.fretLefty;
      applyMorphBg(chance(0.8));
    }

    if (!state.lockTime){
      state.bars = randBetween(2, 32);
      state.tempo = randBetween(60, 220);
      state.swing = randBetween(50, 70);
      state.halfEnabled = chance(0.6);
      state.halfDensity = randBetween(10, 60);
    }

    if (!state.lockStyle){
      state.genrePreset = pick(Object.keys(GENRE_PRESETS));
      applyGenrePreset(state.genrePreset);
    } else {
      // if style locked, still allow chaos slight change?
      // no, keep it stable
    }

    applyComplexityMacro(state.complexity);

    // generator knobs
    if (!state.lockProg){
      // pick logic some
      state.progressionLogic = pick(Object.keys(PROGRESSION_LOGICS));
      generateChart();
    }

    syncUIFromState();
    renderAll();
    saveAll();
    if (state.soundFontUrl) loadSoundFontFromUrl(state.soundFontUrl);
  }

  /* ---------- Style Random (keep progression) ---------- */
  function styleRandom(){
    pushHistory();

    // keep progression ALWAYS here (per request)
    if (!state.lockTheme){
      applyPageTheme(pick(Object.keys(PAGE_THEMES)));
      applyPianoTheme(pick(Object.keys(PIANO_THEMES)));
      applyFretTheme(pick(Object.keys(FRET_THEMES)));
      state.markerStyle = pick(["dots","rings","triangles","squares"]);
      E.markerStyle.value = state.markerStyle;
      if (E.fretTheme) E.fretTheme.value = state.fretTheme;
      state.fretLefty = chance(0.15);
      if (E.fretLefty) E.fretLefty.checked = state.fretLefty;
      applyMorphBg(chance(0.85));
    }

    if (!state.lockStyle){
      state.genrePreset = pick(Object.keys(GENRE_PRESETS));
      applyGenrePreset(state.genrePreset);
    }

    if (!state.lockSounds){
      // also nudge sounds even if genre didn‚Äôt
      if (chance(0.55)) state.keysPreset = pick(["ep","piano","organ","harpsichord","accordion","strings","pad","choirPad","noisePad","fm","chip","bell","glass","celesta","vibes","marimba","harp","pluck2","guitarish","clavBright"]);
      if (chance(0.55)) state.bassPreset = pick(["upright","contra","fretless","pizz","round","sub","pluck","pickBass","muted","fmBass","rubber","acid","reese","squareBass","wobble","mono"]);
      if (chance(0.55)) state.drumsPreset = pick(["jazz","swing","shuffle","brushes","tight","rock","room","disco","lofi","minimal","ambient","electro","analog","house","trap","breaks","dnb","techno","boomBap","perc","latinKit","orchestral","free"]);
    }

    syncUIFromState();
    renderAll();
    saveAll();
  }

  /* ---------- Copy chart ---------- */
  function chartToText(){
    const parts = [];
    for (let b=0;b<state.chartBars.length;b++){
      const bar = state.chartBars[b];
      if (!bar) continue;
      if (bar.split && bar.chords?.length>=2){
        const a = bar.chords[0] ? chordName(bar.chords[0]) : "‚Äî";
        const c = bar.chords[1] ? chordName(bar.chords[1]) : "‚Äî";
        parts.push(`${a} / ${c}`);
      } else {
        const a = bar.chords?.[0] ? chordName(bar.chords[0]) : "‚Äî";
        parts.push(a);
      }
    }
    // group in 4-bar lines
    const lines = [];
    for (let i=0;i<parts.length;i+=4){
      lines.push(parts.slice(i,i+4).map(x=>`| ${x} `).join("") + "|");
    }
    return lines.join("\n");
  }

  async function copyChart(){
    const text = chartToText();
    try{
      await navigator.clipboard.writeText(text);
      E.msg.textContent = "Copied chart to clipboard ‚úÖ";
      setTimeout(()=>E.msg.textContent=" ", 1400);
    }catch{
      // fallback
      const ta=document.createElement("textarea");
      ta.value=text;
      document.body.appendChild(ta);
      ta.select();
      try{ document.execCommand("copy"); }catch{}
      document.body.removeChild(ta);
    }
  }

  /* ---------- Locks UI ---------- */
  function setLockBtn(btn, on, label){
    btn.classList.toggle("on", !!on);
    btn.innerHTML = (on ? "üîí" : "üîì");
  }

  function syncLocksUI(){
    setLockBtn(E.lockProgMini, state.lockProg, "Progression");
    setLockBtn(E.lockStyleMini, state.lockStyle, "Play style");
    setLockBtn(E.lockThemeMini, state.lockTheme, "Theme");
    setLockBtn(E.lockTimeMini, state.lockTime, "Timing");
    setLockBtn(E.lockSoundMini, state.lockSounds, "Sounds");
    setLockBtn(E.lockLimitMini, state.lockLimiters, "Limiters");
  }

  /* ---------- UI <-> State sync ---------- */
  function bindRangePair(rangeEl, numEl, onChange){
    const pull = ()=> {
      const v = Number(rangeEl.value);
      numEl.value = String(v);
      onChange(v);
    };
    const pullNum = ()=> {
      const v = clamp(Number(numEl.value||0), Number(rangeEl.min), Number(rangeEl.max));
      rangeEl.value = String(v);
      numEl.value = String(v);
      onChange(v);
    };
    rangeEl.addEventListener("input", pull);
    numEl.addEventListener("change", pullNum);
  }

  function syncComplexityUI(){
    const c = clamp(Number(state.complexity)||0, 0, 100);
    let msg = "Balanced: moderate density + scales.";
    if (c <= 0) msg = "Simple: no splits or extensions.";
    else if (c < 34) msg = "Simpler: fewer splits, scales, extensions.";
    else if (c >= 67) msg = "Complex: denser, more scales + extensions.";
    if (E.complexityMsg) E.complexityMsg.textContent = msg;
    if (E.complexity) E.complexity.title = msg;
  }

  function applyComplexityMacro(value){
    const raw = clamp(Number(value)||0, 0, 100);
    const c = raw / 100;
    const roll = (p)=> chance(clamp(p, 0, 1));

    if (!state.lockStyle){
      const jitter = (Math.random() - 0.5) * 16 * c;
      state.chaos = clamp(Math.round(6 + c*88 + jitter), 0, 100);
    }

    if (!state.lockTime){
      if (c <= 0){
        state.halfEnabled = false;
        state.halfDensity = 0;
      } else {
        state.halfEnabled = roll(c * 0.9);
        if (state.halfEnabled){
          const densityBase = 6 + c * 70;
          const densityJitter = (Math.random() - 0.5) * 14 * c;
          state.halfDensity = clamp(Math.round(densityBase + densityJitter), 0, 100);
        } else {
          state.halfDensity = 0;
        }
      }
    }

    if (!state.lockProg){
      const maxScale = state.scaleLimitEnabled ? 18 : 28;
      if (c <= 0){
        state.scalesUsed = 1;
      } else {
        const t = Math.random();
        const exp = 1 + Math.abs(c - 0.5) * 4;
        const curve = (c < 0.5)
          ? Math.pow(t, exp)
          : 1 - Math.pow(1 - t, exp);
        const target = 1 + Math.round(curve * (maxScale - 1));
        state.scalesUsed = clamp(target, 1, 32);
      }
    }

    if (!state.lockLimiters){
      const lim = {...state.limiter};

      if (c <= 0){
        lim.qMaj7 = true;
        lim.qMin7 = true;
        lim.qDom7 = true;
        lim.qDim7 = false;
        lim.qHalfDim = false;
        lim.qSus = false;
        lim.qMinMaj = false;

        lim.x9 = false;
        lim.x11 = false;
        lim.x13 = false;
        lim.x6 = false;
        lim.xAdd9 = false;
        lim.xSharp11 = false;
        lim.xMin11 = false;

        lim.tSlash = false;
        lim.tB9 = false;
        lim.tSharp9 = false;
        lim.tChrom = false;
        lim.tAlt = false;
      } else {
        lim.qMaj7 = true;
        lim.qMin7 = true;
        lim.qDom7 = true;
        lim.qDim7 = roll(c * 0.35);
        lim.qHalfDim = roll(c * 0.55);
        lim.qSus = roll(c * 0.45);
        lim.qMinMaj = roll(c * 0.25);

        lim.x9 = roll(c * 0.9);
        lim.x11 = roll(c * 0.75);
        lim.x13 = roll(c * 0.7);
        lim.x6 = roll(c * 0.8);
        lim.xAdd9 = roll(c * 0.6);
        lim.xSharp11 = roll(c * 0.5);
        lim.xMin11 = roll(c * 0.45);

        lim.tSlash = roll(c * 0.7);
        lim.tB9 = roll(c * 0.55);
        lim.tSharp9 = roll(c * 0.5);
        lim.tChrom = roll(c * 0.4);
        lim.tAlt = roll(c * 0.35);
      }

      state.limiter = lim;
      setChordLimiterState(lim);
    }
  }

  function syncScaleLimiterUI(){
    if (!E.scalesUsedMsg) return;
    if (state.scaleLimitEnabled){
      E.scalesUsedMsg.textContent = "Limiter on";
    } else {
      E.scalesUsedMsg.textContent = "Limiter off";
    }
  }

  function syncUIFromState(){
    E.bars.value = String(state.bars);
    E.barsNum.value = String(state.bars);

    E.halfChords.checked = !!state.halfEnabled;
    E.halfDensity.value = String(state.halfDensity);
    E.halfDensityNum.value = String(state.halfDensity);

    E.tempo.value = String(state.tempo);
    E.tempoNum.value = String(state.tempo);

    E.swing.value = String(state.swing);
    E.swingNum.value = String(state.swing);

    E.chaos.value = String(state.chaos);
    E.chaosNum.value = String(state.chaos);

    if (E.complexity) E.complexity.value = String(state.complexity);
    syncComplexityUI();

    E.rootMode.value = state.rootMode;

    E.progressionLogic.value = state.progressionLogic;
    E.genrePreset.value = state.genrePreset;

    E.grooveStyle.value = state.grooveStyle;
    E.compStyle.value = state.compStyle;

    E.scalesUsed.value = String(state.scalesUsed);
    E.scalesUsedNum.value = String(state.scalesUsed);
    if (E.scaleLimitEnabled) E.scaleLimitEnabled.checked = !!state.scaleLimitEnabled;
    syncScaleLimiterUI();

    E.bassPreset.value = state.bassPreset;
    E.keysPreset.value = state.keysPreset;
    E.drumsPreset.value = state.drumsPreset;

    E.drumsLevel.value = String(state.drumsLevel);
    E.drumsLevelNum.value = String(state.drumsLevel);

    E.keysComplex.value = String(state.keysComplex);
    E.keysComplexNum.value = String(state.keysComplex);
    E.keysFill.value = String(state.keysFill);
    E.keysFillNum.value = String(state.keysFill);

    E.bassComplex.value = String(state.bassComplex);
    E.bassComplexNum.value = String(state.bassComplex);
    E.bassFill.value = String(state.bassFill);
    E.bassFillNum.value = String(state.bassFill);

    E.drumsComplex.value = String(state.drumsComplex);
    E.drumsComplexNum.value = String(state.drumsComplex);
    E.drumsFill.value = String(state.drumsFill);
    E.drumsFillNum.value = String(state.drumsFill);

    E.pageTheme.value = state.pageTheme;
    E.pianoTheme.value = state.pianoTheme;
    E.fretTheme.value = state.fretTheme;
    E.fretLefty.checked = !!state.fretLefty;
    E.fretNumbers.checked = !!state.fretNumbers;
    E.markerStyle.value = state.markerStyle;
    E.morphBg.checked = !!state.morphBg;

    E.kbOct.value = String(state.kbOct);
    E.kbOctNum.value = String(state.kbOct);

    if (E.sfEnabled) E.sfEnabled.checked = !!state.soundFontEnabled;
    if (E.sfUrl) E.sfUrl.value = state.soundFontUrl || DEFAULT_SOUNDFONT_URL;
    AudioKit.updateSoundFontPrograms();

    setChordLimiterState(state.limiter);
    syncLocksUI();
    updateUndoRedoButtons();
  }


  /* ---------- Advanced: reorder main menus ---------- */
  const SECTION_IDS = [
    {id:"cardHeader", name:"Title bar"},
    {id:"cardPiano", name:"Instrument"},
    {id:"cardLead", name:"Lead sheet"},
    {id:"cardControls", name:"Controls"},
    {id:"cardLimiters", name:"Chord limiters"},
  ];

  function currentOrder(){
    const app = document.querySelector(".app");
    const ids = [];
    SECTION_IDS.forEach(s=>{
      const el = document.getElementById(s.id);
      if (el && el.parentElement===app) ids.push(s.id);
    });
    return ids;
  }

  function applyOrder(order){
    const app = document.querySelector(".app");
    order.forEach(id=>{
      const el = document.getElementById(id);
      if (el) app.appendChild(el);
    });
    try{ localStorage.setItem("fm_order", JSON.stringify(order)); }catch{}
  }

  function renderOrderList(){
    E.orderList.innerHTML = "";
    const order = currentOrder();
    order.forEach((id, idx)=>{
      const meta = SECTION_IDS.find(s=>s.id===id) || {name:id};
      const row = document.createElement("div");
      row.className = "modalRow";

      const left = document.createElement("div");
      left.className = "name";
      left.textContent = meta.name;

      const btns = document.createElement("div");
      btns.className = "reorderBtns";

      const up = document.createElement("button");
      up.className = "btn small";
      up.type = "button";
      up.textContent = "‚Üë";
      up.disabled = idx===0;
      up.addEventListener("click", ()=>{
        const o = currentOrder();
        const t = o[idx-1];
        o[idx-1] = o[idx];
        o[idx] = t;
        applyOrder(o);
        renderOrderList();
      });

      const down = document.createElement("button");
      down.className = "btn small";
      down.type = "button";
      down.textContent = "‚Üì";
      down.disabled = idx===order.length-1;
      down.addEventListener("click", ()=>{
        const o = currentOrder();
        const t = o[idx+1];
        o[idx+1] = o[idx];
        o[idx] = t;
        applyOrder(o);
        renderOrderList();
      });

      btns.appendChild(up);
      btns.appendChild(down);
      row.appendChild(left);
      row.appendChild(btns);
      E.orderList.appendChild(row);
    });
  }

  function resetDefaultOrder(){
    applyOrder(["cardHeader","cardPiano","cardLead","cardControls","cardLimiters"]);
    renderOrderList();
  }

  /* ---------- Persistence ---------- */
  function saveAll(){
    try{
      localStorage.setItem("fm_state", JSON.stringify({
        chartBars: state.chartBars,
        activeBar: state.activeBar,
        activeHalf: state.activeHalf,

        bars: state.bars,
        halfEnabled: state.halfEnabled,
        halfDensity: state.halfDensity,
        tempo: state.tempo,
        swing: state.swing,
        chaos: state.chaos,
        complexity: state.complexity,
        rootMode: state.rootMode,
        progressionLogic: state.progressionLogic,
        genrePreset: state.genrePreset,
        grooveStyle: state.grooveStyle,
        compStyle: state.compStyle,
        bassPreset: state.bassPreset,
        keysPreset: state.keysPreset,
        drumsPreset: state.drumsPreset,
        drumsLevel: state.drumsLevel,
        keysComplex: state.keysComplex,
        keysFill: state.keysFill,
        bassComplex: state.bassComplex,
        bassFill: state.bassFill,
        drumsComplex: state.drumsComplex,
        drumsFill: state.drumsFill,
        scalesUsed: state.scalesUsed,
        scaleLimitEnabled: state.scaleLimitEnabled,
        limiter: state.limiter,

        pageTheme: state.pageTheme,
        pianoTheme: state.pianoTheme,
        markerStyle: state.markerStyle,
        viewMode: state.viewMode,
        fretTheme: state.fretTheme,
        fretLefty: state.fretLefty,
        fretNumbers: state.fretNumbers,
        morphBg: state.morphBg,
        kbOct: state.kbOct,
        playbackOrder: state.playbackOrder,
        currentSongTitle: state.currentSongTitle,
        soundFontUrl: state.soundFontUrl,
        soundFontEnabled: state.soundFontEnabled,

        locks: {
          lockProg: state.lockProg,
          lockStyle: state.lockStyle,
          lockTheme: state.lockTheme,
          lockTime: state.lockTime,
          lockSounds: state.lockSounds,
          lockLimiters: state.lockLimiters
        }
      }));
    }catch{}
  }

  function loadAll(){
    const saved = safeJSONParse(safeStorageGet("fm_state"), null);
    if (!saved) return false;

    // chart
    state.chartBars = saved.chartBars || [];
    state.activeBar = saved.activeBar || 0;
    state.activeHalf = saved.activeHalf || 0;

    // settings
    Object.assign(state, {
      bars: saved.bars ?? state.bars,
      halfEnabled: saved.halfEnabled ?? state.halfEnabled,
      halfDensity: saved.halfDensity ?? state.halfDensity,
      tempo: saved.tempo ?? state.tempo,
      swing: saved.swing ?? state.swing,
      chaos: saved.chaos ?? state.chaos,
      complexity: saved.complexity ?? state.complexity,
      rootMode: saved.rootMode ?? state.rootMode,
      progressionLogic: saved.progressionLogic ?? state.progressionLogic,
      genrePreset: saved.genrePreset ?? state.genrePreset,
      grooveStyle: saved.grooveStyle ?? state.grooveStyle,
      compStyle: saved.compStyle ?? state.compStyle,
      bassPreset: saved.bassPreset ?? state.bassPreset,
      keysPreset: saved.keysPreset ?? state.keysPreset,
      drumsPreset: saved.drumsPreset ?? state.drumsPreset,
      drumsLevel: saved.drumsLevel ?? state.drumsLevel,
      keysComplex: saved.keysComplex ?? state.keysComplex,
      keysFill: saved.keysFill ?? state.keysFill,
      bassComplex: saved.bassComplex ?? state.bassComplex,
      bassFill: saved.bassFill ?? state.bassFill,
      drumsComplex: saved.drumsComplex ?? state.drumsComplex,
      drumsFill: saved.drumsFill ?? state.drumsFill,
      scalesUsed: saved.scalesUsed ?? state.scalesUsed,
      scaleLimitEnabled: saved.scaleLimitEnabled ?? state.scaleLimitEnabled,
      limiter: saved.limiter ?? state.limiter,

      pageTheme: saved.pageTheme ?? state.pageTheme,
      pianoTheme: saved.pianoTheme ?? state.pianoTheme,
      markerStyle: saved.markerStyle ?? state.markerStyle,
      viewMode: saved.viewMode ?? state.viewMode,
      fretTheme: saved.fretTheme ?? state.fretTheme,
      fretLefty: saved.fretLefty ?? state.fretLefty,
      fretNumbers: saved.fretNumbers ?? state.fretNumbers,
      morphBg: saved.morphBg ?? state.morphBg,
      kbOct: saved.kbOct ?? state.kbOct,
      playbackOrder: Array.isArray(saved.playbackOrder) ? saved.playbackOrder : [],
      currentSongTitle: saved.currentSongTitle ?? state.currentSongTitle,
      soundFontUrl: saved.soundFontUrl ?? state.soundFontUrl,
      soundFontEnabled: saved.soundFontEnabled ?? state.soundFontEnabled
    });

    if (!Array.isArray(state.playbackOrder) || !state.playbackOrder.length){
      state.playbackOrder = state.chartBars.map((_, i)=>i);
    }

    // locks
    const L = saved.locks || {};
    state.lockProg = !!L.lockProg;
    state.lockStyle = !!L.lockStyle;
    state.lockTheme = !!L.lockTheme;
    state.lockTime = !!L.lockTime;
    state.lockSounds = !!L.lockSounds;
    state.lockLimiters = !!L.lockLimiters;

    return true;
  }

  function loadOrder(){
    const o = safeJSONParse(safeStorageGet("fm_order"), null);
    if (Array.isArray(o) && o.length) applyOrder(o);
  }

  /* ---------- Defaults ---------- */
  function applyDefaults(){
    pushHistory();

    Object.assign(state, structuredClone(DEFAULTS));
    state.limiter = structuredClone(DEFAULTS.limiter);
    state.allowedCenters = [];

    // locks remain as-is? user asked ‚Äúdefaults‚Äù to reset after randoms.
    // Keep locks (so you can keep your locking strategy), but reset chart if unlocked:
    const keepLocks = {
      lockProg: state.lockProg,
      lockStyle: state.lockStyle,
      lockTheme: state.lockTheme,
      lockTime: state.lockTime,
      lockSounds: state.lockSounds,
      lockLimiters: state.lockLimiters
    };
    Object.assign(state, keepLocks);

    // apply themes immediately
    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);
    applyFretTheme(state.fretTheme);
    state.markerStyle = DEFAULTS.markerStyle;
    applyMorphBg(DEFAULTS.morphBg);

    // regenerate a safe chart only if progression not locked
    if (!state.lockProg){
      state.bars = DEFAULTS.bars;
      state.halfEnabled = DEFAULTS.halfEnabled;
      state.halfDensity = DEFAULTS.halfDensity;
      state.scalesUsed = DEFAULTS.scalesUsed;
      generateChart();
    } else {
      state.playbackOrder = state.chartBars.map((_, i)=>i);
    }

    syncUIFromState();
    renderAll();
    saveAll();
  }

  function isTypingField(target){
    const el = target;
    if (!el) return false;
    const tag = el.tagName;
    return tag === "INPUT" || tag === "TEXTAREA" || tag === "SELECT" || el.isContentEditable;
  }

  /* ---------- Bind UI events ---------- */
  function bindUI(){
    document.addEventListener("keydown", (ev)=>{
      if (ev.defaultPrevented) return;
      if (ev.metaKey || ev.ctrlKey || ev.altKey) return;
      if (isTypingField(ev.target)) return;

      switch (ev.code){
        case "Space":
          ev.preventDefault();
          if (E.btnPlay) E.btnPlay.click();
          break;
        case "KeyG":
          ev.preventDefault();
          if (E.btnGenerate) E.btnGenerate.click();
          break;
        case "ArrowLeft":
          ev.preventDefault();
          if (E.btnUndo) E.btnUndo.click();
          break;
        case "ArrowRight":
          ev.preventDefault();
          if (E.btnRedo) E.btnRedo.click();
          break;
        case "KeyR":
          ev.preventDefault();
          if (E.btnRandomAll) E.btnRandomAll.click();
          break;
        case "KeyT":
          ev.preventDefault();
          if (E.btnStyleRand) E.btnStyleRand.click();
          break;
        case "KeyC":
          ev.preventDefault();
          if (E.btnCopy) E.btnCopy.click();
          break;
        case "KeyD":
          ev.preventDefault();
          if (E.btnDefaults) E.btnDefaults.click();
          break;
      }
    });
    // ranges
    bindRangePair(E.bars, E.barsNum, (v)=>{ state.bars=v; saveAll(); });
    bindRangePair(E.halfDensity, E.halfDensityNum, (v)=>{ state.halfDensity=v; saveAll(); });
    bindRangePair(E.tempo, E.tempoNum, (v)=>{ state.tempo=v; saveAll(); });
    bindRangePair(E.swing, E.swingNum, (v)=>{ state.swing=v; saveAll(); });
    bindRangePair(E.chaos, E.chaosNum, (v)=>{ state.chaos=v; saveAll(); });
    if (E.complexity){
      E.complexity.addEventListener("input", ()=>{
        const v = Number(E.complexity.value || 0);
        state.complexity = v;
        syncComplexityUI();
        saveAll();
      });
    }
    bindRangePair(E.scalesUsed, E.scalesUsedNum, (v)=>{
      state.scalesUsed=v;
      assignChordModesWithLimit(state.chartBars);
      renderPianoForActive();
      saveAll();
    });
    if (E.scaleLimitEnabled){
      E.scaleLimitEnabled.addEventListener("change", ()=>{
        state.scaleLimitEnabled = !!E.scaleLimitEnabled.checked;
        syncScaleLimiterUI();
        assignChordModesWithLimit(state.chartBars);
        renderPianoForActive();
        saveAll();
      });
    }

    bindRangePair(E.drumsLevel, E.drumsLevelNum, (v)=>{ state.drumsLevel=v; saveAll(); });

    bindRangePair(E.keysComplex, E.keysComplexNum, (v)=>{ state.keysComplex=v; saveAll(); });
    bindRangePair(E.keysFill, E.keysFillNum, (v)=>{ state.keysFill=v; saveAll(); });

    bindRangePair(E.bassComplex, E.bassComplexNum, (v)=>{ state.bassComplex=v; saveAll(); });
    bindRangePair(E.bassFill, E.bassFillNum, (v)=>{ state.bassFill=v; saveAll(); });

    bindRangePair(E.drumsComplex, E.drumsComplexNum, (v)=>{ state.drumsComplex=v; saveAll(); });
    bindRangePair(E.drumsFill, E.drumsFillNum, (v)=>{ state.drumsFill=v; saveAll(); });

    bindRangePair(E.kbOct, E.kbOctNum, (v)=>{ state.kbOct=v; saveAll(); renderPianoForActive(); });

    // checkboxes
    E.halfChords.addEventListener("change", ()=>{
      state.halfEnabled = !!E.halfChords.checked;
      saveAll();
    });

    // selects
    E.rootMode.addEventListener("change", ()=>{ state.rootMode = E.rootMode.value; saveAll(); });
    E.progressionLogic.addEventListener("change", ()=>{ state.progressionLogic = E.progressionLogic.value; saveAll(); });
    E.grooveStyle.addEventListener("change", ()=>{ state.grooveStyle = E.grooveStyle.value; saveAll(); });
    E.compStyle.addEventListener("change", ()=>{ state.compStyle = E.compStyle.value; saveAll(); });
    E.bassPreset.addEventListener("change", ()=>{ state.bassPreset = E.bassPreset.value; AudioKit.updateSoundFontPrograms(); applyBiabPrograms(); saveAll(); });
    E.keysPreset.addEventListener("change", ()=>{ state.keysPreset = E.keysPreset.value; AudioKit.updateSoundFontPrograms(); applyBiabPrograms(); saveAll(); });
    E.drumsPreset.addEventListener("change", ()=>{ state.drumsPreset = E.drumsPreset.value; AudioKit.updateSoundFontPrograms(); applyBiabPrograms(); saveAll(); });
    E.genrePreset.addEventListener("change", ()=>{
      if (!state.lockStyle || !state.lockTime || !state.lockSounds){
        pushHistory();
        applyGenrePreset(E.genrePreset.value);
        syncUIFromState();
        saveAll();
      }
    });

    E.pageTheme.addEventListener("change", ()=>{
      if (state.lockTheme) return;
      pushHistory();
      applyPageTheme(E.pageTheme.value);
      saveAll();
    });
    E.pianoTheme.addEventListener("change", ()=>{
      pushHistory();
      applyPianoTheme(E.pianoTheme.value);
      saveAll();
      renderPianoForActive();
    });
    E.fretTheme.addEventListener("change", ()=>{
      pushHistory();
      applyFretTheme(E.fretTheme.value);
      saveAll();
      renderPianoForActive();
    });
    E.fretLefty.addEventListener("change", ()=>{
      pushHistory();
      state.fretLefty = !!E.fretLefty.checked;
      saveAll();
      renderPianoForActive();
    });
    E.fretNumbers.addEventListener("change", ()=>{
      pushHistory();
      state.fretNumbers = !!E.fretNumbers.checked;
      saveAll();
      renderPianoForActive();
    });
    E.markerStyle.addEventListener("change", ()=>{
      pushHistory();
      state.markerStyle = E.markerStyle.value;
      saveAll();
      renderPianoForActive();
    });

    E.morphBg.addEventListener("change", ()=>{
      pushHistory();
      applyMorphBg(E.morphBg.checked);
      saveAll();
    });

    if (E.btnSongFetch){
      E.btnSongFetch.addEventListener("click", ()=>{
        loadPlaylistFromUrl(E.songUrl ? E.songUrl.value : "");
      });
    }
    if (E.songSearch){
      E.songSearch.addEventListener("input", ()=>{
        songQuery = E.songSearch.value || "";
        renderSongList();
      });
    }
    if (E.songSort){
      E.songSort.addEventListener("change", ()=>{
        songSort = E.songSort.value || "playlist";
        renderSongList();
      });
    }
    if (E.btnSongRandom){
      E.btnSongRandom.addEventListener("click", ()=>{
        const list = filteredSongs();
        if (!list.length){
          setSongStatus("No songs to load.");
          return;
        }
        loadSongToChart(pick(list));
      });
    }
    if (E.songFile){
      E.songFile.addEventListener("change", async ()=>{
        const file = E.songFile.files && E.songFile.files[0];
        if (!file) return;
        if (isBiabFileName(file.name)){
          await loadBiabFromFile(file);
          if (E.songFile) E.songFile.value = "";
          return;
        }
        try{
          const text = await file.text();
          let parsed = [];
          try{
            parsed = parseIrealPlaylist(text);
          } catch {
            setSongStatus("Could not parse file.");
            if (E.songList) E.songList.innerHTML = "";
            return;
          }
          songLibrary = parsed;
          if (!songLibrary.length){
            setSongStatus("No songs found in file.");
            if (E.songList) E.songList.innerHTML = "";
            return;
          }
          renderSongList();
        } catch {
          setSongStatus("Could not read file.");
        }
      });
    }

    if (E.biabFile){
      E.biabFile.addEventListener("change", async ()=>{
        const file = E.biabFile.files && E.biabFile.files[0];
        if (!file) return;
        await loadBiabFromFile(file);
        if (E.biabFile) E.biabFile.value = "";
      });
    }

    if (E.sfEnabled){
      E.sfEnabled.addEventListener("change", ()=>{
        state.soundFontEnabled = !!E.sfEnabled.checked;
        if (!state.soundFontEnabled){
          AudioKit.soundFontAllNotesOff();
        } else if (state.soundFontUrl){
          loadSoundFontFromUrl(state.soundFontUrl);
        }
        AudioKit.updateSoundFontPrograms();
        applyBiabPrograms();
        saveAll();
      });
    }
    if (E.btnSfLoad){
      E.btnSfLoad.addEventListener("click", ()=>{
        const url = E.sfUrl ? E.sfUrl.value : "";
        loadSoundFontFromUrl(url);
      });
    }
    if (E.sfFile){
      E.sfFile.addEventListener("change", async ()=>{
        const file = E.sfFile.files && E.sfFile.files[0];
        if (!file) return;
        await loadSoundFontFromFile(file);
        if (E.sfFile) E.sfFile.value = "";
      });
    }

    // limiter checkboxes -> state
    document.getElementById("cardLimiters").addEventListener("change", (ev)=>{
      const t = ev.target;
      if (!(t instanceof HTMLInputElement)) return;
      if (t.type !== "checkbox") return;
      state.limiter = getChordLimiterState();
      saveAll();
    });

    // buttons
    E.btnPlay.addEventListener("click", async ()=>{
      await AudioKit.resume();
      player.toggle();
      saveAll();
    });

    E.btnGenerate.addEventListener("click", async ()=>{
      await AudioKit.resume();
      generateChart();
    });

    E.btnRandomAll.addEventListener("click", async ()=>{
      await AudioKit.resume();
      randomizeAll();
    });

    E.btnStyleRand.addEventListener("click", async ()=>{
      await AudioKit.resume();
      styleRandom();
    });

    E.btnDefaults.addEventListener("click", ()=>{
      applyDefaults();
    });

    E.btnUndo.addEventListener("click", ()=> doUndo());
    E.btnRedo.addEventListener("click", ()=> doRedo());

    E.btnCopy.addEventListener("click", ()=> copyChart());

    if (E.btnPianoToggle){
      E.btnPianoToggle.addEventListener("click", ()=>{
        state.viewMode = "piano";
        renderPianoForActive();
        saveAll();
      });
    }
    if (E.btnFretToggle){
      E.btnFretToggle.addEventListener("click", ()=>{
        state.viewMode = "fretboard";
        renderPianoForActive();
        saveAll();
      });
    }

    // sectional randoms
    E.btnRandGen.addEventListener("click", ()=> randomizeGeneratorOnly());
    E.btnRandTime.addEventListener("click", ()=> randomizeTimeOnly());
    E.btnRandFeel.addEventListener("click", ()=> randomizeFeelOnly());
    E.btnRandSounds.addEventListener("click", ()=> randomizeSoundsOnly());
    E.btnRandLimit.addEventListener("click", ()=> randomizeLimitersOnly());

    // locks
    E.lockProgMini.addEventListener("click", ()=>{
      state.lockProg = !state.lockProg;
      syncLocksUI();
      saveAll();
    });
    E.lockStyleMini.addEventListener("click", ()=>{
      state.lockStyle = !state.lockStyle;
      syncLocksUI();
      saveAll();
    });
    E.lockThemeMini.addEventListener("click", ()=>{
      state.lockTheme = !state.lockTheme;
      syncLocksUI();
      saveAll();
    });
    E.lockTimeMini.addEventListener("click", ()=>{
      state.lockTime = !state.lockTime;
      syncLocksUI();
      saveAll();
    });
    E.lockSoundMini.addEventListener("click", ()=>{
      state.lockSounds = !state.lockSounds;
      syncLocksUI();
      saveAll();
    });
    E.lockLimitMini.addEventListener("click", ()=>{
      state.lockLimiters = !state.lockLimiters;
      syncLocksUI();
      saveAll();
    });

    // edit mode toggle
    E.btnEdit.addEventListener("click", ()=>{
      state.editMode = !state.editMode;
      applyEditVisuals();
      saveAll();
    });

    // edit modal actions
    E.btnEditClose.addEventListener("click", ()=> closeEdit());
    E.btnEditCancel.addEventListener("click", ()=> closeEdit());
    E.btnEditApply.addEventListener("click", ()=> applyEdit());
    E.btnEditClear.addEventListener("click", ()=> clearEdit());
    E.editBack.addEventListener("click", (ev)=>{
      if (ev.target === E.editBack) closeEdit();
    });

    // advanced modal open/close
    E.btnGear.addEventListener("click", ()=>{
      E.advBack.style.display = "flex";
      renderOrderList();
    });
    E.btnCloseAdv.addEventListener("click", ()=>{
      E.advBack.style.display = "none";
      saveAll();
    });
    E.btnResetMenu.addEventListener("click", ()=> resetDefaultOrder());
    E.advBack.addEventListener("click", (ev)=>{
      if (ev.target === E.advBack) E.advBack.style.display = "none";
    });
  }

  /* ---------- Init ---------- */
  function boot(){
    initFeelDropdowns();
    initLogicDropdown();
    initGenreDropdown();
    initThemeDropdowns();
    initPianoThemeDropdown();
    initFretThemeDropdown();
    initEditDropdowns();

    loadOrder();

    let loaded = false;
    try{ loaded = loadAll(); }catch{ loaded = false; }
    // defaults for ‚Äúall menus collapsed‚Äù: details are collapsed by default in markup
    // set theme
    applyPageTheme(state.pageTheme);
    applyPianoTheme(state.pianoTheme);
    applyFretTheme(state.fretTheme);
    applyMorphBg(state.morphBg);

    // hydrate UI
    syncUIFromState();
    assignChordModesWithLimit(state.chartBars);

    bindUI();
    updateUndoRedoButtons();

    try{
      // if no saved chart, generate a default
      if (!loaded || !Array.isArray(state.chartBars) || state.chartBars.length===0){
        generateChart();
      } else {
        renderAll();
      }
    }catch (err){
      console.error(err);
      if (E.msg) E.msg.textContent = `Init error: ${err && err.message ? err.message : err}`;
    }

    const playlistUrl = DEFAULT_PLAYLIST_URL;
    if (E.songUrl) E.songUrl.value = playlistUrl;
    loadPlaylistFromUrl(playlistUrl);
    if (state.soundFontUrl) loadSoundFontFromUrl(state.soundFontUrl);

  }

  boot();

})();
</script>
</body>
</html>
